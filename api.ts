/* tslint:disable */
/* eslint-disable */
/**
 * LaunchDarkly REST API
 * # Overview  ## Authentication  All REST API resources are authenticated with either [personal or service access tokens](https://docs.launchdarkly.com/home/account-security/api-access-tokens), or session cookies. Other authentication mechanisms are not supported. You can manage personal access tokens on your [**Account settings**](https://app.launchdarkly.com/settings/tokens) page.  LaunchDarkly also has SDK keys, mobile keys, and client-side IDs that are used by our server-side SDKs, mobile SDKs, and JavaScript-based SDKs, respectively. **These keys cannot be used to access our REST API**. These keys are environment-specific, and can only perform read-only operations such as fetching feature flag settings.  | Auth mechanism                                                                                  | Allowed resources                                                                                     | Use cases                                          | | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | -------------------------------------------------- | | [Personal or service access tokens](https://docs.launchdarkly.com/home/account-security/api-access-tokens) | Can be customized on a per-token basis                                                                | Building scripts, custom integrations, data export. | | SDK keys                                                                                        | Can only access read-only resources specific to server-side SDKs. Restricted to a single environment. | Server-side SDKs                     | | Mobile keys                                                                                     | Can only access read-only resources specific to mobile SDKs, and only for flags marked available to mobile keys. Restricted to a single environment.           | Mobile SDKs                                        | | Client-side ID                                                                                  | Can only access read-only resources specific to JavaScript-based client-side SDKs, and only for flags marked available to client-side. Restricted to a single environment.           | Client-side JavaScript                             |  > #### Keep your access tokens and SDK keys private > > Access tokens should _never_ be exposed in untrusted contexts. Never put an access token in client-side JavaScript, or embed it in a mobile application. LaunchDarkly has special mobile keys that you can embed in mobile apps. If you accidentally expose an access token or SDK key, you can reset it from your [**Account settings**](https://app.launchdarkly.com/settings/tokens) page. > > The client-side ID is safe to embed in untrusted contexts. It\'s designed for use in client-side JavaScript.  ### Authentication using request header  The preferred way to authenticate with the API is by adding an `Authorization` header containing your access token to your requests. The value of the `Authorization` header must be your access token.  Manage personal access tokens from the [**Account settings**](https://app.launchdarkly.com/settings/tokens) page.  ### Authentication using session cookie  For testing purposes, you can make API calls directly from your web browser. If you are logged in to the LaunchDarkly application, the API will use your existing session to authenticate calls.  If you have a [role](https://docs.launchdarkly.com/home/team/built-in-roles) other than Admin, or have a [custom role](https://docs.launchdarkly.com/home/team/custom-roles) defined, you may not have permission to perform some API calls. You will receive a `401` response code in that case.  > ### Modifying the Origin header causes an error > > LaunchDarkly validates that the Origin header for any API request authenticated by a session cookie matches the expected Origin header. The expected Origin header is `https://app.launchdarkly.com`. > > If the Origin header does not match what\'s expected, LaunchDarkly returns an error. This error can prevent the LaunchDarkly app from working correctly. > > Any browser extension that intentionally changes the Origin header can cause this problem. For example, the `Allow-Control-Allow-Origin: *` Chrome extension changes the Origin header to `http://evil.com` and causes the app to fail. > > To prevent this error, do not modify your Origin header. > > LaunchDarkly does not require origin matching when authenticating with an access token, so this issue does not affect normal API usage.  ## Representations  All resources expect and return JSON response bodies. Error responses also send a JSON body. To learn more about the error format of the API, read [Errors](/#section/Overview/Errors).  In practice this means that you always get a response with a `Content-Type` header set to `application/json`.  In addition, request bodies for `PATCH`, `POST`, `PUT`, and `REPORT` requests must be encoded as JSON with a `Content-Type` header set to `application/json`.  ### Summary and detailed representations  When you fetch a list of resources, the response includes only the most important attributes of each resource. This is a _summary representation_ of the resource. When you fetch an individual resource, such as a single feature flag, you receive a _detailed representation_ of the resource.  The best way to find a detailed representation is to follow links. Every summary representation includes a link to its detailed representation.  ### Expanding responses  Sometimes the detailed representation of a resource does not include all of the attributes of the resource by default. If this is the case, the request method will clearly document this and describe which attributes you can include in an expanded response.  To include the additional attributes, append the `expand` request parameter to your request and add a comma-separated list of the attributes to include. For example, when you append `?expand=members,roles` to the [Get team](/tag/Teams#operation/getTeam) endpoint, the expanded response includes both of these attributes.  ### Links and addressability  The best way to navigate the API is by following links. These are attributes in representations that link to other resources. The API always uses the same format for links:  - Links to other resources within the API are encapsulated in a `_links` object - If the resource has a corresponding link to HTML content on the site, it is stored in a special `_site` link  Each link has two attributes:  - An `href`, which contains the URL - A `type`, which describes the content type  For example, a feature resource might return the following:  ```json {   \"_links\": {     \"parent\": {       \"href\": \"/api/features\",       \"type\": \"application/json\"     },     \"self\": {       \"href\": \"/api/features/sort.order\",       \"type\": \"application/json\"     }   },   \"_site\": {     \"href\": \"/features/sort.order\",     \"type\": \"text/html\"   } } ```  From this, you can navigate to the parent collection of features by following the `parent` link, or navigate to the site page for the feature by following the `_site` link.  Collections are always represented as a JSON object with an `items` attribute containing an array of representations. Like all other representations, collections have `_links` defined at the top level.  Paginated collections include `first`, `last`, `next`, and `prev` links containing a URL with the respective set of elements in the collection.  ## Updates  Resources that accept partial updates use the `PATCH` verb. Most resources support the [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) format. Some resources also support the [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) format, and some resources support the [semantic patch](/reference#updates-using-semantic-patch) format, which is a way to specify the modifications to perform as a set of executable instructions. Each resource supports optional [comments](/reference#updates-with-comments) that you can submit with updates. Comments appear in outgoing webhooks, the audit log, and other integrations.  When a resource supports both JSON patch and semantic patch, we document both in the request method. However, the specific request body fields and descriptions included in our documentation only match one type of patch or the other.  ### Updates using JSON patch  [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) is a way to specify the modifications to perform on a resource. JSON patch uses paths and a limited set of operations to describe how to transform the current state of the resource into a new state. JSON patch documents are always arrays, where each element contains an operation, a path to the field to update, and the new value.  For example, in this feature flag representation:  ```json {     \"name\": \"New recommendations engine\",     \"key\": \"engine.enable\",     \"description\": \"This is the description\",     ... } ``` You can change the feature flag\'s description with the following patch document:  ```json [{ \"op\": \"replace\", \"path\": \"/description\", \"value\": \"This is the new description\" }] ```  You can specify multiple modifications to perform in a single request. You can also test that certain preconditions are met before applying the patch:  ```json [   { \"op\": \"test\", \"path\": \"/version\", \"value\": 10 },   { \"op\": \"replace\", \"path\": \"/description\", \"value\": \"The new description\" } ] ```  The above patch request tests whether the feature flag\'s `version` is `10`, and if so, changes the feature flag\'s description.  Attributes that are not editable, such as a resource\'s `_links`, have names that start with an underscore.  ### Updates using JSON merge patch  [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) is another format for specifying the modifications to perform on a resource. JSON merge patch is less expressive than JSON patch. However, in many cases it is simpler to construct a merge patch document. For example, you can change a feature flag\'s description with the following merge patch document:  ```json {   \"description\": \"New flag description\" } ```  ### Updates using semantic patch  The API also supports the semantic patch format. A semantic patch is a way to specify the modifications to perform on a resource as a set of executable instructions.  Semantic patch allows you to be explicit about intent using precise, custom instructions. In many cases, you can define semantic patch instructions independently of the current state of the resource. This can be useful when defining a change that may be applied at a future date.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header.  Here\'s how:  ``` Content-Type: application/json; domain-model=launchdarkly.semanticpatch ```  If you call a semantic patch resource without this header, you will receive a `400` response because your semantic patch will be interpreted as a JSON patch.  The body of a semantic patch request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some resources only) The environment key. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the instruction requires parameters, you must include those parameters as additional fields in the object. The documentation for each resource that supports semantic patch includes the available instructions and any additional parameters.  For example:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [ {\"kind\": \"turnFlagOn\"} ] } ```  If any instruction in the patch encounters an error, the endpoint returns an error and will not change the resource. In general, each instruction silently does nothing if the resource is already in the state you request.  ### Updates with comments  You can submit optional comments with `PATCH` changes.  To submit a comment along with a JSON patch document, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"patch\": [{ \"op\": \"replace\", \"path\": \"/description\", \"value\": \"The new description\" }] } ```  To submit a comment along with a JSON merge patch document, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"merge\": { \"description\": \"New flag description\" } } ```  To submit a comment along with a semantic patch, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"instructions\": [ {\"kind\": \"turnFlagOn\"} ] } ```  ## Errors  The API always returns errors in a common format. Here\'s an example:  ```json {   \"code\": \"invalid_request\",   \"message\": \"A feature with that key already exists\",   \"id\": \"30ce6058-87da-11e4-b116-123b93f75cba\" } ```  The `code` indicates the general class of error. The `message` is a human-readable explanation of what went wrong. The `id` is a unique identifier. Use it when you\'re working with LaunchDarkly Support to debug a problem with a specific API call.  ### HTTP status error response codes  | Code | Definition        | Description                                                                                       | Possible Solution                                                | | ---- | ----------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | | 400  | Invalid request       | The request cannot be understood.                                    | Ensure JSON syntax in request body is correct.                   | | 401  | Invalid access token      | Requestor is unauthorized or does not have permission for this API call.                                                | Ensure your API access token is valid and has the appropriate permissions.                                     | | 403  | Forbidden         | Requestor does not have access to this resource.                                                | Ensure that the account member or access token has proper permissions set. | | 404  | Invalid resource identifier | The requested resource is not valid. | Ensure that the resource is correctly identified by id or key. | | 405  | Method not allowed | The request method is not allowed on this resource. | Ensure that the HTTP verb is correct. | | 409  | Conflict          | The API request can not be completed because it conflicts with a concurrent API request. | Retry your request.                                              | | 422  | Unprocessable entity | The API request can not be completed because the update description can not be understood. | Ensure that the request body is correct for the type of patch you are using, either JSON patch or semantic patch. | 429  | Too many requests | Read [Rate limiting](/#section/Overview/Rate-limiting).                                               | Wait and try again later.                                        |  ## CORS  The LaunchDarkly API supports Cross Origin Resource Sharing (CORS) for AJAX requests from any origin. If an `Origin` header is given in a request, it will be echoed as an explicitly allowed origin. Otherwise the request returns a wildcard, `Access-Control-Allow-Origin: *`. For more information on CORS, read the [CORS W3C Recommendation](http://www.w3.org/TR/cors). Example CORS headers might look like:  ```http Access-Control-Allow-Headers: Accept, Content-Type, Content-Length, Accept-Encoding, Authorization Access-Control-Allow-Methods: OPTIONS, GET, DELETE, PATCH Access-Control-Allow-Origin: * Access-Control-Max-Age: 300 ```  You can make authenticated CORS calls just as you would make same-origin calls, using either [token or session-based authentication](/#section/Overview/Authentication). If you are using session authentication, you should set the `withCredentials` property for your `xhr` request to `true`. You should never expose your access tokens to untrusted users.  ## Rate limiting  We use several rate limiting strategies to ensure the availability of our APIs. Rate-limited calls to our APIs return a `429` status code. Calls to our APIs include headers indicating the current rate limit status. The specific headers returned depend on the API route being called. The limits differ based on the route, authentication mechanism, and other factors. Routes that are not rate limited may not contain any of the headers described below.  > ### Rate limiting and SDKs > > LaunchDarkly SDKs are never rate limited and do not use the API endpoints defined here. LaunchDarkly uses a different set of approaches, including streaming/server-sent events and a global CDN, to ensure availability to the routes used by LaunchDarkly SDKs.  ### Global rate limits  Authenticated requests are subject to a global limit. This is the maximum number of calls that your account can make to the API per ten seconds. All personal access tokens on the account share this limit, so exceeding the limit with one access token will impact other tokens. Calls that are subject to global rate limits return the headers below:  | Header name                    | Description                                                                      | | ------------------------------ | -------------------------------------------------------------------------------- | | `X-Ratelimit-Global-Remaining` | The maximum number of requests the account is permitted to make per ten seconds. | | `X-Ratelimit-Reset`            | The time at which the current rate limit window resets in epoch milliseconds.    |  We do not publicly document the specific number of calls that can be made globally. This limit may change, and we encourage clients to program against the specification, relying on the two headers defined above, rather than hardcoding to the current limit.  ### Route-level rate limits  Some authenticated routes have custom rate limits. These also reset every ten seconds. Any access tokens hitting the same route share this limit, so exceeding the limit with one access token may impact other tokens. Calls that are subject to route-level rate limits return the headers below:  | Header name                   | Description                                                                                           | | ----------------------------- | ----------------------------------------------------------------------------------------------------- | | `X-Ratelimit-Route-Remaining` | The maximum number of requests to the current route the account is permitted to make per ten seconds. | | `X-Ratelimit-Reset`           | The time at which the current rate limit window resets in epoch milliseconds.                         |  A _route_ represents a specific URL pattern and verb. For example, the [Delete environment](/tag/Environments#operation/deleteEnvironment) endpoint is considered a single route, and each call to delete an environment counts against your route-level rate limit for that route.  We do not publicly document the specific number of calls that an account can make to each endpoint per ten seconds. These limits may change, and we encourage clients to program against the specification, relying on the two headers defined above, rather than hardcoding to the current limits.  ### IP-based rate limiting  We also employ IP-based rate limiting on some API routes. If you hit an IP-based rate limit, your API response will include a `Retry-After` header indicating how long to wait before re-trying the call. Clients must wait at least `Retry-After` seconds before making additional calls to our API, and should employ jitter and backoff strategies to avoid triggering rate limits again.  ## OpenAPI (Swagger) and client libraries  We have a [complete OpenAPI (Swagger) specification](https://app.launchdarkly.com/api/v2/openapi.json) for our API.  We auto-generate multiple client libraries based on our OpenAPI specification. To learn more, visit the [collection of client libraries on GitHub](https://github.com/search?q=topic%3Alaunchdarkly-api+org%3Alaunchdarkly&type=Repositories). You can also use this specification to generate client libraries to interact with our REST API in your language of choice.  Our OpenAPI specification is supported by several API-based tools such as Postman and Insomnia. In many cases, you can directly import our specification to explore our APIs.  ## Method overriding  Some firewalls and HTTP clients restrict the use of verbs other than `GET` and `POST`. In those environments, our API endpoints that use `DELETE`, `PATCH`, and `PUT` verbs are inaccessible.  To avoid this issue, our API supports the `X-HTTP-Method-Override` header, allowing clients to \"tunnel\" `DELETE`, `PATCH`, and `PUT` requests using a `POST` request.  For example, to call a `PATCH` endpoint using a `POST` request, you can include `X-HTTP-Method-Override:PATCH` as a header.  ## Beta resources  We sometimes release new API resources in **beta** status before we release them with general availability.  Resources that are in beta are still undergoing testing and development. They may change without notice, including becoming backwards incompatible.  We try to promote resources into general availability as quickly as possible. This happens after sufficient testing and when we\'re satisfied that we no longer need to make backwards-incompatible changes.  We mark beta resources with a \"Beta\" callout in our documentation, pictured below:  > ### This feature is in beta > > To use this feature, pass in a header including the `LD-API-Version` key with value set to `beta`. Use this header with each call. To learn more, read [Beta resources](/#section/Overview/Beta-resources). > > Resources that are in beta are still undergoing testing and development. They may change without notice, including becoming backwards incompatible.  ### Using beta resources  To use a beta resource, you must include a header in the request. If you call a beta resource without this header, you receive a `403` response.  Use this header:  ``` LD-API-Version: beta ```  ## Versioning  We try hard to keep our REST API backwards compatible, but we occasionally have to make backwards-incompatible changes in the process of shipping new features. These breaking changes can cause unexpected behavior if you don\'t prepare for them accordingly.  Updates to our REST API include support for the latest features in LaunchDarkly. We also release a new version of our REST API every time we make a breaking change. We provide simultaneous support for multiple API versions so you can migrate from your current API version to a new version at your own pace.  ### Setting the API version per request  You can set the API version on a specific request by sending an `LD-API-Version` header, as shown in the example below:  ``` LD-API-Version: 20220603 ```  The header value is the version number of the API version you would like to request. The number for each version corresponds to the date the version was released in `yyyymmdd` format. In the example above the version `20220603` corresponds to June 03, 2022.  ### Setting the API version per access token  When you create an access token, you must specify a specific version of the API to use. This ensures that integrations using this token cannot be broken by version changes.  Tokens created before versioning was released have their version set to `20160426`, which is the version of the API that existed before the current versioning scheme, so that they continue working the same way they did before versioning.  If you would like to upgrade your integration to use a new API version, you can explicitly set the header described above.  > ### Best practice: Set the header for every client or integration > > We recommend that you set the API version header explicitly in any client or integration you build. > > Only rely on the access token API version during manual testing.  ### API version changelog  |<div style=\"width:75px\">Version</div> | Changes | End of life (EOL) |---|---|---| | `20220603` | <ul><li>Changed the [list projects](/tag/Projects#operation/getProjects) return value:<ul><li>Response is now paginated with a default limit of `20`.</li><li>Added support for filter and sort.</li><li>The project `environments` field is now expandable. This field is omitted by default.</li></ul></li><li>Changed the [get project](/tag/Projects#operation/getProject) return value:<ul><li>The `environments` field is now expandable. This field is omitted by default.</li></ul></li></ul> | Current | | `20210729` | <ul><li>Changed the [create approval request](/tag/Approvals#operation/postApprovalRequest) return value. It now returns HTTP Status Code `201` instead of `200`.</li><li> Changed the [get users](/tag/Users#operation/getUser) return value. It now returns a user record, not a user. </li><li>Added additional optional fields to environment, segments, flags, members, and segments, including the ability to create Big Segments. </li><li> Added default values for flag variations when new environments are created. </li><li>Added filtering and pagination for getting flags and members, including `limit`, `number`, `filter`, and `sort` query parameters. </li><li>Added endpoints for expiring user targets for flags and segments, scheduled changes, access tokens, Relay Proxy configuration, integrations and subscriptions, and approvals. </li></ul> | 2023-06-03 | | `20191212` | <ul><li>[List feature flags](/tag/Feature-flags#operation/getFeatureFlags) now defaults to sending summaries of feature flag configurations, equivalent to setting the query parameter `summary=true`. Summaries omit flag targeting rules and individual user targets from the payload. </li><li> Added endpoints for flags, flag status, projects, environments, users, audit logs, members, users, custom roles, segments, usage, streams, events, and data export. </li></ul> | 2022-07-29 | | `20160426` | <ul><li>Initial versioning of API. Tokens created before versioning have their version set to this.</li></ul> | 2020-12-12 | 
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<AccessDenied>}
     * @memberof Access
     */
    'denied': Array<AccessDenied>;
    /**
     * 
     * @type {Array<AccessAllowedRep>}
     * @memberof Access
     */
    'allowed': Array<AccessAllowedRep>;
}
/**
 * 
 * @export
 * @interface AccessAllowedReason
 */
export interface AccessAllowedReason {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'notActions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccessAllowedReason
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof AccessAllowedReason
     */
    'role_name'?: string;
}
/**
 * 
 * @export
 * @interface AccessAllowedRep
 */
export interface AccessAllowedRep {
    /**
     * 
     * @type {string}
     * @memberof AccessAllowedRep
     */
    'action': string;
    /**
     * 
     * @type {AccessAllowedReason}
     * @memberof AccessAllowedRep
     */
    'reason': AccessAllowedReason;
}
/**
 * 
 * @export
 * @interface AccessDenied
 */
export interface AccessDenied {
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'action': string;
    /**
     * 
     * @type {AccessDeniedReason}
     * @memberof AccessDenied
     */
    'reason': AccessDeniedReason;
}
/**
 * 
 * @export
 * @interface AccessDeniedReason
 */
export interface AccessDeniedReason {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'notActions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccessDeniedReason
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof AccessDeniedReason
     */
    'role_name'?: string;
}
/**
 * 
 * @export
 * @interface AccessTokenPost
 */
export interface AccessTokenPost {
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'name'?: string;
    /**
     * A description for the access token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'description'?: string;
    /**
     * Built-in role for the token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'role'?: AccessTokenPostRoleEnum;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof AccessTokenPost
     */
    'customRoleIds'?: Array<string>;
    /**
     * A JSON array of statements represented as JSON objects with three attributes: effect, resources, actions. May be used in place of a built-in or custom role.
     * @type {Array<StatementPost>}
     * @memberof AccessTokenPost
     */
    'inlineRole'?: Array<StatementPost>;
    /**
     * Whether the token is a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
     * @type {boolean}
     * @memberof AccessTokenPost
     */
    'serviceToken'?: boolean;
    /**
     * The default API version for this token
     * @type {number}
     * @memberof AccessTokenPost
     */
    'defaultApiVersion'?: number;
}

export const AccessTokenPostRoleEnum = {
    Reader: 'reader',
    Writer: 'writer',
    Admin: 'admin'
} as const;

export type AccessTokenPostRoleEnum = typeof AccessTokenPostRoleEnum[keyof typeof AccessTokenPostRoleEnum];

/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * An array of instructions for the stage. Each object in the array uses the semantic patch format for updating a feature flag.
     * @type {any}
     * @memberof ActionInput
     */
    'instructions'?: any;
}
/**
 * 
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * The type of action for this stage
     * @type {string}
     * @memberof ActionOutput
     */
    'kind': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ActionOutput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface ApprovalConditionInput
 */
export interface ApprovalConditionInput {
    /**
     * 
     * @type {string}
     * @memberof ApprovalConditionInput
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApprovalConditionInput
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApprovalConditionInput
     */
    'notifyTeamKeys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApprovalConditionOutput
 */
export interface ApprovalConditionOutput {
    /**
     * 
     * @type {string}
     * @memberof ApprovalConditionOutput
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApprovalConditionOutput
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {Array<ReviewOutput>}
     * @memberof ApprovalConditionOutput
     */
    'allReviews': Array<ReviewOutput>;
    /**
     * 
     * @type {string}
     * @memberof ApprovalConditionOutput
     */
    'reviewStatus': string;
    /**
     * 
     * @type {number}
     * @memberof ApprovalConditionOutput
     */
    'appliedDate'?: number;
}
/**
 * 
 * @export
 * @interface ApprovalSettings
 */
export interface ApprovalSettings {
    /**
     * If approvals are required for this environment.
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'required': boolean;
    /**
     * Whether to skip approvals for pending changes
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'bypassApprovalsForPendingChanges': boolean;
    /**
     * Sets the amount of approvals required before a member can apply a change. The minimum is one and the maximum is five.
     * @type {number}
     * @memberof ApprovalSettings
     */
    'minNumApprovals': number;
    /**
     * Allow someone who makes an approval request to apply their own change.
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'canReviewOwnRequest': boolean;
    /**
     * Allow applying the change as long as at least one person has approved.
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'canApplyDeclinedChanges': boolean;
    /**
     * Which service to use for managing approvals.
     * @type {string}
     * @memberof ApprovalSettings
     */
    'serviceKind': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApprovalSettings
     */
    'serviceConfig': { [key: string]: any; };
    /**
     * Require approval only on flags with the provided tags. Otherwise all flags will require approval.
     * @type {Array<string>}
     * @memberof ApprovalSettings
     */
    'requiredApprovalTags': Array<string>;
}
/**
 * 
 * @export
 * @interface AuditLogEntryListingRep
 */
export interface AuditLogEntryListingRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryListingRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    '_id': string;
    /**
     * The ID of the account to which this audit log entry belongs
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    '_accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntryListingRep
     */
    'date': number;
    /**
     * Details on the actions performed and resources acted on in this audit log entry
     * @type {Array<ResourceAccess>}
     * @memberof AuditLogEntryListingRep
     */
    'accesses': Array<ResourceAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'kind': string;
    /**
     * The name of the resource this audit log entry refers to
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'name': string;
    /**
     * Description of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'description': string;
    /**
     * Shorter version of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'shortDescription': string;
    /**
     * Optional comment for the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'comment'?: string;
    /**
     * 
     * @type {SubjectDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'subject'?: SubjectDataRep;
    /**
     * 
     * @type {MemberDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'member'?: MemberDataRep;
    /**
     * 
     * @type {TokenDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'token'?: TokenDataRep;
    /**
     * 
     * @type {AuthorizedAppDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'app'?: AuthorizedAppDataRep;
    /**
     * The action and resource recorded in this audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'titleVerb'?: string;
    /**
     * A description of what occurred, in the format <code>member</code> <code>titleVerb</code> <code>target</code>
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'title'?: string;
    /**
     * 
     * @type {TargetResourceRep}
     * @memberof AuditLogEntryListingRep
     */
    'target'?: TargetResourceRep;
    /**
     * 
     * @type {ParentResourceRep}
     * @memberof AuditLogEntryListingRep
     */
    'parent'?: ParentResourceRep;
}
/**
 * 
 * @export
 * @interface AuditLogEntryListingRepCollection
 */
export interface AuditLogEntryListingRepCollection {
    /**
     * An array of audit log entries
     * @type {Array<AuditLogEntryListingRep>}
     * @memberof AuditLogEntryListingRepCollection
     */
    'items': Array<AuditLogEntryListingRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryListingRepCollection
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface AuditLogEntryRep
 */
export interface AuditLogEntryRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    '_id': string;
    /**
     * The ID of the account to which this audit log entry belongs
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    '_accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntryRep
     */
    'date': number;
    /**
     * Details on the actions performed and resources acted on in this audit log entry
     * @type {Array<ResourceAccess>}
     * @memberof AuditLogEntryRep
     */
    'accesses': Array<ResourceAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'kind': string;
    /**
     * The name of the resource this audit log entry refers to
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'name': string;
    /**
     * Description of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'description': string;
    /**
     * Shorter version of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'shortDescription': string;
    /**
     * Optional comment for the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'comment'?: string;
    /**
     * 
     * @type {SubjectDataRep}
     * @memberof AuditLogEntryRep
     */
    'subject'?: SubjectDataRep;
    /**
     * 
     * @type {MemberDataRep}
     * @memberof AuditLogEntryRep
     */
    'member'?: MemberDataRep;
    /**
     * 
     * @type {TokenDataRep}
     * @memberof AuditLogEntryRep
     */
    'token'?: TokenDataRep;
    /**
     * 
     * @type {AuthorizedAppDataRep}
     * @memberof AuditLogEntryRep
     */
    'app'?: AuthorizedAppDataRep;
    /**
     * The action and resource recorded in this audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'titleVerb'?: string;
    /**
     * A description of what occurred, in the format <code>member</code> <code>titleVerb</code> <code>target</code>
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'title'?: string;
    /**
     * 
     * @type {TargetResourceRep}
     * @memberof AuditLogEntryRep
     */
    'target'?: TargetResourceRep;
    /**
     * 
     * @type {ParentResourceRep}
     * @memberof AuditLogEntryRep
     */
    'parent'?: ParentResourceRep;
    /**
     * If the audit log entry has been updated, this is the JSON patch body that was used in the request to update the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'delta'?: any;
    /**
     * A JSON representation of the external trigger for this audit log entry, if any
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'triggerBody'?: any;
    /**
     * A JSON representation of the merge information for this audit log entry, if any
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'merge'?: any;
    /**
     * If the audit log entry has been updated, this is a JSON representation of the previous version of the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'previousVersion'?: any;
    /**
     * If the audit log entry has been updated, this is a JSON representation of the current version of the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'currentVersion'?: any;
    /**
     * 
     * @type {Array<AuditLogEntryListingRep>}
     * @memberof AuditLogEntryRep
     */
    'subentries'?: Array<AuditLogEntryListingRep>;
}
/**
 * 
 * @export
 * @interface AuthorizedAppDataRep
 */
export interface AuthorizedAppDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof AuthorizedAppDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The ID of the authorized application
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    '_id'?: string;
    /**
     * Whether the application is authorized through SCIM
     * @type {boolean}
     * @memberof AuthorizedAppDataRep
     */
    'isScim'?: boolean;
    /**
     * The authorized application name
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    'name'?: string;
    /**
     * The name of the maintainer for this authorized application
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    'maintainerName'?: string;
}
/**
 * 
 * @export
 * @interface BigSegmentTarget
 */
export interface BigSegmentTarget {
    /**
     * The user key
     * @type {string}
     * @memberof BigSegmentTarget
     */
    'userKey': string;
    /**
     * Indicates whether the user is included.<br />Included users are always segment members, regardless of segment rules.
     * @type {boolean}
     * @memberof BigSegmentTarget
     */
    'included': boolean;
    /**
     * Indicates whether the user is excluded.<br />Segment rules bypass excluded users, so they will never be included based on rules. Excluded users may still be included explicitly.
     * @type {boolean}
     * @memberof BigSegmentTarget
     */
    'excluded': boolean;
}
/**
 * 
 * @export
 * @interface BooleanDefaults
 */
export interface BooleanDefaults {
    /**
     * 
     * @type {string}
     * @memberof BooleanDefaults
     */
    'trueDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BooleanDefaults
     */
    'falseDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BooleanDefaults
     */
    'trueDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof BooleanDefaults
     */
    'falseDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof BooleanDefaults
     */
    'onVariation'?: number;
    /**
     * 
     * @type {number}
     * @memberof BooleanDefaults
     */
    'offVariation'?: number;
}
/**
 * 
 * @export
 * @interface BooleanFlagDefaults
 */
export interface BooleanFlagDefaults {
    /**
     * 
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'trueDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'falseDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'trueDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'falseDescription': string;
    /**
     * 
     * @type {number}
     * @memberof BooleanFlagDefaults
     */
    'onVariation': number;
    /**
     * 
     * @type {number}
     * @memberof BooleanFlagDefaults
     */
    'offVariation': number;
}
/**
 * 
 * @export
 * @interface BranchCollectionRep
 */
export interface BranchCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof BranchCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of branches
     * @type {Array<BranchRep>}
     * @memberof BranchCollectionRep
     */
    'items': Array<BranchRep>;
}
/**
 * 
 * @export
 * @interface BranchRep
 */
export interface BranchRep {
    /**
     * The branch name
     * @type {string}
     * @memberof BranchRep
     */
    'name': string;
    /**
     * An ID representing the branch HEAD. For example, a commit SHA.
     * @type {string}
     * @memberof BranchRep
     */
    'head': string;
    /**
     * An optional ID used to prevent older data from overwriting newer data
     * @type {number}
     * @memberof BranchRep
     */
    'updateSequenceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof BranchRep
     */
    'syncTime': number;
    /**
     * An array of flag references found on the branch
     * @type {Array<ReferenceRep>}
     * @memberof BranchRep
     */
    'references'?: Array<ReferenceRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof BranchRep
     */
    '_links': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BulkEditMembersRep
 */
export interface BulkEditMembersRep {
    /**
     * A list of members IDs of the members who were successfully updated.
     * @type {Array<string>}
     * @memberof BulkEditMembersRep
     */
    'members'?: Array<string>;
    /**
     * A list of member IDs and errors for the members whose updates failed.
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BulkEditMembersRep
     */
    'errors'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface BulkEditTeamsRep
 */
export interface BulkEditTeamsRep {
    /**
     * A list of member IDs of the members who were added to the teams.
     * @type {Array<string>}
     * @memberof BulkEditTeamsRep
     */
    'memberIDs'?: Array<string>;
    /**
     * A list of team keys of the teams that were successfully updated.
     * @type {Array<string>}
     * @memberof BulkEditTeamsRep
     */
    'teamKeys'?: Array<string>;
    /**
     * A list of team keys and errors for the teams whose updates failed.
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BulkEditTeamsRep
     */
    'errors'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface Clause
 */
export interface Clause {
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    'attribute': string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    'op': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof Clause
     */
    'values': Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof Clause
     */
    'negate': boolean;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Client
     */
    '_links': { [key: string]: Link; };
    /**
     * Client name
     * @type {string}
     * @memberof Client
     */
    'name': string;
    /**
     * Client description
     * @type {string}
     * @memberof Client
     */
    'description'?: string;
    /**
     * The account ID the client is registered under
     * @type {string}
     * @memberof Client
     */
    '_accountId': string;
    /**
     * The client\'s unique ID
     * @type {string}
     * @memberof Client
     */
    '_clientId': string;
    /**
     * The client secret. This will only be shown upon creation.
     * @type {string}
     * @memberof Client
     */
    '_clientSecret'?: string;
    /**
     * The client\'s redirect URI
     * @type {string}
     * @memberof Client
     */
    'redirectUri': string;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    '_creationDate': number;
}
/**
 * 
 * @export
 * @interface ClientCollection
 */
export interface ClientCollection {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ClientCollection
     */
    '_links': { [key: string]: Link; };
    /**
     * List of client objects
     * @type {Array<Client>}
     * @memberof ClientCollection
     */
    'items': Array<Client>;
}
/**
 * 
 * @export
 * @interface ClientSideAvailability
 */
export interface ClientSideAvailability {
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    'usingMobileKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    'usingEnvironmentId'?: boolean;
}
/**
 * 
 * @export
 * @interface ClientSideAvailabilityPost
 */
export interface ClientSideAvailabilityPost {
    /**
     * Whether to enable availability for client-side SDKs. Defaults to <code>false</code>.
     * @type {boolean}
     * @memberof ClientSideAvailabilityPost
     */
    'usingEnvironmentId': boolean;
    /**
     * Whether to enable availability for mobile SDKs. Defaults to <code>true</code>.
     * @type {boolean}
     * @memberof ClientSideAvailabilityPost
     */
    'usingMobileKey': boolean;
}
/**
 * 
 * @export
 * @interface ConditionBaseOutput
 */
export interface ConditionBaseOutput {
    /**
     * 
     * @type {string}
     * @memberof ConditionBaseOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionBaseOutput
     */
    'kind'?: string;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof ConditionBaseOutput
     */
    '_execution': ExecutionOutput;
}
/**
 * 
 * @export
 * @interface ConditionInput
 */
export interface ConditionInput {
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionInput
     */
    'executionDate'?: number;
    /**
     * For workflow stages whose scheduled execution is relative, how far in the future the stage should start.
     * @type {number}
     * @memberof ConditionInput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'waitDurationUnit'?: string;
    /**
     * Whether the workflow stage should be executed immediately
     * @type {boolean}
     * @memberof ConditionInput
     */
    'executeNow'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionInput
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionInput
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'kind'?: string;
}
/**
 * 
 * @export
 * @interface ConditionOutput
 */
export interface ConditionOutput {
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'kind'?: string;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof ConditionOutput
     */
    '_execution': ExecutionOutput;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'executionDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'waitDurationUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionOutput
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {Array<ReviewOutput>}
     * @memberof ConditionOutput
     */
    'allReviews': Array<ReviewOutput>;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'reviewStatus': string;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'appliedDate'?: number;
}
/**
 * 
 * @export
 * @interface ConfidenceIntervalRep
 */
export interface ConfidenceIntervalRep {
    /**
     * 
     * @type {number}
     * @memberof ConfidenceIntervalRep
     */
    'upper'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfidenceIntervalRep
     */
    'lower'?: number;
}
/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Conflict
     */
    'instruction'?: { [key: string]: any; };
    /**
     * Reason why the conflict exists
     * @type {string}
     * @memberof Conflict
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface ConflictOutput
 */
export interface ConflictOutput {
    /**
     * The stage ID
     * @type {string}
     * @memberof ConflictOutput
     */
    'stageId': string;
    /**
     * Message about the conflict
     * @type {string}
     * @memberof ConflictOutput
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CopiedFromEnv
 */
export interface CopiedFromEnv {
    /**
     * Key of feature flag copied
     * @type {string}
     * @memberof CopiedFromEnv
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof CopiedFromEnv
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface CreateCopyFlagConfigApprovalRequestRequest
 */
export interface CreateCopyFlagConfigApprovalRequestRequest {
    /**
     * Optional comment describing the approval request
     * @type {string}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'comment'?: string;
    /**
     * A brief description of your changes
     * @type {string}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'description': string;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * An array of team keys. The members of these teams are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {SourceFlag}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'source': SourceFlag;
    /**
     * Optional list of the flag changes to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If neither are included, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'includedActions'?: Array<CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum>;
    /**
     * Optional list of the flag changes NOT to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If neither are included, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'excludedActions'?: Array<CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum>;
}

export const CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdateRules: 'updateRules',
    UpdateTargets: 'updateTargets',
    UpdatePrerequisites: 'updatePrerequisites'
} as const;

export type CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum = typeof CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum[keyof typeof CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum];
export const CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdateRules: 'updateRules',
    UpdateTargets: 'updateTargets',
    UpdatePrerequisites: 'updatePrerequisites'
} as const;

export type CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum = typeof CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum[keyof typeof CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum];

/**
 * 
 * @export
 * @interface CreateFlagConfigApprovalRequestRequest
 */
export interface CreateFlagConfigApprovalRequestRequest {
    /**
     * Optional comment describing the approval request
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'comment'?: string;
    /**
     * A brief description of the changes you\'re requesting
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * An array of team keys. The members of these teams are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'executionDate'?: number;
    /**
     * The ID of a scheduled change. Include this if your <code>instructions</code> include editing or deleting a scheduled change.
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'integrationConfig'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateWorkflowTemplateInput
 */
export interface CreateWorkflowTemplateInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'workflowId'?: string;
    /**
     * 
     * @type {Array<StageInput>}
     * @memberof CreateWorkflowTemplateInput
     */
    'stages'?: Array<StageInput>;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'projectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'environmentKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'flagKey'?: string;
}
/**
 * 
 * @export
 * @interface CredibleIntervalRep
 */
export interface CredibleIntervalRep {
    /**
     * The upper bound
     * @type {number}
     * @memberof CredibleIntervalRep
     */
    'upper'?: number;
    /**
     * The lower bound
     * @type {number}
     * @memberof CredibleIntervalRep
     */
    'lower'?: number;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * The name of the custom property of this type.
     * @type {string}
     * @memberof CustomProperty
     */
    'name': string;
    /**
     * An array of values for the custom property data to associate with this flag.
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'value': Array<string>;
}
/**
 * 
 * @export
 * @interface CustomRole
 */
export interface CustomRole {
    /**
     * The ID of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    '_id': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomRole
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof CustomRole
     */
    '_access'?: Access;
    /**
     * The description of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'description'?: string;
    /**
     * The key of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'key': string;
    /**
     * The name of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'name': string;
    /**
     * An array of the policies that comprise this custom role
     * @type {Array<Statement>}
     * @memberof CustomRole
     */
    'policy': Array<Statement>;
    /**
     * 
     * @type {string}
     * @memberof CustomRole
     */
    'basePermissions'?: string;
}
/**
 * 
 * @export
 * @interface CustomRolePost
 */
export interface CustomRolePost {
    /**
     * A human-friendly name for the custom role
     * @type {string}
     * @memberof CustomRolePost
     */
    'name': string;
    /**
     * The custom role key
     * @type {string}
     * @memberof CustomRolePost
     */
    'key': string;
    /**
     * Description of custom role
     * @type {string}
     * @memberof CustomRolePost
     */
    'description'?: string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof CustomRolePost
     */
    'policy': Array<StatementPost>;
    /**
     * 
     * @type {string}
     * @memberof CustomRolePost
     */
    'basePermissions'?: string;
}
/**
 * 
 * @export
 * @interface CustomRolePostData
 */
export interface CustomRolePostData {
    /**
     * A human-friendly name for the custom role
     * @type {string}
     * @memberof CustomRolePostData
     */
    'name': string;
    /**
     * The custom role key
     * @type {string}
     * @memberof CustomRolePostData
     */
    'key': string;
    /**
     * Description of custom role
     * @type {string}
     * @memberof CustomRolePostData
     */
    'description'?: string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof CustomRolePostData
     */
    'policy': Array<StatementPost>;
    /**
     * 
     * @type {string}
     * @memberof CustomRolePostData
     */
    'basePermissions'?: string;
}
/**
 * 
 * @export
 * @interface CustomRoles
 */
export interface CustomRoles {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomRoles
     */
    '_links'?: { [key: string]: Link; };
    /**
     * An array of custom roles
     * @type {Array<CustomRole>}
     * @memberof CustomRoles
     */
    'items'?: Array<CustomRole>;
}
/**
 * 
 * @export
 * @interface CustomWorkflowInput
 */
export interface CustomWorkflowInput {
    /**
     * 
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'maintainerId'?: string;
    /**
     * The workflow name
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'name'?: string;
    /**
     * The workflow description
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'description': string;
    /**
     * A list of the workflow stages
     * @type {Array<StageInput>}
     * @memberof CustomWorkflowInput
     */
    'stages'?: Array<StageInput>;
    /**
     * The template key
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'templateKey'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowMeta
 */
export interface CustomWorkflowMeta {
    /**
     * 
     * @type {string}
     * @memberof CustomWorkflowMeta
     */
    'name'?: string;
    /**
     * 
     * @type {CustomWorkflowStageMeta}
     * @memberof CustomWorkflowMeta
     */
    'stage'?: CustomWorkflowStageMeta;
}
/**
 * 
 * @export
 * @interface CustomWorkflowOutput
 */
export interface CustomWorkflowOutput {
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    '_id': string;
    /**
     * The version of the workflow
     * @type {number}
     * @memberof CustomWorkflowOutput
     */
    '_version': number;
    /**
     * Any conflicts that are present in the workflow stages
     * @type {Array<ConflictOutput>}
     * @memberof CustomWorkflowOutput
     */
    '_conflicts': Array<ConflictOutput>;
    /**
     * 
     * @type {number}
     * @memberof CustomWorkflowOutput
     */
    '_creationDate': number;
    /**
     * The member ID of the maintainer of the workflow. Defaults to the workflow creator.
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    '_maintainerId': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomWorkflowOutput
     */
    '_links': { [key: string]: Link; };
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'name': string;
    /**
     * A brief description of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'description'?: string;
    /**
     * The kind of workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'kind'?: string;
    /**
     * The stages that make up the workflow. Each stage contains conditions and actions.
     * @type {Array<StageOutput>}
     * @memberof CustomWorkflowOutput
     */
    'stages'?: Array<StageOutput>;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof CustomWorkflowOutput
     */
    '_execution': ExecutionOutput;
    /**
     * 
     * @type {WorkflowTemplateMetadata}
     * @memberof CustomWorkflowOutput
     */
    'meta'?: WorkflowTemplateMetadata;
    /**
     * For workflows being created from a workflow template, this value is the template\'s key
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'templateKey'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowStageMeta
 */
export interface CustomWorkflowStageMeta {
    /**
     * 
     * @type {number}
     * @memberof CustomWorkflowStageMeta
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomWorkflowStageMeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowsListingOutput
 */
export interface CustomWorkflowsListingOutput {
    /**
     * An array of workflows
     * @type {Array<CustomWorkflowOutput>}
     * @memberof CustomWorkflowsListingOutput
     */
    'items': Array<CustomWorkflowOutput>;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    'Label'?: string;
    /**
     * 
     * @type {number}
     * @memberof Database
     */
    'StartTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Database
     */
    'Tracked'?: boolean;
}
/**
 * 
 * @export
 * @interface DefaultClientSideAvailability
 */
export interface DefaultClientSideAvailability {
    /**
     * 
     * @type {boolean}
     * @memberof DefaultClientSideAvailability
     */
    'usingMobileKey': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefaultClientSideAvailability
     */
    'usingEnvironmentId': boolean;
}
/**
 * 
 * @export
 * @interface DefaultClientSideAvailabilityPost
 */
export interface DefaultClientSideAvailabilityPost {
    /**
     * Whether to enable availability for client-side SDKs.
     * @type {boolean}
     * @memberof DefaultClientSideAvailabilityPost
     */
    'usingEnvironmentId': boolean;
    /**
     * Whether to enable availability for mobile SDKs.
     * @type {boolean}
     * @memberof DefaultClientSideAvailabilityPost
     */
    'usingMobileKey': boolean;
}
/**
 * 
 * @export
 * @interface Defaults
 */
export interface Defaults {
    /**
     * The index, from the array of variations for this flag, of the variation to serve by default when targeting is on.
     * @type {number}
     * @memberof Defaults
     */
    'onVariation': number;
    /**
     * The index, from the array of variations for this flag, of the variation to serve by default when targeting is off.
     * @type {number}
     * @memberof Defaults
     */
    'offVariation': number;
}
/**
 * 
 * @export
 * @interface DependentExperimentRep
 */
export interface DependentExperimentRep {
    /**
     * The experiment key
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'key': string;
    /**
     * The experiment name
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'name': string;
    /**
     * The environment ID
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'environmentId': string;
    /**
     * 
     * @type {number}
     * @memberof DependentExperimentRep
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof DependentExperimentRep
     */
    'archivedDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentExperimentRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface DependentFlag
 */
export interface DependentFlag {
    /**
     * The flag name
     * @type {string}
     * @memberof DependentFlag
     */
    'name'?: string;
    /**
     * The flag key
     * @type {string}
     * @memberof DependentFlag
     */
    'key': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlag
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlag
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface DependentFlagEnvironment
 */
export interface DependentFlagEnvironment {
    /**
     * The environment name
     * @type {string}
     * @memberof DependentFlagEnvironment
     */
    'name'?: string;
    /**
     * The environment key
     * @type {string}
     * @memberof DependentFlagEnvironment
     */
    'key': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlagEnvironment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlagEnvironment
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface DependentFlagsByEnvironment
 */
export interface DependentFlagsByEnvironment {
    /**
     * A list of dependent flags, which are flags that use the requested flag as a prerequisite
     * @type {Array<DependentFlag>}
     * @memberof DependentFlagsByEnvironment
     */
    'items': Array<DependentFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlagsByEnvironment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlagsByEnvironment
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * The ID of this Data Export destination
     * @type {string}
     * @memberof Destination
     */
    '_id'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Destination
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A human-readable name for your Data Export destination
     * @type {string}
     * @memberof Destination
     */
    'name'?: string;
    /**
     * The type of Data Export destination
     * @type {string}
     * @memberof Destination
     */
    'kind'?: DestinationKindEnum;
    /**
     * 
     * @type {number}
     * @memberof Destination
     */
    'version'?: number;
    /**
     * An object with the configuration parameters required for the destination type
     * @type {any}
     * @memberof Destination
     */
    'config'?: any;
    /**
     * Whether the export is on, that is, the status of the integration
     * @type {boolean}
     * @memberof Destination
     */
    'on'?: boolean;
    /**
     * 
     * @type {Access}
     * @memberof Destination
     */
    '_access'?: Access;
}

export const DestinationKindEnum = {
    GooglePubsub: 'google-pubsub',
    Kinesis: 'kinesis',
    Mparticle: 'mparticle',
    Segment: 'segment',
    AzureEventHubs: 'azure-event-hubs'
} as const;

export type DestinationKindEnum = typeof DestinationKindEnum[keyof typeof DestinationKindEnum];

/**
 * 
 * @export
 * @interface DestinationPost
 */
export interface DestinationPost {
    /**
     * A human-readable name for your Data Export destination
     * @type {string}
     * @memberof DestinationPost
     */
    'name'?: string;
    /**
     * The type of Data Export destination
     * @type {string}
     * @memberof DestinationPost
     */
    'kind'?: DestinationPostKindEnum;
    /**
     * An object with the configuration parameters required for the destination type
     * @type {any}
     * @memberof DestinationPost
     */
    'config'?: any;
    /**
     * Whether the export is on. Displayed as the integration status in the LaunchDarkly UI.
     * @type {boolean}
     * @memberof DestinationPost
     */
    'on'?: boolean;
}

export const DestinationPostKindEnum = {
    GooglePubsub: 'google-pubsub',
    Kinesis: 'kinesis',
    Mparticle: 'mparticle',
    Segment: 'segment',
    AzureEventHubs: 'azure-event-hubs'
} as const;

export type DestinationPostKindEnum = typeof DestinationPostKindEnum[keyof typeof DestinationPostKindEnum];

/**
 * 
 * @export
 * @interface Destinations
 */
export interface Destinations {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Destinations
     */
    '_links'?: { [key: string]: Link; };
    /**
     * An array of Data Export destinations
     * @type {Array<Destination>}
     * @memberof Destinations
     */
    'items'?: Array<Destination>;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * Links to other resources within the API. Includes the URL and content type of those resources
     * @type {{ [key: string]: Link; }}
     * @memberof Environment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    '_id': string;
    /**
     * A project-unique key for the new environment.
     * @type {string}
     * @memberof Environment
     */
    'key': string;
    /**
     * A human-friendly name for the new environment.
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * API key to use with client-side SDKs.
     * @type {string}
     * @memberof Environment
     */
    'apiKey': string;
    /**
     * API key to use with mobile SDKs.
     * @type {string}
     * @memberof Environment
     */
    'mobileKey': string;
    /**
     * The color used to indicate this environment in the UI.
     * @type {string}
     * @memberof Environment
     */
    'color': string;
    /**
     * The default time (in minutes) that the PHP SDK can cache feature flag rules locally.
     * @type {number}
     * @memberof Environment
     */
    'defaultTtl': number;
    /**
     * Secure mode ensures that a user of the client-side SDK cannot impersonate another user.
     * @type {boolean}
     * @memberof Environment
     */
    'secureMode': boolean;
    /**
     * Enables tracking detailed information for new flags by default.
     * @type {boolean}
     * @memberof Environment
     */
    'defaultTrackEvents': boolean;
    /**
     * Whether members who modify flags and user segments through the LaunchDarkly user interface are required to add a comment
     * @type {boolean}
     * @memberof Environment
     */
    'requireComments': boolean;
    /**
     * Whether members who modify flags and user segments through the LaunchDarkly user interface are required to confirm those changes
     * @type {boolean}
     * @memberof Environment
     */
    'confirmChanges': boolean;
    /**
     * A list of tags for this environment
     * @type {Array<string>}
     * @memberof Environment
     */
    'tags': Array<string>;
    /**
     * 
     * @type {ApprovalSettings}
     * @memberof Environment
     */
    'approvalSettings'?: ApprovalSettings;
}
/**
 * 
 * @export
 * @interface EnvironmentPost
 */
export interface EnvironmentPost {
    /**
     * A human-friendly name for the new environment.
     * @type {string}
     * @memberof EnvironmentPost
     */
    'name': string;
    /**
     * A project-unique key for the new environment.
     * @type {string}
     * @memberof EnvironmentPost
     */
    'key': string;
    /**
     * A color to indicate this environment in the UI.
     * @type {string}
     * @memberof EnvironmentPost
     */
    'color': string;
    /**
     * The default time (in minutes) that the PHP SDK can cache feature flag rules locally.
     * @type {number}
     * @memberof EnvironmentPost
     */
    'defaultTtl'?: number;
    /**
     * Ensures that a user of the client-side SDK cannot impersonate another user.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'secureMode'?: boolean;
    /**
     * Enables tracking detailed information for new flags by default.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'defaultTrackEvents'?: boolean;
    /**
     * Requires confirmation for all flag and segment changes via the UI in this environment.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'confirmChanges'?: boolean;
    /**
     * Requires comments for all flag and segment changes via the UI in this environment.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'requireComments'?: boolean;
    /**
     * Tags to apply to the new environment.
     * @type {Array<string>}
     * @memberof EnvironmentPost
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {SourceEnv}
     * @memberof EnvironmentPost
     */
    'source'?: SourceEnv;
}
/**
 * 
 * @export
 * @interface Environments
 */
export interface Environments {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Environments
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of environments returned
     * @type {number}
     * @memberof Environments
     */
    'totalCount'?: number;
    /**
     * An array of environments
     * @type {Array<Environment>}
     * @memberof Environments
     */
    'items'?: Array<Environment>;
}
/**
 * 
 * @export
 * @interface EvaluationReason
 */
export interface EvaluationReason {
    /**
     * Describes the general reason that LaunchDarkly selected this variation.
     * @type {string}
     * @memberof EvaluationReason
     */
    'kind': string;
    /**
     * The positional index of the matching rule if the kind is \'RULE_MATCH\'. The index is 0-based.
     * @type {number}
     * @memberof EvaluationReason
     */
    'ruleIndex'?: number;
    /**
     * The unique identifier of the matching rule if the kind is \'RULE_MATCH\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'ruleID'?: string;
    /**
     * The key of the flag that failed if the kind is \'PREREQUISITE_FAILED\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'prerequisiteKey'?: string;
    /**
     * Indicates whether the user was evaluated as part of an experiment.
     * @type {boolean}
     * @memberof EvaluationReason
     */
    'inExperiment'?: boolean;
    /**
     * The specific error type if the kind is \'ERROR\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'errorKind'?: string;
}
/**
 * 
 * @export
 * @interface ExecutionOutput
 */
export interface ExecutionOutput {
    /**
     * The status of the execution of this workflow stage
     * @type {string}
     * @memberof ExecutionOutput
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * The experiment ID
     * @type {string}
     * @memberof Experiment
     */
    '_id'?: string;
    /**
     * The experiment key
     * @type {string}
     * @memberof Experiment
     */
    'key': string;
    /**
     * The experiment name
     * @type {string}
     * @memberof Experiment
     */
    'name': string;
    /**
     * The experiment description
     * @type {string}
     * @memberof Experiment
     */
    'description'?: string;
    /**
     * The ID of the member who maintains this experiment.
     * @type {string}
     * @memberof Experiment
     */
    '_maintainerId': string;
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    '_creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    'archivedDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Experiment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {IterationRep}
     * @memberof Experiment
     */
    'currentIteration'?: IterationRep;
    /**
     * 
     * @type {IterationRep}
     * @memberof Experiment
     */
    'draftIteration'?: IterationRep;
    /**
     * Details on the previous iterations for this experiment.
     * @type {Array<IterationRep>}
     * @memberof Experiment
     */
    'previousIterations'?: Array<IterationRep>;
}
/**
 * 
 * @export
 * @interface ExperimentAllocationRep
 */
export interface ExperimentAllocationRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentAllocationRep
     */
    'defaultVariation': number;
    /**
     * 
     * @type {boolean}
     * @memberof ExperimentAllocationRep
     */
    'canReshuffle': boolean;
}
/**
 * 
 * @export
 * @interface ExperimentBayesianResultsRep
 */
export interface ExperimentBayesianResultsRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentBayesianResultsRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A list of the results for each treatment
     * @type {Array<TreatmentResultRep>}
     * @memberof ExperimentBayesianResultsRep
     */
    'treatmentResults'?: Array<TreatmentResultRep>;
    /**
     * 
     * @type {MetricSeen}
     * @memberof ExperimentBayesianResultsRep
     */
    'metricSeen'?: MetricSeen;
    /**
     * The probability of a Sample Ratio Mismatch
     * @type {number}
     * @memberof ExperimentBayesianResultsRep
     */
    'probabilityOfMismatch'?: number;
}
/**
 * 
 * @export
 * @interface ExperimentCollectionRep
 */
export interface ExperimentCollectionRep {
    /**
     * An array of experiments
     * @type {Array<Experiment>}
     * @memberof ExperimentCollectionRep
     */
    'items'?: Array<Experiment>;
    /**
     * The total number of experiments in this project and environment. Does not include legacy experiments.
     * @type {number}
     * @memberof ExperimentCollectionRep
     */
    'total_count'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExperimentEnabledPeriodRep
 */
export interface ExperimentEnabledPeriodRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnabledPeriodRep
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnabledPeriodRep
     */
    'stopDate'?: number;
}
/**
 * 
 * @export
 * @interface ExperimentEnvironmentSettingRep
 */
export interface ExperimentEnvironmentSettingRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'stopDate'?: number;
    /**
     * 
     * @type {Array<ExperimentEnabledPeriodRep>}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'enabledPeriods'?: Array<ExperimentEnabledPeriodRep>;
}
/**
 * 
 * @export
 * @interface ExperimentExpandableProperties
 */
export interface ExperimentExpandableProperties {
    /**
     * 
     * @type {IterationRep}
     * @memberof ExperimentExpandableProperties
     */
    'draftIteration'?: IterationRep;
    /**
     * Details on the previous iterations for this experiment.
     * @type {Array<IterationRep>}
     * @memberof ExperimentExpandableProperties
     */
    'previousIterations'?: Array<IterationRep>;
}
/**
 * 
 * @export
 * @interface ExperimentInfoRep
 */
export interface ExperimentInfoRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentInfoRep
     */
    'baselineIdx': number;
    /**
     * 
     * @type {Array<LegacyExperimentRep>}
     * @memberof ExperimentInfoRep
     */
    'items': Array<LegacyExperimentRep>;
}
/**
 * 
 * @export
 * @interface ExperimentMetadataRep
 */
export interface ExperimentMetadataRep {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetadataRep
     */
    'key'?: any;
}
/**
 * 
 * @export
 * @interface ExperimentPatchInput
 */
export interface ExperimentPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof ExperimentPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ExperimentPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface ExperimentPost
 */
export interface ExperimentPost {
    /**
     * The experiment name
     * @type {string}
     * @memberof ExperimentPost
     */
    'name': string;
    /**
     * The experiment description
     * @type {string}
     * @memberof ExperimentPost
     */
    'description'?: string;
    /**
     * The ID of the member who maintains this experiment.
     * @type {string}
     * @memberof ExperimentPost
     */
    'maintainerId': string;
    /**
     * The experiment key
     * @type {string}
     * @memberof ExperimentPost
     */
    'key': string;
    /**
     * 
     * @type {IterationInput}
     * @memberof ExperimentPost
     */
    'iteration': IterationInput;
}
/**
 * 
 * @export
 * @interface ExperimentResults
 */
export interface ExperimentResults {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentResults
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<ExperimentMetadataRep>}
     * @memberof ExperimentResults
     */
    'metadata'?: Array<ExperimentMetadataRep>;
    /**
     * 
     * @type {Array<ExperimentTotalsRep>}
     * @memberof ExperimentResults
     */
    'totals'?: Array<ExperimentTotalsRep>;
    /**
     * 
     * @type {Array<ExperimentTimeSeriesSlice>}
     * @memberof ExperimentResults
     */
    'series'?: Array<ExperimentTimeSeriesSlice>;
    /**
     * 
     * @type {ExperimentStatsRep}
     * @memberof ExperimentResults
     */
    'stats'?: ExperimentStatsRep;
    /**
     * 
     * @type {string}
     * @memberof ExperimentResults
     */
    'granularity'?: string;
    /**
     * 
     * @type {MetricSeen}
     * @memberof ExperimentResults
     */
    'metricSeen'?: MetricSeen;
}
/**
 * 
 * @export
 * @interface ExperimentStatsRep
 */
export interface ExperimentStatsRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'pValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'chi2'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'winningVariationIdx'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExperimentStatsRep
     */
    'minSampleSizeMet'?: boolean;
}
/**
 * 
 * @export
 * @interface ExperimentTimeSeriesSlice
 */
export interface ExperimentTimeSeriesSlice {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesSlice
     */
    'Time'?: number;
    /**
     * 
     * @type {Array<ExperimentTimeSeriesVariationSlice>}
     * @memberof ExperimentTimeSeriesSlice
     */
    'VariationData'?: Array<ExperimentTimeSeriesVariationSlice>;
}
/**
 * 
 * @export
 * @interface ExperimentTimeSeriesVariationSlice
 */
export interface ExperimentTimeSeriesVariationSlice {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'conversionRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeConversionRate'?: number;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'confidenceInterval'?: ConfidenceIntervalRep;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeConfidenceInterval'?: ConfidenceIntervalRep;
}
/**
 * 
 * @export
 * @interface ExperimentTotalsRep
 */
export interface ExperimentTotalsRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeImpressionCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeConversionRate'?: number;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeConfidenceInterval'?: ConfidenceIntervalRep;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'pValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'improvement'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'minSampleSize'?: number;
}
/**
 * 
 * @export
 * @interface ExpiringTargetError
 */
export interface ExpiringTargetError {
    /**
     * The index of the PATCH instruction where the error occurred
     * @type {number}
     * @memberof ExpiringTargetError
     */
    'instructionIndex': number;
    /**
     * The error message related to a failed PATCH instruction
     * @type {string}
     * @memberof ExpiringTargetError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetGetResponse
 */
export interface ExpiringUserTargetGetResponse {
    /**
     * An array of expiring user targets
     * @type {Array<ExpiringUserTargetItem>}
     * @memberof ExpiringUserTargetGetResponse
     */
    'items': Array<ExpiringUserTargetItem>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringUserTargetGetResponse
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetItem
 */
export interface ExpiringUserTargetItem {
    /**
     * The ID of this expiring user target
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    '_id': string;
    /**
     * The version of this expiring user target
     * @type {number}
     * @memberof ExpiringUserTargetItem
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ExpiringUserTargetItem
     */
    'expirationDate': number;
    /**
     * A unique key used to represent the user
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'userKey': string;
    /**
     * A segment\'s target type. Included when expiring user targets are updated on a user segment.
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'targetType'?: string;
    /**
     * A unique key used to represent the flag variation. Included when expiring user targets are updated on a feature flag.
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'variationId'?: string;
    /**
     * 
     * @type {ResourceIDResponse}
     * @memberof ExpiringUserTargetItem
     */
    '_resourceId': ResourceIDResponse;
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetPatchResponse
 */
export interface ExpiringUserTargetPatchResponse {
    /**
     * An array of expiring user targets
     * @type {Array<ExpiringUserTargetItem>}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'items': Array<ExpiringUserTargetItem>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringUserTargetPatchResponse
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total count of instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'totalInstructions'?: number;
    /**
     * The total count of successful instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'successfulInstructions'?: number;
    /**
     * The total count of the failed instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'failedInstructions'?: number;
    /**
     * An array of error messages for the failed instructions
     * @type {Array<ExpiringTargetError>}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'errors'?: Array<ExpiringTargetError>;
}
/**
 * 
 * @export
 * @interface Export
 */
export interface Export {
    /**
     * The export ID
     * @type {string}
     * @memberof Export
     */
    'id': string;
    /**
     * The segment key
     * @type {string}
     * @memberof Export
     */
    'segmentKey': string;
    /**
     * 
     * @type {number}
     * @memberof Export
     */
    'creationTime': number;
    /**
     * The export status
     * @type {string}
     * @memberof Export
     */
    'status': string;
    /**
     * The export size, in bytes
     * @type {number}
     * @memberof Export
     */
    'sizeBytes': number;
    /**
     * The export size, with units
     * @type {string}
     * @memberof Export
     */
    'size': string;
    /**
     * 
     * @type {InitiatorRep}
     * @memberof Export
     */
    'initiator': InitiatorRep;
    /**
     * The location and content type of related resources, including the location of the exported file
     * @type {{ [key: string]: Link; }}
     * @memberof Export
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Extinction
 */
export interface Extinction {
    /**
     * The identifier for the revision where flag became extinct. For example, a commit SHA.
     * @type {string}
     * @memberof Extinction
     */
    'revision': string;
    /**
     * Description of the extinction. For example, the commit message for the revision.
     * @type {string}
     * @memberof Extinction
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof Extinction
     */
    'time': number;
    /**
     * The feature flag key
     * @type {string}
     * @memberof Extinction
     */
    'flagKey': string;
    /**
     * The project key
     * @type {string}
     * @memberof Extinction
     */
    'projKey': string;
}
/**
 * 
 * @export
 * @interface ExtinctionCollectionRep
 */
export interface ExtinctionCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExtinctionCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of extinction events
     * @type {{ [key: string]: Array<Extinction>; }}
     * @memberof ExtinctionCollectionRep
     */
    'items': { [key: string]: Array<Extinction>; };
}
/**
 * 
 * @export
 * @interface FeatureFlag
 */
export interface FeatureFlag {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'name': string;
    /**
     * Kind of feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'kind': FeatureFlagKindEnum;
    /**
     * Description of the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'description'?: string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof FeatureFlag
     */
    'key': string;
    /**
     * Version of the feature flag
     * @type {number}
     * @memberof FeatureFlag
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'creationDate': number;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FeatureFlag
     */
    'clientSideAvailability'?: ClientSideAvailability;
    /**
     * An array of possible variations for the flag
     * @type {Array<Variation>}
     * @memberof FeatureFlag
     */
    'variations': Array<Variation>;
    /**
     * Whether the flag is a temporary flag
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'temporary': boolean;
    /**
     * Tags for the feature flag
     * @type {Array<string>}
     * @memberof FeatureFlag
     */
    'tags': Array<string>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlag
     */
    '_links': { [key: string]: Link; };
    /**
     * Associated maintainerId for the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof FeatureFlag
     */
    '_maintainer'?: MemberSummary;
    /**
     * Deprecated
     * @type {Array<string>}
     * @memberof FeatureFlag
     */
    'goalIds'?: Array<string>;
    /**
     * 
     * @type {ExperimentInfoRep}
     * @memberof FeatureFlag
     */
    'experiments': ExperimentInfoRep;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FeatureFlag
     */
    'customProperties': { [key: string]: CustomProperty; };
    /**
     * Boolean indicating if the feature flag is archived
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'archivedDate'?: number;
    /**
     * 
     * @type {Defaults}
     * @memberof FeatureFlag
     */
    'defaults'?: Defaults;
    /**
     * Details on the environments for this flag
     * @type {{ [key: string]: FeatureFlagConfig; }}
     * @memberof FeatureFlag
     */
    'environments': { [key: string]: FeatureFlagConfig; };
}

export const FeatureFlagKindEnum = {
    Boolean: 'boolean',
    Multivariate: 'multivariate'
} as const;

export type FeatureFlagKindEnum = typeof FeatureFlagKindEnum[keyof typeof FeatureFlagKindEnum];

/**
 * 
 * @export
 * @interface FeatureFlagBody
 */
export interface FeatureFlagBody {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'name': string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'key': string;
    /**
     * Description of the feature flag. Defaults to an empty string.
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'description'?: string;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK. Defaults to <code>false</code>.
     * @type {boolean}
     * @memberof FeatureFlagBody
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailabilityPost}
     * @memberof FeatureFlagBody
     */
    'clientSideAvailability'?: ClientSideAvailabilityPost;
    /**
     * An array of possible variations for the flag. The variation values must be unique. If omitted, two boolean variations of <code>true</code> and <code>false</code> will be used.
     * @type {Array<Variation>}
     * @memberof FeatureFlagBody
     */
    'variations'?: Array<Variation>;
    /**
     * Whether the flag is a temporary flag. Defaults to <code>true</code>.
     * @type {boolean}
     * @memberof FeatureFlagBody
     */
    'temporary'?: boolean;
    /**
     * Tags for the feature flag. Defaults to an empty array.
     * @type {Array<string>}
     * @memberof FeatureFlagBody
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FeatureFlagBody
     */
    'customProperties'?: { [key: string]: CustomProperty; };
    /**
     * 
     * @type {Defaults}
     * @memberof FeatureFlagBody
     */
    'defaults'?: Defaults;
}
/**
 * 
 * @export
 * @interface FeatureFlagConfig
 */
export interface FeatureFlagConfig {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'on': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'archived': boolean;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    'sel': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'lastModified': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'version': number;
    /**
     * 
     * @type {Array<Target>}
     * @memberof FeatureFlagConfig
     */
    'targets'?: Array<Target>;
    /**
     * 
     * @type {Array<Rule>}
     * @memberof FeatureFlagConfig
     */
    'rules'?: Array<Rule>;
    /**
     * 
     * @type {VariationOrRolloutRep}
     * @memberof FeatureFlagConfig
     */
    'fallthrough'?: VariationOrRolloutRep;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'offVariation'?: number;
    /**
     * 
     * @type {Array<Prerequisite>}
     * @memberof FeatureFlagConfig
     */
    'prerequisites'?: Array<Prerequisite>;
    /**
     * 
     * @type {Link}
     * @memberof FeatureFlagConfig
     */
    '_site': Link;
    /**
     * 
     * @type {Access}
     * @memberof FeatureFlagConfig
     */
    '_access'?: Access;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    '_environmentName': string;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'trackEvents': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'trackEventsFallthrough': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    '_debugEventsUntilDate'?: number;
    /**
     * 
     * @type {FlagSummary}
     * @memberof FeatureFlagConfig
     */
    '_summary'?: FlagSummary;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChange
 */
export interface FeatureFlagScheduledChange {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagScheduledChange
     */
    '_id': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    '_creationDate': number;
    /**
     * The ID of the scheduled change maintainer
     * @type {string}
     * @memberof FeatureFlagScheduledChange
     */
    '_maintainerId': string;
    /**
     * Version of the scheduled change
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    'executionDate': number;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FeatureFlagScheduledChange
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting scheduled changes
     * @type {any}
     * @memberof FeatureFlagScheduledChange
     */
    'conflicts'?: any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagScheduledChange
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChanges
 */
export interface FeatureFlagScheduledChanges {
    /**
     * Array of scheduled changes
     * @type {Array<FeatureFlagScheduledChange>}
     * @memberof FeatureFlagScheduledChanges
     */
    'items': Array<FeatureFlagScheduledChange>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagScheduledChanges
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagStatus
 */
export interface FeatureFlagStatus {
    /**
     * Status of the flag
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    'name': string;
    /**
     * Timestamp of last time flag was requested
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    'lastRequested'?: string;
    /**
     * Default value seen from code
     * @type {any}
     * @memberof FeatureFlagStatus
     */
    'default'?: any;
}
/**
 * 
 * @export
 * @interface FeatureFlagStatusAcrossEnvironments
 */
export interface FeatureFlagStatusAcrossEnvironments {
    /**
     * Flag status for environment.
     * @type {{ [key: string]: FeatureFlagStatus; }}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    'environments'?: { [key: string]: FeatureFlagStatus; };
    /**
     * feature flag key
     * @type {string}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    'key'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagStatuses
 */
export interface FeatureFlagStatuses {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagStatuses
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Array<FlagStatusRep>}
     * @memberof FeatureFlagStatuses
     */
    'items'?: Array<FlagStatusRep>;
}
/**
 * 
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * An array of feature flags
     * @type {Array<FeatureFlag>}
     * @memberof FeatureFlags
     */
    'items': Array<FeatureFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlags
     */
    '_links': { [key: string]: Link; };
    /**
     * The total number of flags
     * @type {number}
     * @memberof FeatureFlags
     */
    'totalCount'?: number;
    /**
     * The number of flags that have differences between environments. Only shown when query parameter <code>compare</code> is <code>true</code>.
     * @type {number}
     * @memberof FeatureFlags
     */
    'totalCountWithDifferences'?: number;
}
/**
 * 
 * @export
 * @interface FileRep
 */
export interface FileRep {
    /**
     * The imported file name, including the extension
     * @type {string}
     * @memberof FileRep
     */
    'filename'?: string;
    /**
     * The imported file status
     * @type {string}
     * @memberof FileRep
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface FlagConfigApprovalRequestResponse
 */
export interface FlagConfigApprovalRequestResponse {
    /**
     * The ID of this approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_id': string;
    /**
     * Version of the approval request
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'serviceKind': string;
    /**
     * The ID of the member who requested the approval
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'requestorId'?: string;
    /**
     * A human-friendly name for the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'description'?: string;
    /**
     * Current status of the review of this approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'reviewStatus': FlagConfigApprovalRequestResponseReviewStatusEnum;
    /**
     * An array of individual reviews of this approval request
     * @type {Array<ReviewResponse>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'allReviews': Array<ReviewResponse>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'appliedDate'?: number;
    /**
     * The member ID of the member who applied the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'appliedByMemberId'?: string;
    /**
     * Current status of the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'status': FlagConfigApprovalRequestResponseStatusEnum;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting approval requests
     * @type {Array<Conflict>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'conflicts': Array<Conflict>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'executionDate'?: number;
    /**
     * ID of scheduled change to edit or delete
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'integrationMetadata'?: IntegrationMetadata;
    /**
     * 
     * @type {CopiedFromEnv}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'source'?: CopiedFromEnv;
    /**
     * 
     * @type {CustomWorkflowMeta}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'customWorkflowMetadata'?: CustomWorkflowMeta;
}

export const FlagConfigApprovalRequestResponseReviewStatusEnum = {
    Approved: 'approved',
    Declined: 'declined',
    Pending: 'pending'
} as const;

export type FlagConfigApprovalRequestResponseReviewStatusEnum = typeof FlagConfigApprovalRequestResponseReviewStatusEnum[keyof typeof FlagConfigApprovalRequestResponseReviewStatusEnum];
export const FlagConfigApprovalRequestResponseStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed',
    Scheduled: 'scheduled'
} as const;

export type FlagConfigApprovalRequestResponseStatusEnum = typeof FlagConfigApprovalRequestResponseStatusEnum[keyof typeof FlagConfigApprovalRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface FlagConfigApprovalRequestsResponse
 */
export interface FlagConfigApprovalRequestsResponse {
    /**
     * An array of approval requests
     * @type {Array<FlagConfigApprovalRequestResponse>}
     * @memberof FlagConfigApprovalRequestsResponse
     */
    'items': Array<FlagConfigApprovalRequestResponse>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagConfigApprovalRequestsResponse
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagCopyConfigEnvironment
 */
export interface FlagCopyConfigEnvironment {
    /**
     * The environment key
     * @type {string}
     * @memberof FlagCopyConfigEnvironment
     */
    'key': string;
    /**
     * Optional flag version. If you include this, the operation only succeeds if the current flag version in the environment matches this version.
     * @type {number}
     * @memberof FlagCopyConfigEnvironment
     */
    'currentVersion'?: number;
}
/**
 * 
 * @export
 * @interface FlagCopyConfigPost
 */
export interface FlagCopyConfigPost {
    /**
     * 
     * @type {FlagCopyConfigEnvironment}
     * @memberof FlagCopyConfigPost
     */
    'source': FlagCopyConfigEnvironment;
    /**
     * 
     * @type {FlagCopyConfigEnvironment}
     * @memberof FlagCopyConfigPost
     */
    'target': FlagCopyConfigEnvironment;
    /**
     * Optional comment
     * @type {string}
     * @memberof FlagCopyConfigPost
     */
    'comment'?: string;
    /**
     * Optional list of the flag changes to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If you include neither, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof FlagCopyConfigPost
     */
    'includedActions'?: Array<FlagCopyConfigPostIncludedActionsEnum>;
    /**
     * Optional list of the flag changes NOT to copy from the source environment to the target environment. You may include either  <code>includedActions</code> or <code>excludedActions</code>, but not both. If you include neither, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof FlagCopyConfigPost
     */
    'excludedActions'?: Array<FlagCopyConfigPostExcludedActionsEnum>;
}

export const FlagCopyConfigPostIncludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateRules: 'updateRules',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdatePrerequisites: 'updatePrerequisites',
    UpdateTargets: 'updateTargets'
} as const;

export type FlagCopyConfigPostIncludedActionsEnum = typeof FlagCopyConfigPostIncludedActionsEnum[keyof typeof FlagCopyConfigPostIncludedActionsEnum];
export const FlagCopyConfigPostExcludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateRules: 'updateRules',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdatePrerequisites: 'updatePrerequisites',
    UpdateTargets: 'updateTargets'
} as const;

export type FlagCopyConfigPostExcludedActionsEnum = typeof FlagCopyConfigPostExcludedActionsEnum[keyof typeof FlagCopyConfigPostExcludedActionsEnum];

/**
 * 
 * @export
 * @interface FlagDefaults
 */
export interface FlagDefaults {
    /**
     * 
     * @type {Array<string>}
     * @memberof FlagDefaults
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FlagDefaults
     */
    'temporary'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FlagDefaults
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * 
     * @type {BooleanDefaults}
     * @memberof FlagDefaults
     */
    'booleanDefaults'?: BooleanDefaults;
}
/**
 * 
 * @export
 * @interface FlagDefaultsApiBaseRep
 */
export interface FlagDefaultsApiBaseRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagDefaultsApiBaseRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagDefaultsRep
 */
export interface FlagDefaultsRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagDefaultsRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<string>}
     * @memberof FlagDefaultsRep
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FlagDefaultsRep
     */
    'temporary'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FlagDefaultsRep
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * 
     * @type {BooleanDefaults}
     * @memberof FlagDefaultsRep
     */
    'booleanDefaults'?: BooleanDefaults;
}
/**
 * 
 * @export
 * @interface FlagFollowersByProjEnvGetRep
 */
export interface FlagFollowersByProjEnvGetRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagFollowersByProjEnvGetRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of flags and their followers
     * @type {Array<FollowersPerFlag>}
     * @memberof FlagFollowersByProjEnvGetRep
     */
    'items'?: Array<FollowersPerFlag>;
}
/**
 * 
 * @export
 * @interface FlagFollowersGetRep
 */
export interface FlagFollowersGetRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagFollowersGetRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of members who are following this flag
     * @type {Array<FollowFlagMember>}
     * @memberof FlagFollowersGetRep
     */
    'items'?: Array<FollowFlagMember>;
}
/**
 * 
 * @export
 * @interface FlagGlobalAttributesRep
 */
export interface FlagGlobalAttributesRep {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof FlagGlobalAttributesRep
     */
    'name': string;
    /**
     * Kind of feature flag
     * @type {string}
     * @memberof FlagGlobalAttributesRep
     */
    'kind': FlagGlobalAttributesRepKindEnum;
    /**
     * Description of the feature flag
     * @type {string}
     * @memberof FlagGlobalAttributesRep
     */
    'description'?: string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof FlagGlobalAttributesRep
     */
    'key': string;
    /**
     * Version of the feature flag
     * @type {number}
     * @memberof FlagGlobalAttributesRep
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FlagGlobalAttributesRep
     */
    'creationDate': number;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK
     * @type {boolean}
     * @memberof FlagGlobalAttributesRep
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FlagGlobalAttributesRep
     */
    'clientSideAvailability'?: ClientSideAvailability;
    /**
     * An array of possible variations for the flag
     * @type {Array<Variation>}
     * @memberof FlagGlobalAttributesRep
     */
    'variations': Array<Variation>;
    /**
     * Whether the flag is a temporary flag
     * @type {boolean}
     * @memberof FlagGlobalAttributesRep
     */
    'temporary': boolean;
    /**
     * Tags for the feature flag
     * @type {Array<string>}
     * @memberof FlagGlobalAttributesRep
     */
    'tags': Array<string>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagGlobalAttributesRep
     */
    '_links': { [key: string]: Link; };
    /**
     * Associated maintainerId for the feature flag
     * @type {string}
     * @memberof FlagGlobalAttributesRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof FlagGlobalAttributesRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Deprecated
     * @type {Array<string>}
     * @memberof FlagGlobalAttributesRep
     */
    'goalIds'?: Array<string>;
    /**
     * 
     * @type {ExperimentInfoRep}
     * @memberof FlagGlobalAttributesRep
     */
    'experiments': ExperimentInfoRep;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FlagGlobalAttributesRep
     */
    'customProperties': { [key: string]: CustomProperty; };
    /**
     * Boolean indicating if the feature flag is archived
     * @type {boolean}
     * @memberof FlagGlobalAttributesRep
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof FlagGlobalAttributesRep
     */
    'archivedDate'?: number;
    /**
     * 
     * @type {Defaults}
     * @memberof FlagGlobalAttributesRep
     */
    'defaults'?: Defaults;
}

export const FlagGlobalAttributesRepKindEnum = {
    Boolean: 'boolean',
    Multivariate: 'multivariate'
} as const;

export type FlagGlobalAttributesRepKindEnum = typeof FlagGlobalAttributesRepKindEnum[keyof typeof FlagGlobalAttributesRepKindEnum];

/**
 * 
 * @export
 * @interface FlagInput
 */
export interface FlagInput {
    /**
     * The ID of the variation or rollout of the flag to use. Use \"fallthrough\" for the default targeting behavior when the flag is on.
     * @type {string}
     * @memberof FlagInput
     */
    'ruleId': string;
    /**
     * The flag version
     * @type {number}
     * @memberof FlagInput
     */
    'flagConfigVersion': number;
}
/**
 * 
 * @export
 * @interface FlagLinkCollectionRep
 */
export interface FlagLinkCollectionRep {
    /**
     * An array of flag links
     * @type {Array<FlagLinkRep>}
     * @memberof FlagLinkCollectionRep
     */
    'items': Array<FlagLinkRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkCollectionRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagLinkMember
 */
export interface FlagLinkMember {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkMember
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface FlagLinkPost
 */
export interface FlagLinkPost {
    /**
     * The flag link key
     * @type {string}
     * @memberof FlagLinkPost
     */
    'key'?: string;
    /**
     * The integration key for an integration whose <code>manifest.json</code> includes the <code>flagLink</code> capability, if this is a flag link for an existing integration. Do not include for URL flag links.
     * @type {string}
     * @memberof FlagLinkPost
     */
    'integrationKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlagLinkPost
     */
    'timestamp'?: number;
    /**
     * The URL for the external resource you are linking the flag to
     * @type {string}
     * @memberof FlagLinkPost
     */
    'deepLink'?: string;
    /**
     * The title of the flag link
     * @type {string}
     * @memberof FlagLinkPost
     */
    'title'?: string;
    /**
     * The description of the flag link
     * @type {string}
     * @memberof FlagLinkPost
     */
    'description'?: string;
    /**
     * The metadata required by this integration in order to create a flag link, if this is a flag link for an existing integration. Defined in the integration\'s <code>manifest.json</code> file under <code>flagLink</code>.
     * @type {{ [key: string]: string; }}
     * @memberof FlagLinkPost
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface FlagLinkRep
 */
export interface FlagLinkRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The flag link key
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_key'?: string;
    /**
     * The integration key for an integration whose <code>manifest.json</code> includes the <code>flagLink</code> capability, if this is a flag link for an existing integration
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_integrationKey'?: string;
    /**
     * The ID of this flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_id': string;
    /**
     * The URL for the external resource the flag is linked to
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_deepLink': string;
    /**
     * 
     * @type {TimestampRep}
     * @memberof FlagLinkRep
     */
    '_timestamp': TimestampRep;
    /**
     * The title of the flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    'title'?: string;
    /**
     * The description of the flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    'description'?: string;
    /**
     * The metadata required by this integration in order to create a flag link, if this is a flag link for an existing integration. Defined in the integration\'s <code>manifest.json</code> file under <code>flagLink</code>.
     * @type {{ [key: string]: string; }}
     * @memberof FlagLinkRep
     */
    '_metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof FlagLinkRep
     */
    '_createdAt': number;
    /**
     * 
     * @type {FlagLinkMember}
     * @memberof FlagLinkRep
     */
    '_member'?: FlagLinkMember;
}
/**
 * 
 * @export
 * @interface FlagListingRep
 */
export interface FlagListingRep {
    /**
     * 
     * @type {string}
     * @memberof FlagListingRep
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlagListingRep
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagListingRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof FlagListingRep
     */
    '_site'?: Link;
}
/**
 * 
 * @export
 * @interface FlagRep
 */
export interface FlagRep {
    /**
     * The targeting rule
     * @type {string}
     * @memberof FlagRep
     */
    'targetingRule'?: string;
    /**
     * The rule description
     * @type {string}
     * @memberof FlagRep
     */
    'targetingRuleDescription'?: string;
    /**
     * Clause(s) used for targeting certain users by their attributes
     * @type {Array<any>}
     * @memberof FlagRep
     */
    'targetingRuleClauses'?: Array<any>;
    /**
     * The flag version
     * @type {number}
     * @memberof FlagRep
     */
    'flagConfigVersion'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagScheduledChangesInput
 */
export interface FlagScheduledChangesInput {
    /**
     * Optional comment describing the update to the scheduled changes
     * @type {string}
     * @memberof FlagScheduledChangesInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagScheduledChangesInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface FlagStatusRep
 */
export interface FlagStatusRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagStatusRep
     */
    '_links': { [key: string]: Link; };
    /**
     * Status of the flag
     * @type {string}
     * @memberof FlagStatusRep
     */
    'name'?: string;
    /**
     * Timestamp of last time flag was requested
     * @type {string}
     * @memberof FlagStatusRep
     */
    'lastRequested'?: string;
    /**
     * Default value seen from code
     * @type {any}
     * @memberof FlagStatusRep
     */
    'default'?: any;
}
/**
 * 
 * @export
 * @interface FlagSummary
 */
export interface FlagSummary {
    /**
     * 
     * @type {{ [key: string]: VariationSummary; }}
     * @memberof FlagSummary
     */
    'variations': { [key: string]: VariationSummary; };
    /**
     * 
     * @type {number}
     * @memberof FlagSummary
     */
    'prerequisites': number;
}
/**
 * 
 * @export
 * @interface FlagTriggerInput
 */
export interface FlagTriggerInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof FlagTriggerInput
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating. This should be an array with objects that look like <code>{\"kind\": \"trigger_action\"}</code>.
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagTriggerInput
     */
    'instructions'?: Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface FollowFlagMember
 */
export interface FollowFlagMember {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FollowFlagMember
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof FollowFlagMember
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof FollowFlagMember
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof FollowFlagMember
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof FollowFlagMember
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof FollowFlagMember
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface FollowersPerFlag
 */
export interface FollowersPerFlag {
    /**
     * The flag key
     * @type {string}
     * @memberof FollowersPerFlag
     */
    'flagKey'?: string;
    /**
     * A list of members who are following this flag
     * @type {Array<FollowFlagMember>}
     * @memberof FollowersPerFlag
     */
    'followers'?: Array<FollowFlagMember>;
}
/**
 * 
 * @export
 * @interface ForbiddenErrorRep
 */
export interface ForbiddenErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof ForbiddenErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof ForbiddenErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface HunkRep
 */
export interface HunkRep {
    /**
     * Line number of beginning of code reference hunk
     * @type {number}
     * @memberof HunkRep
     */
    'startingLineNumber': number;
    /**
     * Contextual lines of code that include the referenced feature flag
     * @type {string}
     * @memberof HunkRep
     */
    'lines'?: string;
    /**
     * The project key
     * @type {string}
     * @memberof HunkRep
     */
    'projKey'?: string;
    /**
     * The feature flag key
     * @type {string}
     * @memberof HunkRep
     */
    'flagKey'?: string;
    /**
     * An array of flag key aliases
     * @type {Array<string>}
     * @memberof HunkRep
     */
    'aliases'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Import
 */
export interface Import {
    /**
     * The import ID
     * @type {string}
     * @memberof Import
     */
    'id': string;
    /**
     * The segment key
     * @type {string}
     * @memberof Import
     */
    'segmentKey': string;
    /**
     * 
     * @type {number}
     * @memberof Import
     */
    'creationTime': number;
    /**
     * The import mode used, either <code>merge</code> or <code>replace</code>
     * @type {string}
     * @memberof Import
     */
    'mode': string;
    /**
     * The import status
     * @type {string}
     * @memberof Import
     */
    'status': string;
    /**
     * The imported files and their status
     * @type {Array<FileRep>}
     * @memberof Import
     */
    'files'?: Array<FileRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Import
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface InitiatorRep
 */
export interface InitiatorRep {
    /**
     * The name of the member who initiated the export
     * @type {string}
     * @memberof InitiatorRep
     */
    'name'?: string;
    /**
     * The email address of the member who initiated the export
     * @type {string}
     * @memberof InitiatorRep
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface InstructionUserRequest
 */
export interface InstructionUserRequest {
    /**
     * The type of change to make to the removal date for this user from individual targeting for this flag.
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'kind': InstructionUserRequestKindEnum;
    /**
     * The flag key
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'flagKey': string;
    /**
     * ID of a variation on the flag
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'variationId': string;
    /**
     * The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. Required if <code>kind</code> is <code>addExpireUserTargetDate</code> or <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof InstructionUserRequest
     */
    'value'?: number;
    /**
     * The version of the flag variation to update. You can retrieve this by making a GET request for the flag. Required if <code>kind</code> is <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof InstructionUserRequest
     */
    'version'?: number;
}

export const InstructionUserRequestKindEnum = {
    AddExpireUserTargetDate: 'addExpireUserTargetDate',
    UpdateExpireUserTargetDate: 'updateExpireUserTargetDate',
    RemoveExpireUserTargetDate: 'removeExpireUserTargetDate'
} as const;

export type InstructionUserRequestKindEnum = typeof InstructionUserRequestKindEnum[keyof typeof InstructionUserRequestKindEnum];

/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Integration
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The ID for this integration audit log subscription
     * @type {string}
     * @memberof Integration
     */
    '_id'?: string;
    /**
     * The type of integration
     * @type {string}
     * @memberof Integration
     */
    'kind'?: string;
    /**
     * A human-friendly name for the integration
     * @type {string}
     * @memberof Integration
     */
    'name'?: string;
    /**
     * Details on configuration for an integration of this type. Refer to the <code>formVariables</code> field in the corresponding <code>manifest.json</code> for a full list of fields for each integration.
     * @type {{ [key: string]: any; }}
     * @memberof Integration
     */
    'config'?: { [key: string]: any; };
    /**
     * Represents a Custom role policy, defining a resource kinds filter the integration audit log subscription responds to.
     * @type {Array<Statement>}
     * @memberof Integration
     */
    'statements'?: Array<Statement>;
    /**
     * Whether the integration is currently active
     * @type {boolean}
     * @memberof Integration
     */
    'on'?: boolean;
    /**
     * An array of tags for this integration
     * @type {Array<string>}
     * @memberof Integration
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Access}
     * @memberof Integration
     */
    '_access'?: Access;
    /**
     * 
     * @type {IntegrationSubscriptionStatusRep}
     * @memberof Integration
     */
    '_status'?: IntegrationSubscriptionStatusRep;
    /**
     * Slack webhook receiver URL. Only used for legacy Slack webhook integrations.
     * @type {string}
     * @memberof Integration
     */
    'url'?: string;
    /**
     * Datadog API key. Only used for legacy Datadog webhook integrations.
     * @type {string}
     * @memberof Integration
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfiguration
 */
export interface IntegrationDeliveryConfiguration {
    /**
     * 
     * @type {IntegrationDeliveryConfigurationLinks}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_links': IntegrationDeliveryConfigurationLinks;
    /**
     * The integration ID
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_id': string;
    /**
     * The integration key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'integrationKey': string;
    /**
     * The project key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'projectKey': string;
    /**
     * The environment key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'environmentKey': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof IntegrationDeliveryConfiguration
     */
    'config': { [key: string]: any; };
    /**
     * Whether the configuration is turned on
     * @type {boolean}
     * @memberof IntegrationDeliveryConfiguration
     */
    'on': boolean;
    /**
     * List of tags for this configuration
     * @type {Array<string>}
     * @memberof IntegrationDeliveryConfiguration
     */
    'tags': Array<string>;
    /**
     * Name of the configuration
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'name': string;
    /**
     * Version of the current configuration
     * @type {number}
     * @memberof IntegrationDeliveryConfiguration
     */
    'version': number;
    /**
     * 
     * @type {Access}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationCollection
 */
export interface IntegrationDeliveryConfigurationCollection {
    /**
     * 
     * @type {IntegrationDeliveryConfigurationCollectionLinks}
     * @memberof IntegrationDeliveryConfigurationCollection
     */
    '_links': IntegrationDeliveryConfigurationCollectionLinks;
    /**
     * An array of integration delivery configurations
     * @type {Array<IntegrationDeliveryConfiguration>}
     * @memberof IntegrationDeliveryConfigurationCollection
     */
    'items': Array<IntegrationDeliveryConfiguration>;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationCollectionLinks
 */
export interface IntegrationDeliveryConfigurationCollectionLinks {
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationCollectionLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationCollectionLinks
     */
    'parent'?: Link;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationLinks
 */
export interface IntegrationDeliveryConfigurationLinks {
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'parent': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'project': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'environment': Link;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationPost
 */
export interface IntegrationDeliveryConfigurationPost {
    /**
     * Whether the delivery configuration is active. Default value is false.
     * @type {boolean}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'on'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'config': { [key: string]: any; };
    /**
     * Tags to associate with the integration
     * @type {Array<string>}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'tags'?: Array<string>;
    /**
     * Name to identify the integration
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationResponse
 */
export interface IntegrationDeliveryConfigurationResponse {
    /**
     * The status code returned by the validation
     * @type {number}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'timestamp'?: number;
    /**
     * JSON response to the validation request
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'responseBody'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationMetadata
 */
export interface IntegrationMetadata {
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'externalId': string;
    /**
     * 
     * @type {IntegrationStatus}
     * @memberof IntegrationMetadata
     */
    'externalStatus': IntegrationStatus;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'externalUrl': string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'lastChecked': number;
}
/**
 * 
 * @export
 * @interface IntegrationStatus
 */
export interface IntegrationStatus {
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatus
     */
    'display': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatus
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface IntegrationStatusRep
 */
export interface IntegrationStatusRep {
    /**
     * 
     * @type {number}
     * @memberof IntegrationStatusRep
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatusRep
     */
    'responseBody'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationStatusRep
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface IntegrationSubscriptionStatusRep
 */
export interface IntegrationSubscriptionStatusRep {
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'lastSuccess'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'lastError'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'errorCount'?: number;
    /**
     * 
     * @type {Array<IntegrationStatusRep>}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'errors'?: Array<IntegrationStatusRep>;
}
/**
 * 
 * @export
 * @interface Integrations
 */
export interface Integrations {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof Integrations
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<Integration>}
     * @memberof Integrations
     */
    'items'?: Array<Integration>;
    /**
     * 
     * @type {string}
     * @memberof Integrations
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface InvalidRequestErrorRep
 */
export interface InvalidRequestErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof InvalidRequestErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof InvalidRequestErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IpList
 */
export interface IpList {
    /**
     * A list of the IP addresses LaunchDarkly\'s service uses
     * @type {Array<string>}
     * @memberof IpList
     */
    'addresses': Array<string>;
    /**
     * A list of the IP addresses outgoing webhook notifications use
     * @type {Array<string>}
     * @memberof IpList
     */
    'outboundAddresses': Array<string>;
}
/**
 * 
 * @export
 * @interface IterationExpandableProperties
 */
export interface IterationExpandableProperties {
    /**
     * Details on the variations you are testing in the experiment
     * @type {Array<TreatmentRep>}
     * @memberof IterationExpandableProperties
     */
    'treatments'?: Array<TreatmentRep>;
    /**
     * Details on the secondary metrics for this experiment
     * @type {Array<MetricV2Rep>}
     * @memberof IterationExpandableProperties
     */
    'secondaryMetrics'?: Array<MetricV2Rep>;
}
/**
 * 
 * @export
 * @interface IterationInput
 */
export interface IterationInput {
    /**
     * The expected outcome of this experiment
     * @type {string}
     * @memberof IterationInput
     */
    'hypothesis': string;
    /**
     * Whether to allow the experiment to reassign users to different variations (true) or keep users assigned to their initial variation (false). Defaults to true.
     * @type {boolean}
     * @memberof IterationInput
     */
    'canReshuffleTraffic'?: boolean;
    /**
     * 
     * @type {Array<MetricInput>}
     * @memberof IterationInput
     */
    'metrics': Array<MetricInput>;
    /**
     * 
     * @type {Array<TreatmentInput>}
     * @memberof IterationInput
     */
    'treatments': Array<TreatmentInput>;
    /**
     * 
     * @type {{ [key: string]: FlagInput; }}
     * @memberof IterationInput
     */
    'flags': { [key: string]: FlagInput; };
}
/**
 * 
 * @export
 * @interface IterationRep
 */
export interface IterationRep {
    /**
     * The iteration ID
     * @type {string}
     * @memberof IterationRep
     */
    '_id'?: string;
    /**
     * The expected outcome of this experiment
     * @type {string}
     * @memberof IterationRep
     */
    'hypothesis': string;
    /**
     * The status of the iteration: <code>not_started</code>, <code>running</code>, <code>stopped</code>
     * @type {string}
     * @memberof IterationRep
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'startedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'endedAt'?: number;
    /**
     * The ID of the treatment with the probability to be best
     * @type {string}
     * @memberof IterationRep
     */
    'winningTreatmentId'?: string;
    /**
     * The reason you stopped the experiment
     * @type {string}
     * @memberof IterationRep
     */
    'winningReason'?: string;
    /**
     * Whether the experiment is allowed to reassign users to different variations (true) or must keep users assigned to their initial variation (false).
     * @type {boolean}
     * @memberof IterationRep
     */
    'canReshuffleTraffic'?: boolean;
    /**
     * Details on the flag used in this experiment
     * @type {{ [key: string]: FlagRep; }}
     * @memberof IterationRep
     */
    'flags'?: { [key: string]: FlagRep; };
    /**
     * 
     * @type {MetricV2Rep}
     * @memberof IterationRep
     */
    'primaryMetric'?: MetricV2Rep;
    /**
     * Details on the variations you are testing in the experiment
     * @type {Array<TreatmentRep>}
     * @memberof IterationRep
     */
    'treatments'?: Array<TreatmentRep>;
    /**
     * Details on the secondary metrics for this experiment
     * @type {Array<MetricV2Rep>}
     * @memberof IterationRep
     */
    'secondaryMetrics'?: Array<MetricV2Rep>;
}
/**
 * 
 * @export
 * @interface LastSeenMetadata
 */
export interface LastSeenMetadata {
    /**
     * The ID of the token used in the member\'s last session
     * @type {string}
     * @memberof LastSeenMetadata
     */
    'tokenId'?: string;
}
/**
 * 
 * @export
 * @interface LegacyExperimentRep
 */
export interface LegacyExperimentRep {
    /**
     * 
     * @type {string}
     * @memberof LegacyExperimentRep
     */
    'metricKey'?: string;
    /**
     * 
     * @type {MetricListingRep}
     * @memberof LegacyExperimentRep
     */
    '_metric'?: MetricListingRep;
    /**
     * 
     * @type {Array<string>}
     * @memberof LegacyExperimentRep
     */
    'environments'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: ExperimentEnvironmentSettingRep; }}
     * @memberof LegacyExperimentRep
     */
    '_environmentSettings'?: { [key: string]: ExperimentEnvironmentSettingRep; };
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface MaintainerTeam
 */
export interface MaintainerTeam {
    /**
     * 
     * @type {string}
     * @memberof MaintainerTeam
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintainerTeam
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof MaintainerTeam
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Member
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof Member
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof Member
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof Member
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof Member
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * Whether the member has a pending invitation
     * @type {boolean}
     * @memberof Member
     */
    '_pendingInvite': boolean;
    /**
     * Whether the member\'s email address has been verified
     * @type {boolean}
     * @memberof Member
     */
    '_verified': boolean;
    /**
     * The member\'s email address before it has been verified, for accounts where email verification is required
     * @type {string}
     * @memberof Member
     */
    '_pendingEmail'?: string;
    /**
     * The set of custom roles (as keys) assigned to the member
     * @type {Array<string>}
     * @memberof Member
     */
    'customRoles': Array<string>;
    /**
     * Whether multi-factor authentication is enabled for this member
     * @type {string}
     * @memberof Member
     */
    'mfa': string;
    /**
     * Default dashboards that the member has chosen to ignore
     * @type {Array<string>}
     * @memberof Member
     */
    'excludedDashboards'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    '_lastSeen': number;
    /**
     * 
     * @type {LastSeenMetadata}
     * @memberof Member
     */
    '_lastSeenMetadata'?: LastSeenMetadata;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof Member
     */
    '_integrationMetadata'?: IntegrationMetadata;
    /**
     * Details on the teams this member is assigned to
     * @type {Array<MemberTeamSummaryRep>}
     * @memberof Member
     */
    'teams'?: Array<MemberTeamSummaryRep>;
    /**
     * A list of permission grants. Permission grants allow a member to have access to a specific action, without having to create or update a custom role.
     * @type {Array<MemberPermissionGrantSummaryRep>}
     * @memberof Member
     */
    'permissionGrants'?: Array<MemberPermissionGrantSummaryRep>;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    'creationDate': number;
    /**
     * A list of OAuth providers
     * @type {Array<string>}
     * @memberof Member
     */
    'oauthProviders'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MemberDataRep
 */
export interface MemberDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof MemberDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The member ID
     * @type {string}
     * @memberof MemberDataRep
     */
    '_id'?: string;
    /**
     * The member email
     * @type {string}
     * @memberof MemberDataRep
     */
    'email'?: string;
    /**
     * The member first name
     * @type {string}
     * @memberof MemberDataRep
     */
    'firstName'?: string;
    /**
     * The member last name
     * @type {string}
     * @memberof MemberDataRep
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface MemberImportItem
 */
export interface MemberImportItem {
    /**
     * An error message, including CSV line number, if the <code>status</code> is <code>error</code>
     * @type {string}
     * @memberof MemberImportItem
     */
    'message'?: string;
    /**
     * Whether this member can be successfully imported (<code>success</code>) or not (<code>error</code>). Even if the status is <code>success</code>, members are only added to a team on a <code>201</code> response.
     * @type {string}
     * @memberof MemberImportItem
     */
    'status': string;
    /**
     * The email address for the member requested to be added to this team. May be blank or an error, such as \'invalid email format\', if the email address cannot be found or parsed.
     * @type {string}
     * @memberof MemberImportItem
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MemberPermissionGrantSummaryRep
 */
export interface MemberPermissionGrantSummaryRep {
    /**
     * The name of the a group of related actions to allow. A permission grant may have either an <code>actionSet</code> or a list of <code>actions</code> but not both at the same time.
     * @type {string}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'actionSet': string;
    /**
     * A list of actions to allow
     * @type {Array<string>}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'actions': Array<string>;
    /**
     * The resource for which the <code>actions</code> are allowed
     * @type {string}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface MemberSummary
 */
export interface MemberSummary {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MemberSummary
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof MemberSummary
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof MemberSummary
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof MemberSummary
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof MemberSummary
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof MemberSummary
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MemberTeamSummaryRep
 */
export interface MemberTeamSummaryRep {
    /**
     * A list of keys of the custom roles this team has access to
     * @type {Array<string>}
     * @memberof MemberTeamSummaryRep
     */
    'customRoleKeys': Array<string>;
    /**
     * The team key
     * @type {string}
     * @memberof MemberTeamSummaryRep
     */
    'key': string;
    /**
     * The team name
     * @type {string}
     * @memberof MemberTeamSummaryRep
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MemberTeamsPostInput
 */
export interface MemberTeamsPostInput {
    /**
     * List of team keys
     * @type {Array<string>}
     * @memberof MemberTeamsPostInput
     */
    'teamKeys': Array<string>;
}
/**
 * 
 * @export
 * @interface Members
 */
export interface Members {
    /**
     * An array of members
     * @type {Array<Member>}
     * @memberof Members
     */
    'items': Array<Member>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Members
     */
    '_links': { [key: string]: Link; };
    /**
     * The number of members returned
     * @type {number}
     * @memberof Members
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface MembersPatchInput
 */
export interface MembersPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof MembersPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof MembersPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface MethodNotAllowedErrorRep
 */
export interface MethodNotAllowedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof MethodNotAllowedErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof MethodNotAllowedErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface MetricCollectionRep
 */
export interface MetricCollectionRep {
    /**
     * An array of metrics
     * @type {Array<MetricListingRep>}
     * @memberof MetricCollectionRep
     */
    'items'?: Array<MetricListingRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface MetricInput
 */
export interface MetricInput {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricInput
     */
    'key': string;
    /**
     * Whether this is a primary metric (true) or a secondary metric (false)
     * @type {boolean}
     * @memberof MetricInput
     */
    'primary': boolean;
}
/**
 * 
 * @export
 * @interface MetricListingRep
 */
export interface MetricListingRep {
    /**
     * The number of experiments using this metric
     * @type {number}
     * @memberof MetricListingRep
     */
    'experimentCount'?: number;
    /**
     * The ID of this metric
     * @type {string}
     * @memberof MetricListingRep
     */
    '_id': string;
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricListingRep
     */
    'kind': MetricListingRepKindEnum;
    /**
     * The number of feature flags currently attached to this metric
     * @type {number}
     * @memberof MetricListingRep
     */
    '_attachedFlagCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricListingRep
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MetricListingRep
     */
    '_site'?: Link;
    /**
     * 
     * @type {Access}
     * @memberof MetricListingRep
     */
    '_access'?: Access;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricListingRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MetricListingRep
     */
    '_creationDate': number;
    /**
     * 
     * @type {Modification}
     * @memberof MetricListingRep
     */
    'lastModified'?: Modification;
    /**
     * The ID of the member who maintains this metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof MetricListingRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'description'?: string;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when users taken an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricListingRep
     */
    'isNumeric'?: boolean;
    /**
     * For numeric custom metrics, the success criteria
     * @type {string}
     * @memberof MetricListingRep
     */
    'successCriteria'?: MetricListingRepSuccessCriteriaEnum;
    /**
     * For numeric custom metrics, the unit of measure
     * @type {string}
     * @memberof MetricListingRep
     */
    'unit'?: string;
    /**
     * For custom metrics, the event name to use in your code
     * @type {string}
     * @memberof MetricListingRep
     */
    'eventKey'?: string;
}

export const MetricListingRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricListingRepKindEnum = typeof MetricListingRepKindEnum[keyof typeof MetricListingRepKindEnum];
export const MetricListingRepSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricListingRepSuccessCriteriaEnum = typeof MetricListingRepSuccessCriteriaEnum[keyof typeof MetricListingRepSuccessCriteriaEnum];

/**
 * 
 * @export
 * @interface MetricListingRepExpandableProperties
 */
export interface MetricListingRepExpandableProperties {
    /**
     * The number of experiments using this metric
     * @type {number}
     * @memberof MetricListingRepExpandableProperties
     */
    'experimentCount'?: number;
}
/**
 * 
 * @export
 * @interface MetricPost
 */
export interface MetricPost {
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricPost
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricPost
     */
    'name'?: string;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricPost
     */
    'description'?: string;
    /**
     * The kind of event your metric will track
     * @type {string}
     * @memberof MetricPost
     */
    'kind': MetricPostKindEnum;
    /**
     * One or more CSS selectors. Required for click metrics.
     * @type {string}
     * @memberof MetricPost
     */
    'selector'?: string;
    /**
     * One or more target URLs. Required for click and pageview metrics.
     * @type {Array<UrlPost>}
     * @memberof MetricPost
     */
    'urls'?: Array<UrlPost>;
    /**
     * Whether the metric is active
     * @type {boolean}
     * @memberof MetricPost
     */
    'isActive'?: boolean;
    /**
     * Whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when users taken an action (<code>false</code>). Required for custom metrics.
     * @type {boolean}
     * @memberof MetricPost
     */
    'isNumeric'?: boolean;
    /**
     * The unit of measure. Only for numeric custom metrics.
     * @type {string}
     * @memberof MetricPost
     */
    'unit'?: string;
    /**
     * The event name to use in your code. Required for custom metrics.
     * @type {string}
     * @memberof MetricPost
     */
    'eventKey'?: string;
    /**
     * Success criteria. Required for numeric custom metrics.
     * @type {string}
     * @memberof MetricPost
     */
    'successCriteria'?: MetricPostSuccessCriteriaEnum;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricPost
     */
    'tags'?: Array<string>;
}

export const MetricPostKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricPostKindEnum = typeof MetricPostKindEnum[keyof typeof MetricPostKindEnum];
export const MetricPostSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricPostSuccessCriteriaEnum = typeof MetricPostSuccessCriteriaEnum[keyof typeof MetricPostSuccessCriteriaEnum];

/**
 * 
 * @export
 * @interface MetricRep
 */
export interface MetricRep {
    /**
     * The number of experiments using this metric
     * @type {number}
     * @memberof MetricRep
     */
    'experimentCount'?: number;
    /**
     * The ID of this metric
     * @type {string}
     * @memberof MetricRep
     */
    '_id': string;
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricRep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricRep
     */
    'kind': MetricRepKindEnum;
    /**
     * The number of feature flags currently attached to this metric
     * @type {number}
     * @memberof MetricRep
     */
    '_attachedFlagCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricRep
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MetricRep
     */
    '_site'?: Link;
    /**
     * 
     * @type {Access}
     * @memberof MetricRep
     */
    '_access'?: Access;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MetricRep
     */
    '_creationDate': number;
    /**
     * 
     * @type {Modification}
     * @memberof MetricRep
     */
    'lastModified'?: Modification;
    /**
     * The ID of the member who maintains this metric
     * @type {string}
     * @memberof MetricRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof MetricRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricRep
     */
    'description'?: string;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when users taken an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricRep
     */
    'isNumeric'?: boolean;
    /**
     * For numeric custom metrics, the success criteria
     * @type {string}
     * @memberof MetricRep
     */
    'successCriteria'?: MetricRepSuccessCriteriaEnum;
    /**
     * For numeric custom metrics, the unit of measure
     * @type {string}
     * @memberof MetricRep
     */
    'unit'?: string;
    /**
     * For custom metrics, the event name to use in your code
     * @type {string}
     * @memberof MetricRep
     */
    'eventKey'?: string;
    /**
     * 
     * @type {Array<DependentExperimentRep>}
     * @memberof MetricRep
     */
    'experiments'?: Array<DependentExperimentRep>;
    /**
     * Whether the metric is active
     * @type {boolean}
     * @memberof MetricRep
     */
    'isActive'?: boolean;
    /**
     * Details on the flags attached to this metric
     * @type {Array<FlagListingRep>}
     * @memberof MetricRep
     */
    '_attachedFeatures'?: Array<FlagListingRep>;
    /**
     * Version of the metric
     * @type {number}
     * @memberof MetricRep
     */
    '_version'?: number;
    /**
     * For click metrics, the CSS selectors
     * @type {string}
     * @memberof MetricRep
     */
    'selector'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof MetricRep
     */
    'urls'?: Array<{ [key: string]: any; }>;
}

export const MetricRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricRepKindEnum = typeof MetricRepKindEnum[keyof typeof MetricRepKindEnum];
export const MetricRepSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricRepSuccessCriteriaEnum = typeof MetricRepSuccessCriteriaEnum[keyof typeof MetricRepSuccessCriteriaEnum];

/**
 * 
 * @export
 * @interface MetricRepExpandableProperties
 */
export interface MetricRepExpandableProperties {
    /**
     * 
     * @type {Array<DependentExperimentRep>}
     * @memberof MetricRepExpandableProperties
     */
    'experiments'?: Array<DependentExperimentRep>;
}
/**
 * 
 * @export
 * @interface MetricSeen
 */
export interface MetricSeen {
    /**
     * Whether the metric has received an event for this iteration
     * @type {boolean}
     * @memberof MetricSeen
     */
    'ever'?: boolean;
    /**
     * Timestamp of when the metric most recently received an event for this iteration
     * @type {number}
     * @memberof MetricSeen
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface MetricV2Rep
 */
export interface MetricV2Rep {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricV2Rep
     */
    'key': string;
    /**
     * The metric name
     * @type {string}
     * @memberof MetricV2Rep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricV2Rep
     */
    'kind': MetricV2RepKindEnum;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricV2Rep
     */
    '_links': { [key: string]: Link; };
}

export const MetricV2RepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricV2RepKindEnum = typeof MetricV2RepKindEnum[keyof typeof MetricV2RepKindEnum];

/**
 * 
 * @export
 * @interface Modification
 */
export interface Modification {
    /**
     * 
     * @type {string}
     * @memberof Modification
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface MultiEnvironmentDependentFlag
 */
export interface MultiEnvironmentDependentFlag {
    /**
     * The flag name
     * @type {string}
     * @memberof MultiEnvironmentDependentFlag
     */
    'name'?: string;
    /**
     * The flag key
     * @type {string}
     * @memberof MultiEnvironmentDependentFlag
     */
    'key': string;
    /**
     * A list of environments in which the dependent flag appears
     * @type {Array<DependentFlagEnvironment>}
     * @memberof MultiEnvironmentDependentFlag
     */
    'environments': Array<DependentFlagEnvironment>;
}
/**
 * 
 * @export
 * @interface MultiEnvironmentDependentFlags
 */
export interface MultiEnvironmentDependentFlags {
    /**
     * An array of dependent flags with their environment information
     * @type {Array<MultiEnvironmentDependentFlag>}
     * @memberof MultiEnvironmentDependentFlags
     */
    'items': Array<MultiEnvironmentDependentFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MultiEnvironmentDependentFlags
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MultiEnvironmentDependentFlags
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface NewMemberForm
 */
export interface NewMemberForm {
    /**
     * The member\'s email
     * @type {string}
     * @memberof NewMemberForm
     */
    'email': string;
    /**
     * The member\'s password
     * @type {string}
     * @memberof NewMemberForm
     */
    'password'?: string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof NewMemberForm
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof NewMemberForm
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role
     * @type {string}
     * @memberof NewMemberForm
     */
    'role'?: NewMemberFormRoleEnum;
    /**
     * An array of the member\'s custom roles
     * @type {Array<string>}
     * @memberof NewMemberForm
     */
    'customRoles'?: Array<string>;
    /**
     * An array of the member\'s teams
     * @type {Array<string>}
     * @memberof NewMemberForm
     */
    'teamKeys'?: Array<string>;
}

export const NewMemberFormRoleEnum = {
    Reader: 'reader',
    Writer: 'writer',
    Admin: 'admin',
    NoAccess: 'no_access'
} as const;

export type NewMemberFormRoleEnum = typeof NewMemberFormRoleEnum[keyof typeof NewMemberFormRoleEnum];

/**
 * 
 * @export
 * @interface NotFoundErrorRep
 */
export interface NotFoundErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof NotFoundErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof NotFoundErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface OauthClientPost
 */
export interface OauthClientPost {
    /**
     * The name of your new LaunchDarkly OAuth 2.0 client.
     * @type {string}
     * @memberof OauthClientPost
     */
    'name'?: string;
    /**
     * The redirect URI for your new OAuth 2.0 application. This should be an absolute URL conforming with the standard HTTPS protocol.
     * @type {string}
     * @memberof OauthClientPost
     */
    'redirectUri'?: string;
    /**
     * Description of your OAuth 2.0 client.
     * @type {string}
     * @memberof OauthClientPost
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ParameterDefault
 */
export interface ParameterDefault {
    /**
     * The default value for the given parameter
     * @type {any}
     * @memberof ParameterDefault
     */
    'value'?: any;
    /**
     * Variation value for boolean flags. Not applicable for non-boolean flags.
     * @type {boolean}
     * @memberof ParameterDefault
     */
    'booleanVariationValue'?: boolean;
    /**
     * 
     * @type {RuleClause}
     * @memberof ParameterDefault
     */
    'ruleClause'?: RuleClause;
}
/**
 * 
 * @export
 * @interface ParameterDefaultInput
 */
export interface ParameterDefaultInput {
    /**
     * 
     * @type {any}
     * @memberof ParameterDefaultInput
     */
    'value'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ParameterDefaultInput
     */
    'booleanVariationValue'?: boolean;
}
/**
 * 
 * @export
 * @interface ParameterRep
 */
export interface ParameterRep {
    /**
     * 
     * @type {string}
     * @memberof ParameterRep
     */
    'variationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterRep
     */
    'flagKey'?: string;
}
/**
 * 
 * @export
 * @interface ParentResourceRep
 */
export interface ParentResourceRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof ParentResourceRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The name of the parent resource
     * @type {string}
     * @memberof ParentResourceRep
     */
    'name'?: string;
    /**
     * The parent\'s resource specifier
     * @type {string}
     * @memberof ParentResourceRep
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface PatchFailedErrorRep
 */
export interface PatchFailedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof PatchFailedErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof PatchFailedErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface PatchFlagsRequest
 */
export interface PatchFlagsRequest {
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof PatchFlagsRequest
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PatchFlagsRequest
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * The type of operation to perform
     * @type {string}
     * @memberof PatchOperation
     */
    'op': string;
    /**
     * A JSON Pointer string specifying the part of the document to operate on
     * @type {string}
     * @memberof PatchOperation
     */
    'path': string;
    /**
     * A JSON value used in \"add\", \"replace\", and \"test\" operations
     * @type {any}
     * @memberof PatchOperation
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface PatchSegmentInstruction
 */
export interface PatchSegmentInstruction {
    /**
     * The type of change to make to the user\'s removal date from this segment
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'kind': PatchSegmentInstructionKindEnum;
    /**
     * A unique key used to represent the user
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'userKey': string;
    /**
     * The segment\'s target type
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'targetType': PatchSegmentInstructionTargetTypeEnum;
    /**
     * The time, in Unix milliseconds, when the user should be removed from this segment. Required if <code>kind</code> is <code>addExpireUserTargetDate</code> or <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof PatchSegmentInstruction
     */
    'value'?: number;
    /**
     * The version of the segment to update. Required if <code>kind</code> is <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof PatchSegmentInstruction
     */
    'version'?: number;
}

export const PatchSegmentInstructionKindEnum = {
    AddExpireUserTargetDate: 'addExpireUserTargetDate',
    UpdateExpireUserTargetDate: 'updateExpireUserTargetDate',
    RemoveExpireUserTargetDate: 'removeExpireUserTargetDate'
} as const;

export type PatchSegmentInstructionKindEnum = typeof PatchSegmentInstructionKindEnum[keyof typeof PatchSegmentInstructionKindEnum];
export const PatchSegmentInstructionTargetTypeEnum = {
    Included: 'included',
    Excluded: 'excluded'
} as const;

export type PatchSegmentInstructionTargetTypeEnum = typeof PatchSegmentInstructionTargetTypeEnum[keyof typeof PatchSegmentInstructionTargetTypeEnum];

/**
 * 
 * @export
 * @interface PatchSegmentRequest
 */
export interface PatchSegmentRequest {
    /**
     * Optional description of changes
     * @type {string}
     * @memberof PatchSegmentRequest
     */
    'comment'?: string;
    /**
     * Semantic patch instructions for the desired changes to the resource
     * @type {Array<PatchSegmentInstruction>}
     * @memberof PatchSegmentRequest
     */
    'instructions': Array<PatchSegmentInstruction>;
}
/**
 * 
 * @export
 * @interface PatchUsersRequest
 */
export interface PatchUsersRequest {
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof PatchUsersRequest
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating
     * @type {Array<InstructionUserRequest>}
     * @memberof PatchUsersRequest
     */
    'instructions': Array<InstructionUserRequest>;
}
/**
 * 
 * @export
 * @interface PatchWithComment
 */
export interface PatchWithComment {
    /**
     * 
     * @type {Array<PatchOperation>}
     * @memberof PatchWithComment
     */
    'patch': Array<PatchOperation>;
    /**
     * Optional comment
     * @type {string}
     * @memberof PatchWithComment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface PermissionGrantInput
 */
export interface PermissionGrantInput {
    /**
     * A group of related actions to allow. Specify either <code>actionSet</code> or <code>actions</code>. Use <code>maintainTeam</code> to add team maintainers.
     * @type {string}
     * @memberof PermissionGrantInput
     */
    'actionSet'?: PermissionGrantInputActionSetEnum;
    /**
     * A list of actions to allow. Specify either <code>actionSet</code> or <code>actions</code>. To learn more, read [Role actions](https://docs.launchdarkly.com/home/members/role-actions).
     * @type {Array<string>}
     * @memberof PermissionGrantInput
     */
    'actions'?: Array<string>;
    /**
     * A list of member IDs who receive the permission grant.
     * @type {Array<string>}
     * @memberof PermissionGrantInput
     */
    'memberIDs'?: Array<string>;
}

export const PermissionGrantInputActionSetEnum = {
    MaintainTeam: 'maintainTeam'
} as const;

export type PermissionGrantInputActionSetEnum = typeof PermissionGrantInputActionSetEnum[keyof typeof PermissionGrantInputActionSetEnum];

/**
 * 
 * @export
 * @interface PostApprovalRequestApplyRequest
 */
export interface PostApprovalRequestApplyRequest {
    /**
     * Optional comment about the approval request
     * @type {string}
     * @memberof PostApprovalRequestApplyRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface PostApprovalRequestReviewRequest
 */
export interface PostApprovalRequestReviewRequest {
    /**
     * The type of review for this approval request
     * @type {string}
     * @memberof PostApprovalRequestReviewRequest
     */
    'kind'?: PostApprovalRequestReviewRequestKindEnum;
    /**
     * Optional comment about the approval request
     * @type {string}
     * @memberof PostApprovalRequestReviewRequest
     */
    'comment'?: string;
}

export const PostApprovalRequestReviewRequestKindEnum = {
    Approve: 'approve',
    Comment: 'comment',
    Decline: 'decline'
} as const;

export type PostApprovalRequestReviewRequestKindEnum = typeof PostApprovalRequestReviewRequestKindEnum[keyof typeof PostApprovalRequestReviewRequestKindEnum];

/**
 * 
 * @export
 * @interface PostFlagScheduledChangesInput
 */
export interface PostFlagScheduledChangesInput {
    /**
     * Optional comment describing the scheduled changes
     * @type {string}
     * @memberof PostFlagScheduledChangesInput
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostFlagScheduledChangesInput
     */
    'executionDate': number;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PostFlagScheduledChangesInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface Prerequisite
 */
export interface Prerequisite {
    /**
     * 
     * @type {string}
     * @memberof Prerequisite
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof Prerequisite
     */
    'variation': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Project
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this project
     * @type {string}
     * @memberof Project
     */
    '_id': string;
    /**
     * The key of this project
     * @type {string}
     * @memberof Project
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default
     * @type {boolean}
     * @memberof Project
     */
    'includeInSnippetByDefault': boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof Project
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * A human-friendly name for the project
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * A list of tags for the project
     * @type {Array<string>}
     * @memberof Project
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Environments}
     * @memberof Project
     */
    'environments'?: Environments;
}
/**
 * 
 * @export
 * @interface ProjectListingRep
 */
export interface ProjectListingRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectListingRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this project
     * @type {string}
     * @memberof ProjectListingRep
     */
    '_id': string;
    /**
     * The key of this project
     * @type {string}
     * @memberof ProjectListingRep
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default
     * @type {boolean}
     * @memberof ProjectListingRep
     */
    'includeInSnippetByDefault': boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof ProjectListingRep
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * A human-friendly name for the project
     * @type {string}
     * @memberof ProjectListingRep
     */
    'name': string;
    /**
     * A list of tags for the project
     * @type {Array<string>}
     * @memberof ProjectListingRep
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectPost
 */
export interface ProjectPost {
    /**
     * A human-friendly name for the project.
     * @type {string}
     * @memberof ProjectPost
     */
    'name': string;
    /**
     * A unique key used to reference the project in your code.
     * @type {string}
     * @memberof ProjectPost
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default.
     * @type {boolean}
     * @memberof ProjectPost
     */
    'includeInSnippetByDefault'?: boolean;
    /**
     * 
     * @type {DefaultClientSideAvailabilityPost}
     * @memberof ProjectPost
     */
    'defaultClientSideAvailability'?: DefaultClientSideAvailabilityPost;
    /**
     * Tags for the project
     * @type {Array<string>}
     * @memberof ProjectPost
     */
    'tags'?: Array<string>;
    /**
     * Creates the provided environments for this project. If omitted default environments will be created instead.
     * @type {Array<EnvironmentPost>}
     * @memberof ProjectPost
     */
    'environments'?: Array<EnvironmentPost>;
}
/**
 * 
 * @export
 * @interface ProjectRep
 */
export interface ProjectRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this project
     * @type {string}
     * @memberof ProjectRep
     */
    '_id': string;
    /**
     * The key of this project
     * @type {string}
     * @memberof ProjectRep
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default
     * @type {boolean}
     * @memberof ProjectRep
     */
    'includeInSnippetByDefault': boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof ProjectRep
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * A human-friendly name for the project
     * @type {string}
     * @memberof ProjectRep
     */
    'name': string;
    /**
     * A list of tags for the project
     * @type {Array<string>}
     * @memberof ProjectRep
     */
    'tags': Array<string>;
    /**
     * A list of environments for the project
     * @type {Array<Environment>}
     * @memberof ProjectRep
     */
    'environments': Array<Environment>;
}
/**
 * 
 * @export
 * @interface ProjectSummary
 */
export interface ProjectSummary {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectSummary
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The project key
     * @type {string}
     * @memberof ProjectSummary
     */
    'key'?: string;
    /**
     * The project name
     * @type {string}
     * @memberof ProjectSummary
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Projects
 */
export interface Projects {
    /**
     * A link to this resource.
     * @type {{ [key: string]: Link; }}
     * @memberof Projects
     */
    '_links': { [key: string]: Link; };
    /**
     * List of projects.
     * @type {Array<Project>}
     * @memberof Projects
     */
    'items': Array<Project>;
    /**
     * 
     * @type {number}
     * @memberof Projects
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface PubNubDetailRep
 */
export interface PubNubDetailRep {
    /**
     * 
     * @type {string}
     * @memberof PubNubDetailRep
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof PubNubDetailRep
     */
    'cipherKey'?: string;
}
/**
 * 
 * @export
 * @interface PutBranch
 */
export interface PutBranch {
    /**
     * The branch name
     * @type {string}
     * @memberof PutBranch
     */
    'name': string;
    /**
     * An ID representing the branch HEAD. For example, a commit SHA.
     * @type {string}
     * @memberof PutBranch
     */
    'head': string;
    /**
     * An optional ID used to prevent older data from overwriting newer data. If no sequence ID is included, the newly submitted data will always be saved.
     * @type {number}
     * @memberof PutBranch
     */
    'updateSequenceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PutBranch
     */
    'syncTime': number;
    /**
     * An array of flag references found on the branch
     * @type {Array<ReferenceRep>}
     * @memberof PutBranch
     */
    'references'?: Array<ReferenceRep>;
    /**
     * 
     * @type {number}
     * @memberof PutBranch
     */
    'commitTime'?: number;
}
/**
 * 
 * @export
 * @interface RateLimitedErrorRep
 */
export interface RateLimitedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof RateLimitedErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof RateLimitedErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RecentTriggerBody
 */
export interface RecentTriggerBody {
    /**
     * 
     * @type {number}
     * @memberof RecentTriggerBody
     */
    'timestamp'?: number;
    /**
     * The marshalled JSON request body for the incoming trigger webhook. If this is empty or contains invalid JSON, the timestamp is recorded but this field will be empty.
     * @type {{ [key: string]: any; }}
     * @memberof RecentTriggerBody
     */
    'jsonBody'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReferenceRep
 */
export interface ReferenceRep {
    /**
     * File path of the reference
     * @type {string}
     * @memberof ReferenceRep
     */
    'path': string;
    /**
     * Programming language used in the file
     * @type {string}
     * @memberof ReferenceRep
     */
    'hint'?: string;
    /**
     * 
     * @type {Array<HunkRep>}
     * @memberof ReferenceRep
     */
    'hunks': Array<HunkRep>;
}
/**
 * 
 * @export
 * @interface RelativeDifferenceRep
 */
export interface RelativeDifferenceRep {
    /**
     * The upper bound
     * @type {number}
     * @memberof RelativeDifferenceRep
     */
    'upper'?: number;
    /**
     * The lower bound
     * @type {number}
     * @memberof RelativeDifferenceRep
     */
    'lower'?: number;
    /**
     * The treatment ID
     * @type {string}
     * @memberof RelativeDifferenceRep
     */
    'fromTreatmentId'?: string;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigCollectionRep
 */
export interface RelayAutoConfigCollectionRep {
    /**
     * An array of Relay Proxy configurations
     * @type {Array<RelayAutoConfigRep>}
     * @memberof RelayAutoConfigCollectionRep
     */
    'items': Array<RelayAutoConfigRep>;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigPost
 */
export interface RelayAutoConfigPost {
    /**
     * A human-friendly name for the Relay Proxy configuration
     * @type {string}
     * @memberof RelayAutoConfigPost
     */
    'name': string;
    /**
     * A description of what environments and projects the Relay Proxy should include or exclude. To learn more, read [Writing an inline policy](https://docs.launchdarkly.com/home/relay-proxy/automatic-configuration#writing-an-inline-policy).
     * @type {Array<Statement>}
     * @memberof RelayAutoConfigPost
     */
    'policy': Array<Statement>;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigRep
 */
export interface RelayAutoConfigRep {
    /**
     * 
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    '_id': string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof RelayAutoConfigRep
     */
    '_creator'?: MemberSummary;
    /**
     * 
     * @type {Access}
     * @memberof RelayAutoConfigRep
     */
    '_access'?: Access;
    /**
     * A human-friendly name for the Relay Proxy configuration
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'name': string;
    /**
     * A description of what environments and projects the Relay Proxy should include or exclude
     * @type {Array<Statement>}
     * @memberof RelayAutoConfigRep
     */
    'policy': Array<Statement>;
    /**
     * The Relay Proxy configuration key
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'fullKey': string;
    /**
     * The last few characters of the Relay Proxy configuration key, displayed in the LaunchDarkly UI
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'displayKey': string;
    /**
     * 
     * @type {number}
     * @memberof RelayAutoConfigRep
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof RelayAutoConfigRep
     */
    'lastModified': number;
}
/**
 * 
 * @export
 * @interface RepositoryCollectionRep
 */
export interface RepositoryCollectionRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepositoryCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of repositories
     * @type {Array<RepositoryRep>}
     * @memberof RepositoryCollectionRep
     */
    'items': Array<RepositoryRep>;
}
/**
 * 
 * @export
 * @interface RepositoryPost
 */
export interface RepositoryPost {
    /**
     * The repository name
     * @type {string}
     * @memberof RepositoryPost
     */
    'name': string;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof RepositoryPost
     */
    'sourceLink'?: string;
    /**
     * A template for constructing a valid URL to view the commit
     * @type {string}
     * @memberof RepositoryPost
     */
    'commitUrlTemplate'?: string;
    /**
     * A template for constructing a valid URL to view the hunk
     * @type {string}
     * @memberof RepositoryPost
     */
    'hunkUrlTemplate'?: string;
    /**
     * The type of repository. If not specified, the default value is <code>custom</code>.
     * @type {string}
     * @memberof RepositoryPost
     */
    'type'?: RepositoryPostTypeEnum;
    /**
     * The repository\'s default branch. If not specified, the default value is <code>main</code>.
     * @type {string}
     * @memberof RepositoryPost
     */
    'defaultBranch'?: string;
}

export const RepositoryPostTypeEnum = {
    Bitbucket: 'bitbucket',
    Custom: 'custom',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepositoryPostTypeEnum = typeof RepositoryPostTypeEnum[keyof typeof RepositoryPostTypeEnum];

/**
 * 
 * @export
 * @interface RepositoryRep
 */
export interface RepositoryRep {
    /**
     * The repository name
     * @type {string}
     * @memberof RepositoryRep
     */
    'name': string;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof RepositoryRep
     */
    'sourceLink'?: string;
    /**
     * A template for constructing a valid URL to view the commit
     * @type {string}
     * @memberof RepositoryRep
     */
    'commitUrlTemplate'?: string;
    /**
     * A template for constructing a valid URL to view the hunk
     * @type {string}
     * @memberof RepositoryRep
     */
    'hunkUrlTemplate'?: string;
    /**
     * The type of repository
     * @type {string}
     * @memberof RepositoryRep
     */
    'type': RepositoryRepTypeEnum;
    /**
     * The repository\'s default branch
     * @type {string}
     * @memberof RepositoryRep
     */
    'defaultBranch': string;
    /**
     * Whether or not a repository is enabled for code reference scanning
     * @type {boolean}
     * @memberof RepositoryRep
     */
    'enabled': boolean;
    /**
     * The version of the repository\'s saved information
     * @type {number}
     * @memberof RepositoryRep
     */
    'version': number;
    /**
     * An array of the repository\'s branches that have been scanned for code references
     * @type {Array<BranchRep>}
     * @memberof RepositoryRep
     */
    'branches'?: Array<BranchRep>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RepositoryRep
     */
    '_links': { [key: string]: any; };
    /**
     * 
     * @type {Access}
     * @memberof RepositoryRep
     */
    '_access'?: Access;
}

export const RepositoryRepTypeEnum = {
    Bitbucket: 'bitbucket',
    Custom: 'custom',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepositoryRepTypeEnum = typeof RepositoryRepTypeEnum[keyof typeof RepositoryRepTypeEnum];

/**
 * 
 * @export
 * @interface ResolvedContext
 */
export interface ResolvedContext {
    /**
     * 
     * @type {Array<ResolvedUIBlockElement>}
     * @memberof ResolvedContext
     */
    'elements'?: Array<ResolvedUIBlockElement>;
}
/**
 * 
 * @export
 * @interface ResolvedImage
 */
export interface ResolvedImage {
    /**
     * 
     * @type {boolean}
     * @memberof ResolvedImage
     */
    'isAvatar'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResolvedImage
     */
    'isIcon'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResolvedImage
     */
    'sourceUrl'?: string;
}
/**
 * 
 * @export
 * @interface ResolvedTitle
 */
export interface ResolvedTitle {
    /**
     * 
     * @type {Array<ResolvedUIBlockElement>}
     * @memberof ResolvedTitle
     */
    'elements'?: Array<ResolvedUIBlockElement>;
    /**
     * 
     * @type {boolean}
     * @memberof ResolvedTitle
     */
    'linkToReference'?: boolean;
}
/**
 * 
 * @export
 * @interface ResolvedUIBlockElement
 */
export interface ResolvedUIBlockElement {
    /**
     * 
     * @type {boolean}
     * @memberof ResolvedUIBlockElement
     */
    'isBold'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUIBlockElement
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUIBlockElement
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResolvedUIBlockElement
     */
    'isTimestamp'?: boolean;
}
/**
 * 
 * @export
 * @interface ResolvedUIBlocks
 */
export interface ResolvedUIBlocks {
    /**
     * 
     * @type {ResolvedImage}
     * @memberof ResolvedUIBlocks
     */
    'image'?: ResolvedImage;
    /**
     * 
     * @type {ResolvedContext}
     * @memberof ResolvedUIBlocks
     */
    'context'?: ResolvedContext;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUIBlocks
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUIBlocks
     */
    'name'?: string;
    /**
     * 
     * @type {ResolvedTitle}
     * @memberof ResolvedUIBlocks
     */
    'title'?: ResolvedTitle;
}
/**
 * 
 * @export
 * @interface ResourceAccess
 */
export interface ResourceAccess {
    /**
     * 
     * @type {string}
     * @memberof ResourceAccess
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceAccess
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface ResourceIDResponse
 */
export interface ResourceIDResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'projectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'environmentKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'flagKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface ReviewOutput
 */
export interface ReviewOutput {
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'kind': string;
    /**
     * 
     * @type {number}
     * @memberof ReviewOutput
     */
    'creationDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'memberId'?: string;
}
/**
 * 
 * @export
 * @interface ReviewResponse
 */
export interface ReviewResponse {
    /**
     * The approval request ID
     * @type {string}
     * @memberof ReviewResponse
     */
    '_id': string;
    /**
     * The type of review action to take
     * @type {string}
     * @memberof ReviewResponse
     */
    'kind': ReviewResponseKindEnum;
    /**
     * 
     * @type {number}
     * @memberof ReviewResponse
     */
    'creationDate'?: number;
    /**
     * A comment describing the approval response
     * @type {string}
     * @memberof ReviewResponse
     */
    'comment'?: string;
    /**
     * ID of account member that reviewed request
     * @type {string}
     * @memberof ReviewResponse
     */
    'memberId'?: string;
}

export const ReviewResponseKindEnum = {
    Approve: 'approve',
    Decline: 'decline',
    Comment: 'comment'
} as const;

export type ReviewResponseKindEnum = typeof ReviewResponseKindEnum[keyof typeof ReviewResponseKindEnum];

/**
 * 
 * @export
 * @interface Rollout
 */
export interface Rollout {
    /**
     * 
     * @type {Array<WeightedVariation>}
     * @memberof Rollout
     */
    'variations': Array<WeightedVariation>;
    /**
     * 
     * @type {ExperimentAllocationRep}
     * @memberof Rollout
     */
    'experimentAllocation'?: ExperimentAllocationRep;
    /**
     * 
     * @type {number}
     * @memberof Rollout
     */
    'seed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Rollout
     */
    'bucketBy'?: string;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    '_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    'variation'?: number;
    /**
     * 
     * @type {Rollout}
     * @memberof Rule
     */
    'rollout'?: Rollout;
    /**
     * 
     * @type {Array<Clause>}
     * @memberof Rule
     */
    'clauses': Array<Clause>;
    /**
     * 
     * @type {boolean}
     * @memberof Rule
     */
    'trackEvents': boolean;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'ref'?: string;
}
/**
 * 
 * @export
 * @interface RuleClause
 */
export interface RuleClause {
    /**
     * The attribute the rule applies to, for example, last name or email address
     * @type {string}
     * @memberof RuleClause
     */
    'attribute'?: string;
    /**
     * The operator to apply to the given attribute
     * @type {string}
     * @memberof RuleClause
     */
    'op'?: RuleClauseOpEnum;
    /**
     * Whether the operator should be negated
     * @type {boolean}
     * @memberof RuleClause
     */
    'negate'?: boolean;
}

export const RuleClauseOpEnum = {
    In: 'in',
    EndsWith: 'endsWith',
    StartsWith: 'startsWith',
    Matches: 'matches',
    Contains: 'contains',
    LessThan: 'lessThan',
    LessThanOrEqual: 'lessThanOrEqual',
    GreaterThan: 'greaterThan',
    GreaterThanOrEqual: 'greaterThanOrEqual',
    Before: 'before',
    After: 'after',
    SegmentMatch: 'segmentMatch',
    SemVerEqual: 'semVerEqual',
    SemVerLessThan: 'semVerLessThan',
    SemVerGreaterThan: 'semVerGreaterThan'
} as const;

export type RuleClauseOpEnum = typeof RuleClauseOpEnum[keyof typeof RuleClauseOpEnum];

/**
 * 
 * @export
 * @interface ScheduleConditionInput
 */
export interface ScheduleConditionInput {
    /**
     * 
     * @type {string}
     * @memberof ScheduleConditionInput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleConditionInput
     */
    'executionDate'?: number;
    /**
     * For workflow stages whose scheduled execution is relative, how far in the future the stage should start.
     * @type {number}
     * @memberof ScheduleConditionInput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleConditionInput
     */
    'waitDurationUnit'?: string;
    /**
     * Whether the workflow stage should be executed immediately
     * @type {boolean}
     * @memberof ScheduleConditionInput
     */
    'executeNow'?: boolean;
}
/**
 * 
 * @export
 * @interface ScheduleConditionOutput
 */
export interface ScheduleConditionOutput {
    /**
     * 
     * @type {string}
     * @memberof ScheduleConditionOutput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleConditionOutput
     */
    'executionDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScheduleConditionOutput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleConditionOutput
     */
    'waitDurationUnit'?: string;
}
/**
 * 
 * @export
 * @interface SdkListRep
 */
export interface SdkListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SdkListRep
     */
    '_links': { [key: string]: any; };
    /**
     * The list of SDK names
     * @type {Array<string>}
     * @memberof SdkListRep
     */
    'sdks': Array<string>;
}
/**
 * 
 * @export
 * @interface SdkVersionListRep
 */
export interface SdkVersionListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SdkVersionListRep
     */
    '_links': { [key: string]: any; };
    /**
     * The list of SDK names and versions
     * @type {Array<SdkVersionRep>}
     * @memberof SdkVersionListRep
     */
    'sdkVersions': Array<SdkVersionRep>;
}
/**
 * 
 * @export
 * @interface SdkVersionRep
 */
export interface SdkVersionRep {
    /**
     * The SDK name, or \"Unknown\"
     * @type {string}
     * @memberof SdkVersionRep
     */
    'sdk': string;
    /**
     * The version number, or \"Unknown\"
     * @type {string}
     * @memberof SdkVersionRep
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface SegmentBody
 */
export interface SegmentBody {
    /**
     * A human-friendly name for the segment
     * @type {string}
     * @memberof SegmentBody
     */
    'name': string;
    /**
     * A unique key used to reference the segment
     * @type {string}
     * @memberof SegmentBody
     */
    'key': string;
    /**
     * A description of the segment\'s purpose
     * @type {string}
     * @memberof SegmentBody
     */
    'description'?: string;
    /**
     * Tags for the segment
     * @type {Array<string>}
     * @memberof SegmentBody
     */
    'tags'?: Array<string>;
    /**
     * Whether to create a standard segment (false) or a Big Segment (true). Only use a Big Segment if you need to add more than 15,000 users.
     * @type {boolean}
     * @memberof SegmentBody
     */
    'unbounded'?: boolean;
}
/**
 * 
 * @export
 * @interface SegmentMetadata
 */
export interface SegmentMetadata {
    /**
     * 
     * @type {string}
     * @memberof SegmentMetadata
     */
    'envId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentMetadata
     */
    'segmentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'version'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'includedCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'excludedCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SegmentMetadata
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface SegmentUserList
 */
export interface SegmentUserList {
    /**
     * 
     * @type {Array<string>}
     * @memberof SegmentUserList
     */
    'add'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SegmentUserList
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SegmentUserState
 */
export interface SegmentUserState {
    /**
     * 
     * @type {SegmentUserList}
     * @memberof SegmentUserState
     */
    'included'?: SegmentUserList;
    /**
     * 
     * @type {SegmentUserList}
     * @memberof SegmentUserState
     */
    'excluded'?: SegmentUserList;
}
/**
 * 
 * @export
 * @interface SeriesListRep
 */
export interface SeriesListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SeriesListRep
     */
    '_links': { [key: string]: any; };
    /**
     * Metadata about each series
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SeriesListRep
     */
    'metadata': Array<{ [key: string]: any; }>;
    /**
     * An array of data points with timestamps
     * @type {Array<{ [key: string]: number; }>}
     * @memberof SeriesListRep
     */
    'series': Array<{ [key: string]: number; }>;
}
/**
 * 
 * @export
 * @interface SourceEnv
 */
export interface SourceEnv {
    /**
     * The key of the source environment to clone from
     * @type {string}
     * @memberof SourceEnv
     */
    'key'?: string;
    /**
     * (Optional) The version number of the source environment to clone from. Used for optimistic locking
     * @type {number}
     * @memberof SourceEnv
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface SourceFlag
 */
export interface SourceFlag {
    /**
     * The environment key for the source environment
     * @type {string}
     * @memberof SourceFlag
     */
    'key': string;
    /**
     * The version of the source flag from which to copy
     * @type {number}
     * @memberof SourceFlag
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface StageInput
 */
export interface StageInput {
    /**
     * The stage name
     * @type {string}
     * @memberof StageInput
     */
    'name'?: string;
    /**
     * Whether to execute the conditions in sequence for the given stage
     * @type {boolean}
     * @memberof StageInput
     */
    'executeConditionsInSequence'?: boolean;
    /**
     * An array of conditions for the stage
     * @type {Array<ConditionInput>}
     * @memberof StageInput
     */
    'conditions'?: Array<ConditionInput>;
    /**
     * 
     * @type {ActionInput}
     * @memberof StageInput
     */
    'action'?: ActionInput;
}
/**
 * 
 * @export
 * @interface StageOutput
 */
export interface StageOutput {
    /**
     * The ID of this stage
     * @type {string}
     * @memberof StageOutput
     */
    '_id': string;
    /**
     * The stage name
     * @type {string}
     * @memberof StageOutput
     */
    'name'?: string;
    /**
     * An array of conditions for the stage
     * @type {Array<ConditionOutput>}
     * @memberof StageOutput
     */
    'conditions': Array<ConditionOutput>;
    /**
     * 
     * @type {ActionOutput}
     * @memberof StageOutput
     */
    'action': ActionOutput;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof StageOutput
     */
    '_execution': ExecutionOutput;
}
/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof Statement
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof Statement
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    'notActions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'effect': string;
}
/**
 * 
 * @export
 * @interface StatementPost
 */
export interface StatementPost {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'notActions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StatementPost
     */
    'effect': string;
}
/**
 * 
 * @export
 * @interface StatementPostData
 */
export interface StatementPostData {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof StatementPostData
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPostData
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof StatementPostData
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPostData
     */
    'notActions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StatementPostData
     */
    'effect': string;
}
/**
 * 
 * @export
 * @interface StatisticCollectionRep
 */
export interface StatisticCollectionRep {
    /**
     * A map of flag keys to a list of code reference statistics for each code repository in which the flag key appears
     * @type {{ [key: string]: Array<StatisticRep>; }}
     * @memberof StatisticCollectionRep
     */
    'flags': { [key: string]: Array<StatisticRep>; };
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof StatisticCollectionRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface StatisticRep
 */
export interface StatisticRep {
    /**
     * The repository name
     * @type {string}
     * @memberof StatisticRep
     */
    'name': string;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof StatisticRep
     */
    'sourceLink': string;
    /**
     * The repository\'s default branch
     * @type {string}
     * @memberof StatisticRep
     */
    'defaultBranch': string;
    /**
     * Whether or not a repository is enabled for code reference scanning
     * @type {boolean}
     * @memberof StatisticRep
     */
    'enabled': boolean;
    /**
     * The version of the repository\'s saved information
     * @type {number}
     * @memberof StatisticRep
     */
    'version': number;
    /**
     * The number of code reference hunks in which the flag appears in this repository
     * @type {number}
     * @memberof StatisticRep
     */
    'hunkCount': number;
    /**
     * The number of files in which the flag appears in this repository
     * @type {number}
     * @memberof StatisticRep
     */
    'fileCount': number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof StatisticRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface StatisticsRep
 */
export interface StatisticsRep {
    /**
     * A list of code reference statistics for each code repository
     * @type {Array<StatisticRep>}
     * @memberof StatisticsRep
     */
    'items'?: Array<StatisticRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof StatisticsRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface StatisticsRoot
 */
export interface StatisticsRoot {
    /**
     * The location and content type of all projects that have code references
     * @type {Array<Link>}
     * @memberof StatisticsRoot
     */
    'projects'?: Array<Link>;
    /**
     * 
     * @type {Link}
     * @memberof StatisticsRoot
     */
    'self'?: Link;
}
/**
 * 
 * @export
 * @interface StatusConflictErrorRep
 */
export interface StatusConflictErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof StatusConflictErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof StatusConflictErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SubjectDataRep
 */
export interface SubjectDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof SubjectDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The subject\'s name
     * @type {string}
     * @memberof SubjectDataRep
     */
    'name'?: string;
    /**
     * The subject\'s avatar
     * @type {string}
     * @memberof SubjectDataRep
     */
    'avatarUrl'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionPost
 */
export interface SubscriptionPost {
    /**
     * A human-friendly name for your audit log subscription.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'name': string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof SubscriptionPost
     */
    'statements'?: Array<StatementPost>;
    /**
     * Whether or not you want your subscription to actively send events.
     * @type {boolean}
     * @memberof SubscriptionPost
     */
    'on'?: boolean;
    /**
     * An array of tags for this subscription.
     * @type {Array<string>}
     * @memberof SubscriptionPost
     */
    'tags'?: Array<string>;
    /**
     * The unique set of fields required to configure an audit log subscription integration of this type. Refer to the <code>formVariables</code> field in the corresponding <code>manifest.json</code> at https://github.com/launchdarkly/integration-framework/tree/main/integrations for a full list of fields for the integration you wish to configure.
     * @type {{ [key: string]: any; }}
     * @memberof SubscriptionPost
     */
    'config': { [key: string]: any; };
    /**
     * Slack webhook receiver URL. Only necessary for legacy Slack webhook integrations.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'url'?: string;
    /**
     * Datadog API key. Only necessary for legacy Datadog webhook integrations.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface TagCollection
 */
export interface TagCollection {
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof TagCollection
     */
    'items': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TagCollection
     */
    '_links': { [key: string]: Link; };
    /**
     * The total number of tags
     * @type {number}
     * @memberof TagCollection
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface Target
 */
export interface Target {
    /**
     * 
     * @type {Array<string>}
     * @memberof Target
     */
    'values': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Target
     */
    'variation': number;
}
/**
 * 
 * @export
 * @interface TargetResourceRep
 */
export interface TargetResourceRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TargetResourceRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The name of the resource
     * @type {string}
     * @memberof TargetResourceRep
     */
    'name'?: string;
    /**
     * The resource specifier
     * @type {Array<string>}
     * @memberof TargetResourceRep
     */
    'resources'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * A description of the team
     * @type {string}
     * @memberof Team
     */
    'description'?: string;
    /**
     * The team key
     * @type {string}
     * @memberof Team
     */
    'key'?: string;
    /**
     * A human-friendly name for the team
     * @type {string}
     * @memberof Team
     */
    'name'?: string;
    /**
     * 
     * @type {Access}
     * @memberof Team
     */
    '_access'?: Access;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    '_creationDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Team
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    '_lastModified'?: number;
    /**
     * The team version
     * @type {number}
     * @memberof Team
     */
    '_version'?: number;
    /**
     * Whether the team has been synced with an external identity provider (IdP). Team sync is available to customers on an Enterprise plan.
     * @type {boolean}
     * @memberof Team
     */
    '_idpSynced'?: boolean;
    /**
     * 
     * @type {TeamCustomRoles}
     * @memberof Team
     */
    'roles'?: TeamCustomRoles;
    /**
     * 
     * @type {TeamMembers}
     * @memberof Team
     */
    'members'?: TeamMembers;
    /**
     * 
     * @type {TeamProjects}
     * @memberof Team
     */
    'projects'?: TeamProjects;
    /**
     * 
     * @type {TeamMaintainers}
     * @memberof Team
     */
    'maintainers'?: TeamMaintainers;
}
/**
 * 
 * @export
 * @interface TeamCustomRole
 */
export interface TeamCustomRole {
    /**
     * The key of the custom role
     * @type {string}
     * @memberof TeamCustomRole
     */
    'key'?: string;
    /**
     * The name of the custom role
     * @type {string}
     * @memberof TeamCustomRole
     */
    'name'?: string;
    /**
     * 
     * @type {TeamProjects}
     * @memberof TeamCustomRole
     */
    'projects'?: TeamProjects;
    /**
     * 
     * @type {number}
     * @memberof TeamCustomRole
     */
    'appliedOn'?: number;
}
/**
 * 
 * @export
 * @interface TeamCustomRoles
 */
export interface TeamCustomRoles {
    /**
     * The number of custom roles assigned to this team
     * @type {number}
     * @memberof TeamCustomRoles
     */
    'totalCount'?: number;
    /**
     * An array of the custom roles that have been assigned to this team
     * @type {Array<TeamCustomRole>}
     * @memberof TeamCustomRoles
     */
    'items'?: Array<TeamCustomRole>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TeamCustomRoles
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TeamImportsRep
 */
export interface TeamImportsRep {
    /**
     * An array of details about the members requested to be added to this team
     * @type {Array<MemberImportItem>}
     * @memberof TeamImportsRep
     */
    'items'?: Array<MemberImportItem>;
}
/**
 * 
 * @export
 * @interface TeamMaintainers
 */
export interface TeamMaintainers {
    /**
     * The number of maintainers of the team
     * @type {number}
     * @memberof TeamMaintainers
     */
    'totalCount'?: number;
    /**
     * Details on the members that have been assigned as maintainers of the team
     * @type {Array<MemberSummary>}
     * @memberof TeamMaintainers
     */
    'items'?: Array<MemberSummary>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TeamMaintainers
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TeamMembers
 */
export interface TeamMembers {
    /**
     * The total count of members that belong to the team
     * @type {number}
     * @memberof TeamMembers
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TeamPatchInput
 */
export interface TeamPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof TeamPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TeamPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface TeamPostInput
 */
export interface TeamPostInput {
    /**
     * List of custom role keys the team will access
     * @type {Array<string>}
     * @memberof TeamPostInput
     */
    'customRoleKeys'?: Array<string>;
    /**
     * A description of the team
     * @type {string}
     * @memberof TeamPostInput
     */
    'description'?: string;
    /**
     * The team key
     * @type {string}
     * @memberof TeamPostInput
     */
    'key': string;
    /**
     * A list of member IDs who belong to the team
     * @type {Array<string>}
     * @memberof TeamPostInput
     */
    'memberIDs'?: Array<string>;
    /**
     * A human-friendly name for the team
     * @type {string}
     * @memberof TeamPostInput
     */
    'name': string;
    /**
     * A list of permission grants. Permission grants allow access to a specific action, without having to create or update a custom role.
     * @type {Array<PermissionGrantInput>}
     * @memberof TeamPostInput
     */
    'permissionGrants'?: Array<PermissionGrantInput>;
}
/**
 * 
 * @export
 * @interface TeamProjects
 */
export interface TeamProjects {
    /**
     * 
     * @type {number}
     * @memberof TeamProjects
     */
    'totalCount'?: number;
    /**
     * Details on each project where team members have write privileges on at least one custom role action
     * @type {Array<ProjectSummary>}
     * @memberof TeamProjects
     */
    'items'?: Array<ProjectSummary>;
}
/**
 * 
 * @export
 * @interface TeamRepExpandableProperties
 */
export interface TeamRepExpandableProperties {
    /**
     * 
     * @type {TeamCustomRoles}
     * @memberof TeamRepExpandableProperties
     */
    'roles'?: TeamCustomRoles;
    /**
     * 
     * @type {TeamMembers}
     * @memberof TeamRepExpandableProperties
     */
    'members'?: TeamMembers;
    /**
     * 
     * @type {TeamProjects}
     * @memberof TeamRepExpandableProperties
     */
    'projects'?: TeamProjects;
    /**
     * 
     * @type {TeamMaintainers}
     * @memberof TeamRepExpandableProperties
     */
    'maintainers'?: TeamMaintainers;
}
/**
 * 
 * @export
 * @interface Teams
 */
export interface Teams {
    /**
     * An array of teams
     * @type {Array<Team>}
     * @memberof Teams
     */
    'items'?: Array<Team>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Teams
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of teams
     * @type {number}
     * @memberof Teams
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TeamsPatchInput
 */
export interface TeamsPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof TeamsPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TeamsPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface TimestampRep
 */
export interface TimestampRep {
    /**
     * 
     * @type {number}
     * @memberof TimestampRep
     */
    'milliseconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimestampRep
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimestampRep
     */
    'rfc3339'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampRep
     */
    'simple'?: string;
}
/**
 * 
 * @export
 * @interface TitleRep
 */
export interface TitleRep {
    /**
     * 
     * @type {SubjectDataRep}
     * @memberof TitleRep
     */
    'subject'?: SubjectDataRep;
    /**
     * 
     * @type {MemberDataRep}
     * @memberof TitleRep
     */
    'member'?: MemberDataRep;
    /**
     * 
     * @type {TokenDataRep}
     * @memberof TitleRep
     */
    'token'?: TokenDataRep;
    /**
     * 
     * @type {AuthorizedAppDataRep}
     * @memberof TitleRep
     */
    'app'?: AuthorizedAppDataRep;
    /**
     * The action and resource recorded in this audit log entry
     * @type {string}
     * @memberof TitleRep
     */
    'titleVerb'?: string;
    /**
     * A description of what occurred, in the format <code>member</code> <code>titleVerb</code> <code>target</code>
     * @type {string}
     * @memberof TitleRep
     */
    'title'?: string;
    /**
     * 
     * @type {TargetResourceRep}
     * @memberof TitleRep
     */
    'target'?: TargetResourceRep;
    /**
     * 
     * @type {ParentResourceRep}
     * @memberof TitleRep
     */
    'parent'?: ParentResourceRep;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'memberId': string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof Token
     */
    '_member'?: MemberSummary;
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     * A description for the access token
     * @type {string}
     * @memberof Token
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lastModified': number;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof Token
     */
    'customRoleIds'?: Array<string>;
    /**
     * An array of policy statements, with three attributes: effect, resources, actions. May be used in place of a built-in or custom role.
     * @type {Array<Statement>}
     * @memberof Token
     */
    'inlineRole'?: Array<Statement>;
    /**
     * Built-in role for the token
     * @type {string}
     * @memberof Token
     */
    'role'?: string;
    /**
     * Last four characters of the token value
     * @type {string}
     * @memberof Token
     */
    'token'?: string;
    /**
     * Whether this is a service token or a personal token
     * @type {boolean}
     * @memberof Token
     */
    'serviceToken'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Token
     */
    '_links': { [key: string]: Link; };
    /**
     * The default API version for this token
     * @type {number}
     * @memberof Token
     */
    'defaultApiVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lastUsed'?: number;
}
/**
 * 
 * @export
 * @interface TokenDataRep
 */
export interface TokenDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TokenDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof TokenDataRep
     */
    '_id'?: string;
    /**
     * The name of the token
     * @type {string}
     * @memberof TokenDataRep
     */
    'name'?: string;
    /**
     * The last few characters of the token
     * @type {string}
     * @memberof TokenDataRep
     */
    'ending'?: string;
    /**
     * Whether this is a service token
     * @type {boolean}
     * @memberof TokenDataRep
     */
    'serviceToken'?: boolean;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * An array of access tokens
     * @type {Array<Token>}
     * @memberof Tokens
     */
    'items'?: Array<Token>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof Tokens
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TreatmentInput
 */
export interface TreatmentInput {
    /**
     * The treatment name
     * @type {string}
     * @memberof TreatmentInput
     */
    'name': string;
    /**
     * Whether this treatment is the baseline to compare other treatments against
     * @type {boolean}
     * @memberof TreatmentInput
     */
    'baseline': boolean;
    /**
     * The percentage of traffic allocated to this treatment during the iteration
     * @type {string}
     * @memberof TreatmentInput
     */
    'allocationPercent': string;
    /**
     * Details on the flag and variation to use for this treatment
     * @type {Array<TreatmentParameterInput>}
     * @memberof TreatmentInput
     */
    'parameters': Array<TreatmentParameterInput>;
}
/**
 * 
 * @export
 * @interface TreatmentParameterInput
 */
export interface TreatmentParameterInput {
    /**
     * The flag key
     * @type {string}
     * @memberof TreatmentParameterInput
     */
    'flagKey': string;
    /**
     * The ID of the flag variation
     * @type {string}
     * @memberof TreatmentParameterInput
     */
    'variationId': string;
}
/**
 * 
 * @export
 * @interface TreatmentRep
 */
export interface TreatmentRep {
    /**
     * The treatment ID. This is the variation ID from the flag.
     * @type {string}
     * @memberof TreatmentRep
     */
    '_id'?: string;
    /**
     * The treatment name. This is the variation name from the flag.
     * @type {string}
     * @memberof TreatmentRep
     */
    'name': string;
    /**
     * The percentage of traffic allocated to this treatment during the iteration
     * @type {string}
     * @memberof TreatmentRep
     */
    'allocationPercent': string;
    /**
     * Whether this treatment is the baseline to compare other treatments against
     * @type {boolean}
     * @memberof TreatmentRep
     */
    'baseline'?: boolean;
    /**
     * Details on the flag and variation used for this treatment
     * @type {Array<ParameterRep>}
     * @memberof TreatmentRep
     */
    'parameters'?: Array<ParameterRep>;
}
/**
 * 
 * @export
 * @interface TreatmentResultRep
 */
export interface TreatmentResultRep {
    /**
     * The ID of the treatment
     * @type {string}
     * @memberof TreatmentResultRep
     */
    'treatmentId'?: string;
    /**
     * The name of the treatment
     * @type {string}
     * @memberof TreatmentResultRep
     */
    'treatmentName'?: string;
    /**
     * The average value of the variation in this sample. It doesn’t capture the uncertainty in the measurement, so it should not be the only measurement you use to make decisions.
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'mean'?: number;
    /**
     * 
     * @type {CredibleIntervalRep}
     * @memberof TreatmentResultRep
     */
    'credibleInterval'?: CredibleIntervalRep;
    /**
     * The likelihood that this variation has the biggest effect on the primary metric. Of all the variations in the experiment, the one with highest probability is likely the best option to choose.
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'pBest'?: number;
    /**
     * A list of the ranges of the metric that you should have 90% confidence in, for each treatment ID. For example, if the range of the relative differences is [-1%, 4%], you can have 90% confidence that the population difference is a number between 1% lower and 4% higher than the control.
     * @type {Array<RelativeDifferenceRep>}
     * @memberof TreatmentResultRep
     */
    'relativeDifferences'?: Array<RelativeDifferenceRep>;
    /**
     * The number of experiment users for this variation
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'units'?: number;
}
/**
 * 
 * @export
 * @interface TriggerPost
 */
export interface TriggerPost {
    /**
     * Optional comment describing the trigger
     * @type {string}
     * @memberof TriggerPost
     */
    'comment'?: string;
    /**
     * The action to perform when triggering. This should be an array with a single object that looks like <code>{\"kind\": \"flag_action\"}</code>. Supported flag actions are <code>turnFlagOn</code> and <code>turnFlagOff</code>.
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TriggerPost
     */
    'instructions'?: Array<{ [key: string]: any; }>;
    /**
     * The unique identifier of the integration for your trigger. Use <code>generic-trigger</code> for integrations not explicitly supported.
     * @type {string}
     * @memberof TriggerPost
     */
    'integrationKey': string;
}
/**
 * 
 * @export
 * @interface TriggerWorkflowCollectionRep
 */
export interface TriggerWorkflowCollectionRep {
    /**
     * An array of flag triggers
     * @type {Array<TriggerWorkflowRep>}
     * @memberof TriggerWorkflowCollectionRep
     */
    'items'?: Array<TriggerWorkflowRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TriggerWorkflowCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TriggerWorkflowRep
 */
export interface TriggerWorkflowRep {
    /**
     * 
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_id'?: string;
    /**
     * The flag trigger version
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_version'?: number;
    /**
     * 
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_creationDate'?: number;
    /**
     * The ID of the flag trigger maintainer
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof TriggerWorkflowRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Whether the flag trigger is currently enabled
     * @type {boolean}
     * @memberof TriggerWorkflowRep
     */
    'enabled'?: boolean;
    /**
     * The unique identifier of the integration for your trigger
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_integrationKey'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TriggerWorkflowRep
     */
    'instructions'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_lastTriggeredAt'?: number;
    /**
     * Details on recent flag trigger requests.
     * @type {Array<RecentTriggerBody>}
     * @memberof TriggerWorkflowRep
     */
    '_recentTriggerBodies'?: Array<RecentTriggerBody>;
    /**
     * Number of times the trigger has been executed
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_triggerCount'?: number;
    /**
     * The unguessable URL for this flag trigger
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    'triggerURL'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TriggerWorkflowRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface UnauthorizedErrorRep
 */
export interface UnauthorizedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof UnauthorizedErrorRep
     */
    'code'?: string;
    /**
     * Description of the error
     * @type {string}
     * @memberof UnauthorizedErrorRep
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpsertFlagDefaultsPayload
 */
export interface UpsertFlagDefaultsPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpsertFlagDefaultsPayload
     */
    'tags': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertFlagDefaultsPayload
     */
    'temporary': boolean;
    /**
     * 
     * @type {DefaultClientSideAvailability}
     * @memberof UpsertFlagDefaultsPayload
     */
    'defaultClientSideAvailability': DefaultClientSideAvailability;
    /**
     * 
     * @type {BooleanFlagDefaults}
     * @memberof UpsertFlagDefaultsPayload
     */
    'booleanDefaults': BooleanFlagDefaults;
}
/**
 * 
 * @export
 * @interface UpsertPayloadRep
 */
export interface UpsertPayloadRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof UpsertPayloadRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<string>}
     * @memberof UpsertPayloadRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertPayloadRep
     */
    'temporary': boolean;
    /**
     * 
     * @type {DefaultClientSideAvailability}
     * @memberof UpsertPayloadRep
     */
    'defaultClientSideAvailability': DefaultClientSideAvailability;
    /**
     * 
     * @type {BooleanFlagDefaults}
     * @memberof UpsertPayloadRep
     */
    'booleanDefaults': BooleanFlagDefaults;
}
/**
 * 
 * @export
 * @interface UrlPost
 */
export interface UrlPost {
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'kind'?: UrlPostKindEnum;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'substring'?: string;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'pattern'?: string;
}

export const UrlPostKindEnum = {
    Exact: 'exact',
    Canonical: 'canonical',
    Substring: 'substring',
    Regex: 'regex'
} as const;

export type UrlPostKindEnum = typeof UrlPostKindEnum[keyof typeof UrlPostKindEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user key. This is the only mandatory user attribute.
     * @type {string}
     * @memberof User
     */
    'key'?: string;
    /**
     * If provided, used with the user key to generate a variation in percentage rollouts
     * @type {string}
     * @memberof User
     */
    'secondary'?: string;
    /**
     * The user\'s IP address
     * @type {string}
     * @memberof User
     */
    'ip'?: string;
    /**
     * The user\'s country
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * The user\'s email
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * The user\'s first name
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * The user\'s last name
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * An absolute URL to an avatar image. The avatar appears on the Users dashboard in the LaunchDarkly UI.
     * @type {string}
     * @memberof User
     */
    'avatar'?: string;
    /**
     * The user\'s full name
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * Whether the user is anonymous. If true, this user does not appear on the Users dashboard in the LaunchDarkly UI.
     * @type {boolean}
     * @memberof User
     */
    'anonymous'?: boolean;
    /**
     * Any other custom attributes for this user. Custom attributes contain any other user data that you would like to use to conditionally target your users.
     * @type {{ [key: string]: any; }}
     * @memberof User
     */
    'custom'?: { [key: string]: any; };
    /**
     * A list of attribute names that are marked as private. You can use these attributes in targeting rules and segments. If you are using a server-side SDK, the SDK will not send the private attribute back to LaunchDarkly. If you are using a client-side SDK, the SDK will send the private attribute back to LaunchDarkly for evaluation. However, the SDK won\'t send the attribute to LaunchDarkly in events data, LaunchDarkly won\'t store the private attribute, and the private attribute will not appear on the Users dashboard.
     * @type {Array<string>}
     * @memberof User
     */
    'privateAttrs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserAttributeNamesRep
 */
export interface UserAttributeNamesRep {
    /**
     * private attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'private'?: Array<string>;
    /**
     * custom attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'custom'?: Array<string>;
    /**
     * standard attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'standard'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserFlagSetting
 */
export interface UserFlagSetting {
    /**
     * The location and content type of related resources.
     * @type {{ [key: string]: Link; }}
     * @memberof UserFlagSetting
     */
    '_links': { [key: string]: Link; };
    /**
     * The value of the flag variation that the user receives. If there is no defined default rule, this is null.
     * @type {any}
     * @memberof UserFlagSetting
     */
    '_value': any;
    /**
     * Whether the user is explicitly targeted to receive a particular variation. The setting is false if you have turned off a feature flag for a user. It is null if you haven\'t assigned that user to a specific variation.
     * @type {any}
     * @memberof UserFlagSetting
     */
    'setting': any;
    /**
     * 
     * @type {EvaluationReason}
     * @memberof UserFlagSetting
     */
    'reason'?: EvaluationReason;
}
/**
 * 
 * @export
 * @interface UserFlagSettings
 */
export interface UserFlagSettings {
    /**
     * An array of flag settings for the user
     * @type {{ [key: string]: UserFlagSetting; }}
     * @memberof UserFlagSettings
     */
    'items': { [key: string]: UserFlagSetting; };
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserFlagSettings
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface UserRecord
 */
export interface UserRecord {
    /**
     * Timestamp of the last time this user was seen
     * @type {string}
     * @memberof UserRecord
     */
    'lastPing'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    'environmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    'ownerId'?: string;
    /**
     * 
     * @type {User}
     * @memberof UserRecord
     */
    'user'?: User;
    /**
     * If this record is returned as part of a list, the value used to sort the list. This is only included when the <code>sort</code> query parameter is specified. It is a time, in Unix milliseconds, if the sort is by <code>lastSeen</code>. It is a user key if the sort is by <code>userKey</code>.
     * @type {any}
     * @memberof UserRecord
     */
    'sortValue'?: any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserRecord
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof UserRecord
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface UserRecordRep
 */
export interface UserRecordRep {
    /**
     * Timestamp of the last time this user was seen
     * @type {string}
     * @memberof UserRecordRep
     */
    'lastPing'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecordRep
     */
    'environmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecordRep
     */
    'ownerId'?: string;
    /**
     * 
     * @type {User}
     * @memberof UserRecordRep
     */
    'user'?: User;
    /**
     * If this record is returned as part of a list, the value used to sort the list. This is only included when the <code>sort</code> query parameter is specified. It is a time, in Unix milliseconds, if the sort is by <code>lastSeen</code>. It is a user key if the sort is by <code>userKey</code>.
     * @type {any}
     * @memberof UserRecordRep
     */
    'sortValue'?: any;
}
/**
 * 
 * @export
 * @interface UserSegment
 */
export interface UserSegment {
    /**
     * A human-friendly name for the segment.
     * @type {string}
     * @memberof UserSegment
     */
    'name': string;
    /**
     * A description of the segment\'s purpose. Defaults to <code>null</code> and is omitted in the response if not provided.
     * @type {string}
     * @memberof UserSegment
     */
    'description'?: string;
    /**
     * Tags for the segment. Defaults to an empty array.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    'creationDate': number;
    /**
     * A unique key used to reference the segment
     * @type {string}
     * @memberof UserSegment
     */
    'key': string;
    /**
     * An array of user keys for included users. Included users are always segment members, regardless of segment rules. For Big Segments this array is either empty or omitted.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'included'?: Array<string>;
    /**
     * An array of user keys for excluded users. Segment rules bypass excluded users, so they will never be included based on rules. Excluded users may still be included explicitly. This value is omitted for Big Segments.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'excluded'?: Array<string>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserSegment
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of the targeting rules for this segment.
     * @type {Array<UserSegmentRule>}
     * @memberof UserSegment
     */
    'rules': Array<UserSegmentRule>;
    /**
     * Version of the segment
     * @type {number}
     * @memberof UserSegment
     */
    'version': number;
    /**
     * Whether the segment has been deleted
     * @type {boolean}
     * @memberof UserSegment
     */
    'deleted': boolean;
    /**
     * 
     * @type {Access}
     * @memberof UserSegment
     */
    '_access'?: Access;
    /**
     * 
     * @type {Array<FlagListingRep>}
     * @memberof UserSegment
     */
    '_flags'?: Array<FlagListingRep>;
    /**
     * Whether this is a standard segment (<code>false</code>) or a Big Segment (<code>true</code>). If omitted, the segment is a standard segment.
     * @type {boolean}
     * @memberof UserSegment
     */
    'unbounded'?: boolean;
    /**
     * For Big Segments, how many times this segment has been created
     * @type {number}
     * @memberof UserSegment
     */
    'generation': number;
    /**
     * 
     * @type {SegmentMetadata}
     * @memberof UserSegment
     */
    '_unboundedMetadata'?: SegmentMetadata;
    /**
     * The external data store backing this segment. Only applies to Big Segments.
     * @type {string}
     * @memberof UserSegment
     */
    '_external'?: string;
    /**
     * The URL for the external data store backing this segment. Only applies to Big Segments.
     * @type {string}
     * @memberof UserSegment
     */
    '_externalLink'?: string;
    /**
     * Whether an import is currently in progress for the specified segment. Only applies to Big Segments.
     * @type {boolean}
     * @memberof UserSegment
     */
    '_importInProgress'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSegmentRule
 */
export interface UserSegmentRule {
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    '_id'?: string;
    /**
     * 
     * @type {Array<Clause>}
     * @memberof UserSegmentRule
     */
    'clauses': Array<Clause>;
    /**
     * 
     * @type {number}
     * @memberof UserSegmentRule
     */
    'weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    'bucketBy'?: string;
}
/**
 * 
 * @export
 * @interface UserSegments
 */
export interface UserSegments {
    /**
     * An array of segments
     * @type {Array<UserSegment>}
     * @memberof UserSegments
     */
    'items': Array<UserSegment>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserSegments
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Users
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total number of users in the environment
     * @type {number}
     * @memberof Users
     */
    'totalCount': number;
    /**
     * Details on the users
     * @type {Array<UserRecord>}
     * @memberof Users
     */
    'items': Array<UserRecord>;
}
/**
 * 
 * @export
 * @interface UsersRep
 */
export interface UsersRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UsersRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total number of users in the environment
     * @type {number}
     * @memberof UsersRep
     */
    'totalCount': number;
    /**
     * Details on the users
     * @type {Array<UserRecord>}
     * @memberof UsersRep
     */
    'items': Array<UserRecord>;
}
/**
 * 
 * @export
 * @interface ValuePut
 */
export interface ValuePut {
    /**
     * The variation value to set for the user. Must match the flag\'s variation type.
     * @type {any}
     * @memberof ValuePut
     */
    'setting'?: any;
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof ValuePut
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface Variate
 */
export interface Variate {
    /**
     * 
     * @type {string}
     * @memberof Variate
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof Variate
     */
    'value': any;
    /**
     * 
     * @type {string}
     * @memberof Variate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Variate
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Variation
 */
export interface Variation {
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    '_id'?: string;
    /**
     * The value of the variation. For boolean flags, this must be <code>true</code> or <code>false</code>. For multivariate flags, this may be a string, number, or JSON object.
     * @type {any}
     * @memberof Variation
     */
    'value': any;
    /**
     * Description of the variation. Defaults to an empty string, but is omitted from the response if not set.
     * @type {string}
     * @memberof Variation
     */
    'description'?: string;
    /**
     * A human-friendly name for the variation. Defaults to an empty string, but is omitted from the response if not set.
     * @type {string}
     * @memberof Variation
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface VariationOrRolloutRep
 */
export interface VariationOrRolloutRep {
    /**
     * 
     * @type {number}
     * @memberof VariationOrRolloutRep
     */
    'variation'?: number;
    /**
     * 
     * @type {Rollout}
     * @memberof VariationOrRolloutRep
     */
    'rollout'?: Rollout;
}
/**
 * 
 * @export
 * @interface VariationSummary
 */
export interface VariationSummary {
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'rules': number;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'nullRules': number;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'targets': number;
    /**
     * 
     * @type {boolean}
     * @memberof VariationSummary
     */
    'isFallthrough'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariationSummary
     */
    'isOff'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'rollout'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariationSummary
     */
    'bucketBy'?: string;
}
/**
 * 
 * @export
 * @interface VersionsRep
 */
export interface VersionsRep {
    /**
     * A list of all valid API versions. To learn more about our versioning, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).
     * @type {Array<number>}
     * @memberof VersionsRep
     */
    'validVersions': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof VersionsRep
     */
    'latestVersion': number;
    /**
     * 
     * @type {number}
     * @memberof VersionsRep
     */
    'currentVersion': number;
    /**
     * Whether the version of the API currently is use is a beta version. This is always <code>true</code> if you add the <code>LD-API-Version: beta</code> header to your request.
     * @type {boolean}
     * @memberof VersionsRep
     */
    'beta'?: boolean;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Webhook
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this webhook
     * @type {string}
     * @memberof Webhook
     */
    '_id': string;
    /**
     * A human-readable name for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'name'?: string;
    /**
     * The URL to which LaunchDarkly sends an HTTP POST payload for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * The secret for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'secret'?: string;
    /**
     * Represents a Custom role policy, defining a resource kinds filter the webhook responds to.
     * @type {Array<Statement>}
     * @memberof Webhook
     */
    'statements'?: Array<Statement>;
    /**
     * Whether or not this webhook is enabled
     * @type {boolean}
     * @memberof Webhook
     */
    'on': boolean;
    /**
     * List of tags for this webhook
     * @type {Array<string>}
     * @memberof Webhook
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Access}
     * @memberof Webhook
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface WebhookPost
 */
export interface WebhookPost {
    /**
     * A human-readable name for your webhook
     * @type {string}
     * @memberof WebhookPost
     */
    'name'?: string;
    /**
     * The URL of the remote webhook
     * @type {string}
     * @memberof WebhookPost
     */
    'url': string;
    /**
     * If sign is true, and the secret attribute is omitted, LaunchDarkly automatically generates a secret for you.
     * @type {string}
     * @memberof WebhookPost
     */
    'secret'?: string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof WebhookPost
     */
    'statements'?: Array<StatementPost>;
    /**
     * If sign is false, the webhook does not include a signature header, and the secret can be omitted.
     * @type {boolean}
     * @memberof WebhookPost
     */
    'sign': boolean;
    /**
     * Whether or not this webhook is enabled.
     * @type {boolean}
     * @memberof WebhookPost
     */
    'on': boolean;
    /**
     * List of tags for this webhook
     * @type {Array<string>}
     * @memberof WebhookPost
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhooks
 */
export interface Webhooks {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Webhooks
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of webhooks
     * @type {Array<Webhook>}
     * @memberof Webhooks
     */
    'items': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WeightedVariation
 */
export interface WeightedVariation {
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    'variation': number;
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    'weight': number;
    /**
     * 
     * @type {boolean}
     * @memberof WeightedVariation
     */
    '_untracked'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateMetadata
 */
export interface WorkflowTemplateMetadata {
    /**
     * 
     * @type {Array<WorkflowTemplateParameter>}
     * @memberof WorkflowTemplateMetadata
     */
    'parameters'?: Array<WorkflowTemplateParameter>;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateOutput
 */
export interface WorkflowTemplateOutput {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_key': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowTemplateOutput
     */
    '_creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_maintainerId': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof WorkflowTemplateOutput
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    'description'?: string;
    /**
     * 
     * @type {Array<StageOutput>}
     * @memberof WorkflowTemplateOutput
     */
    'stages'?: Array<StageOutput>;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateParameter
 */
export interface WorkflowTemplateParameter {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateParameter
     */
    '_id'?: string;
    /**
     * The path of the property to parameterize, relative to its parent condition or instruction
     * @type {string}
     * @memberof WorkflowTemplateParameter
     */
    'path'?: string;
    /**
     * 
     * @type {ParameterDefault}
     * @memberof WorkflowTemplateParameter
     */
    'default'?: ParameterDefault;
    /**
     * Whether the default value is valid for the target flag and environment
     * @type {boolean}
     * @memberof WorkflowTemplateParameter
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateParameterInput
 */
export interface WorkflowTemplateParameterInput {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateParameterInput
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateParameterInput
     */
    'path'?: string;
    /**
     * 
     * @type {ParameterDefaultInput}
     * @memberof WorkflowTemplateParameterInput
     */
    'default'?: ParameterDefaultInput;
}
/**
 * 
 * @export
 * @interface WorkflowTemplatesListingOutputRep
 */
export interface WorkflowTemplatesListingOutputRep {
    /**
     * 
     * @type {Array<WorkflowTemplateOutput>}
     * @memberof WorkflowTemplatesListingOutputRep
     */
    'items': Array<WorkflowTemplateOutput>;
}

/**
 * AccessTokensApi - axios parameter creator
 * @export
 */
export const AccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (showAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (showAll !== undefined) {
                localVarQueryParameter['showAll'] = showAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an access token\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the access token.
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchToken', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchToken', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken: async (accessTokenPost: AccessTokenPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenPost' is not null or undefined
            assertParamExists('postToken', 'accessTokenPost', accessTokenPost)
            const localVarPath = `/api/v2/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken: async (id: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessTokensApi - functional programming interface
 * @export
 */
export const AccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(showAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(showAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an access token\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the access token.
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchToken(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchToken(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postToken(accessTokenPost: AccessTokenPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postToken(accessTokenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetToken(id: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetToken(id, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessTokensApi - factory interface
 * @export
 */
export const AccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessTokensApiFp(configuration)
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(id: string, options?: any): AxiosPromise<Token> {
            return localVarFp.getToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(showAll?: boolean, options?: any): AxiosPromise<Tokens> {
            return localVarFp.getTokens(showAll, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an access token\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the access token.
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Token> {
            return localVarFp.patchToken(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken(accessTokenPost: AccessTokenPost, options?: any): AxiosPromise<Token> {
            return localVarFp.postToken(accessTokenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken(id: string, expiry?: number, options?: any): AxiosPromise<Token> {
            return localVarFp.resetToken(id, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessTokensApi - object-oriented interface
 * @export
 * @class AccessTokensApi
 * @extends {BaseAPI}
 */
export class AccessTokensApi extends BaseAPI {
    /**
     * Delete an access token by ID.
     * @summary Delete access token
     * @param {string} id The ID of the access token to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public deleteToken(id: string, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).deleteToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single access token by ID.
     * @summary Get access token
     * @param {string} id The ID of the access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getToken(id: string, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).getToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all access tokens.
     * @summary List access tokens
     * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getTokens(showAll?: boolean, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).getTokens(showAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an access token\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the access token.
     * @summary Patch access token
     * @param {string} id The ID of the access token to update
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public patchToken(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).patchToken(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new access token.
     * @summary Create access token
     * @param {AccessTokenPost} accessTokenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public postToken(accessTokenPost: AccessTokenPost, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).postToken(accessTokenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an access token\'s secret key with an optional expiry time for the old key.
     * @summary Reset access token
     * @param {string} id The ID of the access token to update
     * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public resetToken(id: string, expiry?: number, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).resetToken(id, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountMembersApi - axios parameter creator
 * @export
 */
export const AccountMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMember', 'id', id)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMember', 'id', id)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource.    - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (limit?: number, offset?: number, filter?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a single account member. The request should be a valid JSON Patch document describing the changes to be made to the member.  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchMember', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchMember', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMemberTeams: async (id: string, memberTeamsPostInput: MemberTeamsPostInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postMemberTeams', 'id', id)
            // verify required parameter 'memberTeamsPostInput' is not null or undefined
            assertParamExists('postMemberTeams', 'memberTeamsPostInput', memberTeamsPostInput)
            const localVarPath = `/api/v2/members/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberTeamsPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to bulk invite members is available to customers on an Enterprise plan. If you are on a Pro plan, you can invite members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers: async (newMemberForm: Array<NewMemberForm>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newMemberForm' is not null or undefined
            assertParamExists('postMembers', 'newMemberForm', newMemberForm)
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newMemberForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountMembersApi - functional programming interface
 * @export
 */
export const AccountMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMember(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMember(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource.    - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(limit, offset, filter, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a single account member. The request should be a valid JSON Patch document describing the changes to be made to the member.  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMember(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMember(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMemberTeams(id, memberTeamsPostInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to bulk invite members is available to customers on an Enterprise plan. If you are on a Pro plan, you can invite members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMembers(newMemberForm: Array<NewMemberForm>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMembers(newMemberForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountMembersApi - factory interface
 * @export
 */
export const AccountMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountMembersApiFp(configuration)
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id: string, options?: any): AxiosPromise<Member> {
            return localVarFp.getMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource.    - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: any): AxiosPromise<Members> {
            return localVarFp.getMembers(limit, offset, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a single account member. The request should be a valid JSON Patch document describing the changes to be made to the member.  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Member> {
            return localVarFp.patchMember(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: any): AxiosPromise<Member> {
            return localVarFp.postMemberTeams(id, memberTeamsPostInput, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to bulk invite members is available to customers on an Enterprise plan. If you are on a Pro plan, you can invite members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers(newMemberForm: Array<NewMemberForm>, options?: any): AxiosPromise<Members> {
            return localVarFp.postMembers(newMemberForm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountMembersApi - object-oriented interface
 * @export
 * @class AccountMembersApi
 * @extends {BaseAPI}
 */
export class AccountMembersApi extends BaseAPI {
    /**
     * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
     * @summary Delete account member
     * @param {string} id The member ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public deleteMember(id: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).deleteMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
     * @summary Get account member
     * @param {string} id The member ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public getMember(id: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).getMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource.    - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
     * @summary List account members
     * @param {number} [limit] The number of members to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).getMembers(limit, offset, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a single account member. The request should be a valid JSON Patch document describing the changes to be made to the member.  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
     * @summary Modify an account member
     * @param {string} id The member ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public patchMember(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).patchMember(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add one member to one or more teams.
     * @summary Add a member to teams
     * @param {string} id The member ID
     * @param {MemberTeamsPostInput} memberTeamsPostInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).postMemberTeams(id, memberTeamsPostInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Full use of this API resource is an Enterprise feature > > The ability to bulk invite members is available to customers on an Enterprise plan. If you are on a Pro plan, you can invite members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
     * @summary Invite new members
     * @param {Array<NewMemberForm>} newMemberForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public postMembers(newMemberForm: Array<NewMemberForm>, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).postMembers(newMemberForm, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountMembersBetaApi - axios parameter creator
 * @export
 */
export const AccountMembersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are excluded from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are excluded from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMembers: async (membersPatchInput: MembersPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membersPatchInput' is not null or undefined
            assertParamExists('patchMembers', 'membersPatchInput', membersPatchInput)
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountMembersBetaApi - functional programming interface
 * @export
 */
export const AccountMembersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountMembersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are excluded from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are excluded from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMembers(membersPatchInput: MembersPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkEditMembersRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMembers(membersPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountMembersBetaApi - factory interface
 * @export
 */
export const AccountMembersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountMembersBetaApiFp(configuration)
    return {
        /**
         * Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are excluded from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are excluded from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMembers(membersPatchInput: MembersPatchInput, options?: any): AxiosPromise<BulkEditMembersRep> {
            return localVarFp.patchMembers(membersPatchInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountMembersBetaApi - object-oriented interface
 * @export
 * @class AccountMembersBetaApi
 * @extends {BaseAPI}
 */
export class AccountMembersBetaApi extends BaseAPI {
    /**
     * Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are excluded from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are excluded from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
     * @summary Modify account members
     * @param {MembersPatchInput} membersPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersBetaApi
     */
    public patchMembers(membersPatchInput: MembersPatchInput, options?: AxiosRequestConfig) {
        return AccountMembersBetaApiFp(this.configuration).patchMembers(membersPatchInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountUsageBetaApi - axios parameter creator
 * @export
 */
export const AccountUsageBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationsUsage: async (projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/usage/evaluations/{projectKey}/{environmentKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsage: async (type: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getEventsUsage', 'type', type)
            const localVarPath = `/api/v2/usage/events/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauSdksByType: async (from?: string, to?: string, sdktype?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau/sdks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sdktype !== undefined) {
                localVarQueryParameter['sdktype'] = sdktype;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsage: async (from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (sdktype !== undefined) {
                localVarQueryParameter['sdktype'] = sdktype;
            }

            if (sdk !== undefined) {
                localVarQueryParameter['sdk'] = sdk;
            }

            if (anonymous !== undefined) {
                localVarQueryParameter['anonymous'] = anonymous;
            }

            if (groupby !== undefined) {
                localVarQueryParameter['groupby'] = groupby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsageByCategory: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau/bycategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsage: async (source: string, from?: string, to?: string, tz?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsage', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageBySdkVersion: async (source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsageBySdkVersion', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}/bysdkversion`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }

            if (sdk !== undefined) {
                localVarQueryParameter['sdk'] = sdk;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageSdkversion: async (source: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsageSdkversion', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}/sdkversions`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsageBetaApi - functional programming interface
 * @export
 */
export const AccountUsageBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsageBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsUsage(type: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsUsage(type, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauSdksByType(from, to, sdktype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauUsageByCategory(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauUsageByCategory(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsage(source, from, to, tz, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsageSdkversion(source: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkVersionListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsageSdkversion(source, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountUsageBetaApi - factory interface
 * @export
 */
export const AccountUsageBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsageBetaApiFp(configuration)
    return {
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options).then((request) => request(axios, basePath));
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsage(type: string, from?: string, to?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getEventsUsage(type, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: any): AxiosPromise<SdkListRep> {
            return localVarFp.getMauSdksByType(from, to, sdktype, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options).then((request) => request(axios, basePath));
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsageByCategory(from?: string, to?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getMauUsageByCategory(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getStreamUsage(source, from, to, tz, options).then((request) => request(axios, basePath));
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageSdkversion(source: string, options?: any): AxiosPromise<SdkVersionListRep> {
            return localVarFp.getStreamUsageSdkversion(source, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountUsageBetaApi - object-oriented interface
 * @export
 * @class AccountUsageBetaApi
 * @extends {BaseAPI}
 */
export class AccountUsageBetaApi extends BaseAPI {
    /**
     * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get evaluations usage
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get events usage
     * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getEventsUsage(type: string, from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getEventsUsage(type, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.
     * @summary Get MAU SDKs by type
     * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
     * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
     * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauSdksByType(from, to, sdktype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.
     * @summary Get MAU usage
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
     * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
     * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
     * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
     * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
     * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.
     * @summary Get MAU usage by category
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauUsageByCategory(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauUsageByCategory(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get stream usage
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsage(source, from, to, tz, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get stream usage by SDK version
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
     * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
     * @summary Get stream usage SDK versions
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsageSdkversion(source: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsageSdkversion(source, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApprovalsApi - axios parameter creator
 * @export
 */
export const ApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequest: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteApprovalRequest', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteApprovalRequest', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteApprovalRequest', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApprovalRequest', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApprovalForFlag', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequest: async (projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequest', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequest', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequest', 'environmentKey', environmentKey)
            // verify required parameter 'createFlagConfigApprovalRequestRequest' is not null or undefined
            assertParamExists('postApprovalRequest', 'createFlagConfigApprovalRequestRequest', createFlagConfigApprovalRequestRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlagConfigApprovalRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApplyRequest: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyRequest', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyRequest', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyRequest', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestApplyRequest', 'id', id)
            // verify required parameter 'postApprovalRequestApplyRequest' is not null or undefined
            assertParamExists('postApprovalRequestApplyRequest', 'postApprovalRequestApplyRequest', postApprovalRequestApplyRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/apply`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestApplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReview: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'id', id)
            // verify required parameter 'postApprovalRequestReviewRequest' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'postApprovalRequestReviewRequest', postApprovalRequestReviewRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/reviews`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagCopyConfigApprovalRequest: async (projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'environmentKey', environmentKey)
            // verify required parameter 'createCopyFlagConfigApprovalRequestRequest' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'createCopyFlagConfigApprovalRequestRequest', createCopyFlagConfigApprovalRequestRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests-flag-copy`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCopyFlagConfigApprovalRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApprovalsApi - functional programming interface
 * @export
 */
export const ApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApprovalRequest(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequest(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestApplyRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestApplyRequest(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestReview(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestReview(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApprovalsApi - factory interface
 * @export
 */
export const ApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApprovalsApiFp(configuration)
    return {
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApprovalRequest(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FlagConfigApprovalRequestsResponse> {
            return localVarFp.getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequest(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApplyRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequestApplyRequest(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReview(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequestReview(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApprovalsApi - object-oriented interface
 * @export
 * @class ApprovalsApi
 * @extends {BaseAPI}
 */
export class ApprovalsApi extends BaseAPI {
    /**
     * Delete an approval request for a feature flag.
     * @summary Delete approval request
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public deleteApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).deleteApprovalRequest(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single approval request for a feature flag.
     * @summary Get approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all approval requests for a feature flag.
     * @summary List approval requests for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an approval request for a feature flag.
     * @summary Create approval request
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequest(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply an approval request that has been approved.
     * @summary Apply approval request
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestApplyRequest(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestApplyRequest(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Review an approval request by approving or denying changes.
     * @summary Review approval request
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestReview(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestReview(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an approval request to copy a feature flag\'s configuration across environments.
     * @summary Create approval request to copy flag configurations across environments
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key for the target environment
     * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditLogApi - axios parameter creator
 * @export
 */
export const AuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.
         * @summary List audit log feature flag entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource, or full or partial email address of the member who made a change.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries: async (before?: number, after?: number, q?: string, limit?: number, spec?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auditlog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (spec !== undefined) {
                localVarQueryParameter['spec'] = spec;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuditLogEntry', 'id', id)
            const localVarPath = `/api/v2/auditlog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogApi - functional programming interface
 * @export
 */
export const AuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.
         * @summary List audit log feature flag entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource, or full or partial email address of the member who made a change.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntryListingRepCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogEntries(before, after, q, limit, spec, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntry(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditLogApi - factory interface
 * @export
 */
export const AuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogApiFp(configuration)
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.
         * @summary List audit log feature flag entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource, or full or partial email address of the member who made a change.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: any): AxiosPromise<AuditLogEntryListingRepCollection> {
            return localVarFp.getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry(id: string, options?: any): AxiosPromise<AuditLogEntryRep> {
            return localVarFp.getAuditLogEntry(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export class AuditLogApi extends BaseAPI {
    /**
     * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.
     * @summary List audit log feature flag entries
     * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
     * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
     * @param {string} [q] Text to search for. You can search for the full or partial name of the resource, or full or partial email address of the member who made a change.
     * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20.
     * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: AxiosRequestConfig) {
        return AuditLogApiFp(this.configuration).getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
     * @summary Get audit log entry
     * @param {string} id The ID of the audit log entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntry(id: string, options?: AxiosRequestConfig) {
        return AuditLogApiFp(this.configuration).getAuditLogEntry(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CodeReferencesApi - axios parameter creator
 * @export
 */
export const CodeReferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranches: async (repo: string, requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('deleteBranches', 'repo', repo)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteBranches', 'requestBody', requestBody)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branch-delete-tasks`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('deleteRepository', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch: async (repo: string, branch: string, projKey?: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getBranch', 'branch', branch)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBranches', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtinctions: async (repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/extinctions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (repoName !== undefined) {
                localVarQueryParameter['repoName'] = repoName;
            }

            if (branchName !== undefined) {
                localVarQueryParameter['branchName'] = branchName;
            }

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories: async (withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withBranches !== undefined) {
                localVarQueryParameter['withBranches'] = withBranches;
            }

            if (withReferencesForDefaultBranch !== undefined) {
                localVarQueryParameter['withReferencesForDefaultBranch'] = withReferencesForDefaultBranch;
            }

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getRepository', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootStatistic: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (projectKey: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getStatistics', 'projectKey', projectKey)
            const localVarPath = `/api/v2/code-refs/statistics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a repository\'s settings. The request must be a valid JSON Patch document describing the changes to be made to the repository.
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepository: async (repo: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('patchRepository', 'repo', repo)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchRepository', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExtinction: async (repo: string, branch: string, extinction: Array<Extinction>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('postExtinction', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('postExtinction', 'branch', branch)
            // verify required parameter 'extinction' is not null or undefined
            assertParamExists('postExtinction', 'extinction', extinction)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}/extinction-events`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extinction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepository: async (repositoryPost: RepositoryPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryPost' is not null or undefined
            assertParamExists('postRepository', 'repositoryPost', repositoryPost)
            const localVarPath = `/api/v2/code-refs/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBranch: async (repo: string, branch: string, putBranch: PutBranch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('putBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('putBranch', 'branch', branch)
            // verify required parameter 'putBranch' is not null or undefined
            assertParamExists('putBranch', 'putBranch', putBranch)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putBranch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodeReferencesApi - functional programming interface
 * @export
 */
export const CodeReferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CodeReferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranches(repo: string, requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranches(repo, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranch(repo, branch, projKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranches(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranches(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtinctionCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtinctions(repoName, branchName, projKey, flagKey, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepository(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepository(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootStatistic(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsRoot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootStatistic(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(projectKey: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(projectKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a repository\'s settings. The request must be a valid JSON Patch document describing the changes to be made to the repository.
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepository(repo, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postExtinction(repo, branch, extinction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepository(repositoryPost: RepositoryPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepository(repositoryPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBranch(repo: string, branch: string, putBranch: PutBranch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBranch(repo, branch, putBranch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CodeReferencesApi - factory interface
 * @export
 */
export const CodeReferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CodeReferencesApiFp(configuration)
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranches(repo: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBranches(repo, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: any): AxiosPromise<BranchRep> {
            return localVarFp.getBranch(repo, branch, projKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches(repo: string, options?: any): AxiosPromise<BranchCollectionRep> {
            return localVarFp.getBranches(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: any): AxiosPromise<ExtinctionCollectionRep> {
            return localVarFp.getExtinctions(repoName, branchName, projKey, flagKey, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: any): AxiosPromise<RepositoryCollectionRep> {
            return localVarFp.getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository(repo: string, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.getRepository(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootStatistic(options?: any): AxiosPromise<StatisticsRoot> {
            return localVarFp.getRootStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(projectKey: string, flagKey?: string, options?: any): AxiosPromise<StatisticCollectionRep> {
            return localVarFp.getStatistics(projectKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a repository\'s settings. The request must be a valid JSON Patch document describing the changes to be made to the repository.
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.patchRepository(repo, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: any): AxiosPromise<void> {
            return localVarFp.postExtinction(repo, branch, extinction, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepository(repositoryPost: RepositoryPost, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.postRepository(repositoryPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBranch(repo: string, branch: string, putBranch: PutBranch, options?: any): AxiosPromise<void> {
            return localVarFp.putBranch(repo, branch, putBranch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CodeReferencesApi - object-oriented interface
 * @export
 * @class CodeReferencesApi
 * @extends {BaseAPI}
 */
export class CodeReferencesApi extends BaseAPI {
    /**
     * Asynchronously delete a number of branches.
     * @summary Delete branches
     * @param {string} repo The repository name to delete branches for.
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public deleteBranches(repo: string, requestBody: Array<string>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).deleteBranches(repo, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository with the specified name.
     * @summary Delete repository
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public deleteRepository(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).deleteRepository(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific branch in a repository.
     * @summary Get branch
     * @param {string} repo The repository name
     * @param {string} branch The url-encoded branch name
     * @param {string} [projKey] Filter results to a specific project
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getBranch(repo, branch, projKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of branches.
     * @summary List branches
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getBranches(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getBranches(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
     * @summary List extinctions
     * @param {string} [repoName] Filter results to a specific repository
     * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
     * @param {string} [projKey] Filter results to a specific project
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
     * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getExtinctions(repoName, branchName, projKey, flagKey, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
     * @summary List repositories
     * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
     * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
     * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
     * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single repository by name.
     * @summary Get repository
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRepository(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRepository(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get links for all projects that have code references.
     * @summary Get links to code reference repositories for each project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRootStatistic(options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRootStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
     * @summary Get code references statistics for flags
     * @param {string} projectKey The project key
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getStatistics(projectKey: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getStatistics(projectKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a repository\'s settings. The request must be a valid JSON Patch document describing the changes to be made to the repository.
     * @summary Update repository
     * @param {string} repo The repository name
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).patchRepository(repo, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new extinction.
     * @summary Create extinction
     * @param {string} repo The repository name
     * @param {string} branch The URL-encoded branch name
     * @param {Array<Extinction>} extinction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).postExtinction(repo, branch, extinction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a repository with the specified name.
     * @summary Create repository
     * @param {RepositoryPost} repositoryPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public postRepository(repositoryPost: RepositoryPost, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).postRepository(repositoryPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
     * @summary Upsert branch
     * @param {string} repo The repository name
     * @param {string} branch The URL-encoded branch name
     * @param {PutBranch} putBranch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public putBranch(repo: string, branch: string, putBranch: PutBranch, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).putBranch(repo, branch, putBranch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomRolesApi - axios parameter creator
 * @export
 */
export const CustomRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole: async (customRoleKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('deleteCustomRole', 'customRoleKey', customRoleKey)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole: async (customRoleKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('getCustomRole', 'customRoleKey', customRoleKey)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a single custom role. The request must be a valid JSON Patch document describing the changes to be made to the custom role. To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Using `/0` adds to the beginning of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole: async (customRoleKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('patchCustomRole', 'customRoleKey', customRoleKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchCustomRole', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole: async (customRolePost: CustomRolePost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRolePost' is not null or undefined
            assertParamExists('postCustomRole', 'customRolePost', customRolePost)
            const localVarPath = `/api/v2/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customRolePost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomRolesApi - functional programming interface
 * @export
 */
export const CustomRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomRole(customRoleKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomRole(customRoleKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRole(customRoleKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomRole(customRoleKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a single custom role. The request must be a valid JSON Patch document describing the changes to be made to the custom role. To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Using `/0` adds to the beginning of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCustomRole(customRoleKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomRole(customRolePost: CustomRolePost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomRole(customRolePost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomRolesApi - factory interface
 * @export
 */
export const CustomRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomRolesApiFp(configuration)
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole(customRoleKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole(customRoleKey: string, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.getCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles(options?: any): AxiosPromise<CustomRoles> {
            return localVarFp.getCustomRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a single custom role. The request must be a valid JSON Patch document describing the changes to be made to the custom role. To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Using `/0` adds to the beginning of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.patchCustomRole(customRoleKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole(customRolePost: CustomRolePost, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.postCustomRole(customRolePost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomRolesApi - object-oriented interface
 * @export
 * @class CustomRolesApi
 * @extends {BaseAPI}
 */
export class CustomRolesApi extends BaseAPI {
    /**
     * Delete a custom role by key
     * @summary Delete custom role
     * @param {string} customRoleKey The custom role key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public deleteCustomRole(customRoleKey: string, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).deleteCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single custom role by key or ID
     * @summary Get custom role
     * @param {string} customRoleKey The custom role key or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRole(customRoleKey: string, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).getCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
     * @summary List custom roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRoles(options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).getCustomRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a single custom role. The request must be a valid JSON Patch document describing the changes to be made to the custom role. To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Using `/0` adds to the beginning of the array.
     * @summary Update custom role
     * @param {string} customRoleKey The custom role key
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).patchCustomRole(customRoleKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new custom role
     * @summary Create custom role
     * @param {CustomRolePost} customRolePost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public postCustomRole(customRolePost: CustomRolePost, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).postCustomRole(customRolePost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataExportDestinationsApi - axios parameter creator
 * @export
 */
export const DataExportDestinationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination: async (projectKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDestination', 'id', id)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination: async (projectKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDestination', 'id', id)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Data Export destination. This requires a JSON Patch representation of the modified destination.
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination: async (projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchDestination', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchDestination', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination: async (projectKey: string, environmentKey: string, destinationPost: DestinationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postDestination', 'environmentKey', environmentKey)
            // verify required parameter 'destinationPost' is not null or undefined
            assertParamExists('postDestination', 'destinationPost', destinationPost)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExportDestinationsApi - functional programming interface
 * @export
 */
export const DataExportDestinationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataExportDestinationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDestination(projectKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestination(projectKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destinations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Data Export destination. This requires a JSON Patch representation of the modified destination.
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchDestination(projectKey, environmentKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDestination(projectKey, environmentKey, destinationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataExportDestinationsApi - factory interface
 * @export
 */
export const DataExportDestinationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataExportDestinationsApiFp(configuration)
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(projectKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDestination(projectKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination(projectKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<Destination> {
            return localVarFp.getDestination(projectKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options?: any): AxiosPromise<Destinations> {
            return localVarFp.getDestinations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Data Export destination. This requires a JSON Patch representation of the modified destination.
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Destination> {
            return localVarFp.patchDestination(projectKey, environmentKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: any): AxiosPromise<Destination> {
            return localVarFp.postDestination(projectKey, environmentKey, destinationPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataExportDestinationsApi - object-oriented interface
 * @export
 * @class DataExportDestinationsApi
 * @extends {BaseAPI}
 */
export class DataExportDestinationsApi extends BaseAPI {
    /**
     * Delete a Data Export destination by ID.
     * @summary Delete Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public deleteDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).deleteDestination(projectKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Data Export destination by ID.
     * @summary Get destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).getDestination(projectKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Data Export destinations configured across all projects and environments.
     * @summary List destinations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestinations(options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).getDestinations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Data Export destination. This requires a JSON Patch representation of the modified destination.
     * @summary Update Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).patchDestination(projectKey, environmentKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
     * @summary Create Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {DestinationPost} destinationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).postDestination(projectKey, environmentKey, destinationPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting environments  LaunchDarkly supports two fields for sorting: - `name` sorts by environment name. - `createdOn` sorts by the creation date of the environment.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsByProject: async (projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEnvironmentsByProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an environment. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the environment.  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment: async (projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchEnvironment', 'environmentKey', environmentKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchEnvironment', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment: async (projectKey: string, environmentPost: EnvironmentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentPost' is not null or undefined
            assertParamExists('postEnvironment', 'environmentPost', environmentPost)
            const localVarPath = `/api/v2/projects/{projectKey}/environments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('resetEnvironmentMobileKey', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('resetEnvironmentMobileKey', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/mobileKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey: async (projectKey: string, environmentKey: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('resetEnvironmentSDKKey', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('resetEnvironmentSDKKey', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/apiKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting environments  LaunchDarkly supports two fields for sorting: - `name` sorts by environment name. - `createdOn` sorts by the creation date of the environment.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an environment. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the environment.  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEnvironment(projectKey, environmentKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEnvironment(projectKey, environmentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetEnvironmentMobileKey(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting environments  LaunchDarkly supports two fields for sorting: - `name` sorts by environment name. - `createdOn` sorts by the creation date of the environment.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: any): AxiosPromise<Environments> {
            return localVarFp.getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an environment. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the environment.  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Environment> {
            return localVarFp.patchEnvironment(projectKey, environmentKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: any): AxiosPromise<Environment> {
            return localVarFp.postEnvironment(projectKey, environmentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.resetEnvironmentMobileKey(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): AxiosPromise<Environment> {
            return localVarFp.resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * Delete a environment by key.
     * @summary Delete environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public deleteEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).deleteEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
     * @summary Get environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting environments  LaunchDarkly supports two fields for sorting: - `name` sorts by environment name. - `createdOn` sorts by the creation date of the environment.  For example, `sort=name` sorts the response by environment name in ascending order. 
     * @summary List environments
     * @param {string} projectKey The project key
     * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an environment. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the environment.  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
     * @summary Update environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).patchEnvironment(projectKey, environmentKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
     * @summary Create environment
     * @param {string} projectKey The project key
     * @param {EnvironmentPost} environmentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).postEnvironment(projectKey, environmentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
     * @summary Reset environment mobile SDK key
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentMobileKey(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an environment\'s SDK key with an optional expiry time for the old key.
     * @summary Reset environment SDK key
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExperimentsBetaApi - axios parameter creator
 * @export
 */
export const ExperimentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an experiment. To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments).
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment: async (projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentPost' is not null or undefined
            assertParamExists('createExperiment', 'experimentPost', experimentPost)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experimentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an experiment iteration. Experiment iterations let you record experiments in discrete blocks of time. To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations).
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIteration: async (projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createIteration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createIteration', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('createIteration', 'experimentKey', experimentKey)
            // verify required parameter 'iterationInput' is not null or undefined
            assertParamExists('createIteration', 'iterationInput', iterationInput)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/iterations`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iterationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes a draft of an iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment: async (projectKey: string, environmentKey: string, experimentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('getExperiment', 'experimentKey', experimentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get results from an experiment for a particular metric.
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults: async (projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperimentResults', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperimentResults', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('getExperimentResults', 'experimentKey', experimentKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getExperimentResults', 'metricKey', metricKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metrics/{metricKey}/results`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments: async (projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperiments', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperiments', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (lifecycleState !== undefined) {
                localVarQueryParameter['lifecycleState'] = lifecycleState;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLegacyExperimentResults: async (projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'environmentKey', environmentKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'metricKey', metricKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/experiments/{environmentKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  #### startIteration  Starts a new iteration for this experiment.  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment - `winningReason`: The reason for the winner 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment: async (projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('patchExperiment', 'experimentKey', experimentKey)
            // verify required parameter 'experimentPatchInput' is not null or undefined
            assertParamExists('patchExperiment', 'experimentPatchInput', experimentPatchInput)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experimentPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset all experiment results by deleting all existing data for an experiment.
         * @summary Reset experiment results
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric\&#39;s key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetExperiment: async (projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('resetExperiment', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('resetExperiment', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('resetExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('resetExperiment', 'metricKey', metricKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/experiments/{environmentKey}/{metricKey}/results`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsBetaApi - functional programming interface
 * @export
 */
export const ExperimentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperimentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an experiment. To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments).
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperiment(projectKey, environmentKey, experimentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an experiment iteration. Experiment iterations let you record experiments in discrete blocks of time. To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations).
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IterationRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIteration(projectKey, environmentKey, experimentKey, iterationInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes a draft of an iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiment(projectKey: string, environmentKey: string, experimentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiment(projectKey, environmentKey, experimentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get results from an experiment for a particular metric.
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentBayesianResultsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  #### startIteration  Starts a new iteration for this experiment.  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment - `winningReason`: The reason for the winner 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset all experiment results by deleting all existing data for an experiment.
         * @summary Reset experiment results
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric\&#39;s key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetExperiment(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetExperiment(projectKey, featureFlagKey, environmentKey, metricKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperimentsBetaApi - factory interface
 * @export
 */
export const ExperimentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperimentsBetaApiFp(configuration)
    return {
        /**
         * Create an experiment. To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments).
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: any): AxiosPromise<Experiment> {
            return localVarFp.createExperiment(projectKey, environmentKey, experimentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an experiment iteration. Experiment iterations let you record experiments in discrete blocks of time. To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations).
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: any): AxiosPromise<IterationRep> {
            return localVarFp.createIteration(projectKey, environmentKey, experimentKey, iterationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes a draft of an iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(projectKey: string, environmentKey: string, experimentKey: string, options?: any): AxiosPromise<Experiment> {
            return localVarFp.getExperiment(projectKey, environmentKey, experimentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get results from an experiment for a particular metric.
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, options?: any): AxiosPromise<ExperimentBayesianResultsRep> {
            return localVarFp.getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: any): AxiosPromise<ExperimentCollectionRep> {
            return localVarFp.getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: any): AxiosPromise<ExperimentResults> {
            return localVarFp.getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  #### startIteration  Starts a new iteration for this experiment.  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment - `winningReason`: The reason for the winner 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: any): AxiosPromise<Experiment> {
            return localVarFp.patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset all experiment results by deleting all existing data for an experiment.
         * @summary Reset experiment results
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric\&#39;s key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetExperiment(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.resetExperiment(projectKey, featureFlagKey, environmentKey, metricKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperimentsBetaApi - object-oriented interface
 * @export
 * @class ExperimentsBetaApi
 * @extends {BaseAPI}
 */
export class ExperimentsBetaApi extends BaseAPI {
    /**
     * Create an experiment. To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments).
     * @summary Create experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {ExperimentPost} experimentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).createExperiment(projectKey, environmentKey, experimentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an experiment iteration. Experiment iterations let you record experiments in discrete blocks of time. To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations).
     * @summary Create iteration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {IterationInput} iterationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).createIteration(projectKey, environmentKey, experimentKey, iterationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about an experiment.  ### Expanding the experiment response LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes a draft of an iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. 
     * @summary Get experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperiment(projectKey: string, environmentKey: string, experimentKey: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperiment(projectKey, environmentKey, experimentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get results from an experiment for a particular metric.
     * @summary Get experiment results
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {string} metricKey The metric key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration. 
     * @summary Get experiments
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed experiment result data for legacy experiments.
     * @summary Get legacy experiment results (deprecated)
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} metricKey The metric key
     * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
     * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  #### startIteration  Starts a new iteration for this experiment.  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment - `winningReason`: The reason for the winner 
     * @summary Patch experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {ExperimentPatchInput} experimentPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset all experiment results by deleting all existing data for an experiment.
     * @summary Reset experiment results
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} metricKey The metric\&#39;s key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public resetExperiment(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).resetExperiment(projectKey, featureFlagKey, environmentKey, metricKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureFlagsApi - axios parameter creator
 * @export
 */
export const FeatureFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag: async (projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('copyFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('copyFeatureFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'flagCopyConfigPost' is not null or undefined
            assertParamExists('copyFeatureFlag', 'flagCopyConfigPost', flagCopyConfigPost)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/copy`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagCopyConfigPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFeatureFlag', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of user targets on a feature flag that are scheduled for removal.
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag: async (projectKey: string, featureFlagKey: string, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlag', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments: async (projectKey: string, featureFlagKey: string, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatusAcrossEnvironments', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagStatusAcrossEnvironments', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-status/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: the feature flag was created within the last seven days, and has not been requested yet - `active`: the feature flag was requested by your servers or clients within the last seven days - `inactive`: the feature flag was created more than seven days ago, and hasn\'t been requested by your servers or clients within the past seven days - `launched`: one variation of the feature flag has been rolled out to all your users for at least 7 days 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatuses', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagStatuses', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/flag-statuses/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all features in the given project. By default, each feature includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the tag query parameter.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  - `query` is a string that matches against the flags\' keys and names. It is not case sensitive. - `archived` is a boolean with values of `true` or `false` that filters the list to archived flags. Setting the value to `true` returns only archived flags. When this is absent, only unarchived flags are returned. - `type` is a string allowing filtering to `temporary` or `permanent` flags. - `status` is a string allowing filtering to `new`, `inactive`, `active`, or `launched` flags in the specified environment. This filter also requires a `filterEnv` field to be set to a valid environment. For example: `filter=status:active,filterEnv:production`. - `tags` is a `+` separated list of tags. It filters the list to members who have all of the tags in the list. For example: `filter=tags:beta+test`. - `hasExperiment` is a boolean with values of `true` or `false` that returns any flags that are used in an experiment. - `hasDataExport` is a boolean with values of `true` or `false` that returns any flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter also requires that you set a `filterEnv` field to a valid environment key. For example: `filter=hasDataExport:true,filterEnv:production` - `evaluated` is an object that contains a key of `after` and a value in Unix time in milliseconds. This returns all flags that have been evaluated since the time you specify in the environment provided. This filter also requires you to set a `filterEnv` field to a valid environment. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production`. - `filterEnv` is a string with the key of a valid environment. You can use the `filterEnv` field for filters that are environment-specific. If there are multiple environment-specific filters, you should only declare this parameter once. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active`.  By default, this returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order. 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default in API version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags: async (projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlags', 'projectKey', projectKey)
            const localVarPath = `/api/v2/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (summary !== undefined) {
                localVarQueryParameter['summary'] = summary;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (compare !== undefined) {
                localVarQueryParameter['compare'] = compare;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a user for removal from individual targeting on a feature flag. The flag must already individually target the user.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'patchFlagsRequest' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'patchFlagsRequest', patchFlagsRequest)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchFlagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch or JSON patch.  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for turning flags on and off</summary>  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  For example, to turn a flag off, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  For example, to turn a flag on, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for working with targeting and variations</summary>  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. - `beforeRuleId`: (Optional) ID of a flag rule. - `variationId`: ID of a variation of the flag. - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) User attribute.  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies.  ##### Parameters  - `variationId`: ID of a variation on the flag.  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  For example, to replace prerequisites, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key\",           \"variationId\": \"variation-1\"         },         {           \"key\": \"another-prereq-flag-key\",           \"variationId\": \"variation-2\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  For example, to replace rules, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"variation-1\",           \"description\": \"myRule\",           \"clauses\": [             {               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  For example, to replace user targets, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"variation-1\",           \"values\": [\"blah\", \"foo\", \"bar\"]         },         {           \"variationId\": \"variation-2\",           \"values\": [\"abc\", \"def\"]         }       ]     }       ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a user matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag. or - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  </details><br />  <details> <summary>Click to expand instructions for updating flag settings</summary>  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your users.  #### makeFlagTemporary  Marks the feature flag as temporary.  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  </details><br />  <details> <summary>Click to expand instructions for updating the flag lifecycle</summary>  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all users.  #### restoreFlag  Restores the feature flag if it was previously archived.  </details>  ### Example  The body of a single semantic patch can contain many different instructions.  <details> <summary>Click to expand example semantic patch request body</summary>  ```json {   \"environmentKey\": \"production\",   \"instructions\": [     {       \"kind\": \"turnFlagOn\"     },     {       \"kind\": \"turnFlagOff\"     },     {       \"kind\": \"addUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId\", \"userId2\"]     },     {       \"kind\": \"removeUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId3\", \"userId4\"]     },     {       \"kind\": \"updateFallthroughVariationOrRollout\",       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": null     },     {       \"kind\": \"addRule\",       \"clauses\": [         {           \"attribute\": \"segmentMatch\",           \"negate\": false,           \"values\": [\"test-segment\"]         }       ],       \"variationId\": null,       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": \"key\"     },     {       \"kind\": \"removeRule\",       \"ruleId\": \"99f12464-a429-40fc-86cc-b27612188955\"     },     {       \"kind\": \"reorderRules\",       \"ruleIds\": [\"2f72974e-de68-4243-8dd3-739582147a1f\", \"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"addClauses\",       \"ruleId\": \"1134\",       \"clauses\": [         {           \"attribute\": \"email\",           \"op\": \"in\",           \"negate\": false,           \"values\": [\"test@test.com\"]         }       ]     },     {       \"kind\": \"removeClauses\",       \"ruleId\": \"1242529\",       \"clauseIds\": [\"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"updateClause\",       \"ruleId\": \"2f72974e-de68-4243-8dd3-739582147a1f\",       \"clauseId\": \"309845\",       \"clause\": {         \"attribute\": \"segmentMatch\",         \"negate\": false,         \"values\": [\"test-segment\"]       }     },     {       \"kind\": \"updateRuleVariationOrRollout\",       \"ruleId\": \"2342\",       \"rolloutWeights\": null,       \"rolloutBucketBy\": null     },     {       \"kind\": \"updateOffVariation\",       \"variationId\": \"3242453\"     },     {       \"kind\": \"addPrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"updatePrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"removePrerequisite\",       \"key\": \"flagKey\"     }   ] } ``` </details>  ### Using JSON Patches on a feature flag If you do not include the header described above, you can use [JSON patch](/reference#updates-using-json-patch).  When using the update feature flag endpoint to add individual users to a specific variation, there are two different patch documents, depending on whether users are already being individually targeted for the variation.  If a flag variation already has users individually targeted, the path for the JSON Patch operation is:  ```json {   \"op\": \"add\",   \"path\": \"/environments/devint/targets/0/values/-\",   \"value\": \"TestClient10\" } ```  If a flag variation does not already have users individually targeted, the path for the JSON Patch operation is:  ```json [   {     \"op\": \"add\",     \"path\": \"/environments/devint/targets/-\",     \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }   } ] ```   ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows-(beta)).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`. 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag: async (projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchFeatureFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchFeatureFlag', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a feature flag with the given name, key, and variations.
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag: async (projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagBody' is not null or undefined
            assertParamExists('postFeatureFlag', 'featureFlagBody', featureFlagBody)
            const localVarPath = `/api/v2/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (clone !== undefined) {
                localVarQueryParameter['clone'] = clone;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(featureFlagBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsApi - functional programming interface
 * @export
 */
export const FeatureFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeatureFlag(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of user targets on a feature flag that are scheduled for removal.
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlag(projectKey, featureFlagKey, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagStatusRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatusAcrossEnvironments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: the feature flag was created within the last seven days, and has not been requested yet - `active`: the feature flag was requested by your servers or clients within the last seven days - `inactive`: the feature flag was created more than seven days ago, and hasn\'t been requested by your servers or clients within the past seven days - `launched`: one variation of the feature flag has been rolled out to all your users for at least 7 days 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatuses(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all features in the given project. By default, each feature includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the tag query parameter.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  - `query` is a string that matches against the flags\' keys and names. It is not case sensitive. - `archived` is a boolean with values of `true` or `false` that filters the list to archived flags. Setting the value to `true` returns only archived flags. When this is absent, only unarchived flags are returned. - `type` is a string allowing filtering to `temporary` or `permanent` flags. - `status` is a string allowing filtering to `new`, `inactive`, `active`, or `launched` flags in the specified environment. This filter also requires a `filterEnv` field to be set to a valid environment. For example: `filter=status:active,filterEnv:production`. - `tags` is a `+` separated list of tags. It filters the list to members who have all of the tags in the list. For example: `filter=tags:beta+test`. - `hasExperiment` is a boolean with values of `true` or `false` that returns any flags that are used in an experiment. - `hasDataExport` is a boolean with values of `true` or `false` that returns any flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter also requires that you set a `filterEnv` field to a valid environment key. For example: `filter=hasDataExport:true,filterEnv:production` - `evaluated` is an object that contains a key of `after` and a value in Unix time in milliseconds. This returns all flags that have been evaluated since the time you specify in the environment provided. This filter also requires you to set a `filterEnv` field to a valid environment. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production`. - `filterEnv` is a string with the key of a valid environment. You can use the `filterEnv` field for filters that are environment-specific. If there are multiple environment-specific filters, you should only declare this parameter once. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active`.  By default, this returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order. 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default in API version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a user for removal from individual targeting on a feature flag. The flag must already individually target the user.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch or JSON patch.  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for turning flags on and off</summary>  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  For example, to turn a flag off, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  For example, to turn a flag on, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for working with targeting and variations</summary>  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. - `beforeRuleId`: (Optional) ID of a flag rule. - `variationId`: ID of a variation of the flag. - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) User attribute.  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies.  ##### Parameters  - `variationId`: ID of a variation on the flag.  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  For example, to replace prerequisites, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key\",           \"variationId\": \"variation-1\"         },         {           \"key\": \"another-prereq-flag-key\",           \"variationId\": \"variation-2\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  For example, to replace rules, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"variation-1\",           \"description\": \"myRule\",           \"clauses\": [             {               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  For example, to replace user targets, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"variation-1\",           \"values\": [\"blah\", \"foo\", \"bar\"]         },         {           \"variationId\": \"variation-2\",           \"values\": [\"abc\", \"def\"]         }       ]     }       ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a user matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag. or - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  </details><br />  <details> <summary>Click to expand instructions for updating flag settings</summary>  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your users.  #### makeFlagTemporary  Marks the feature flag as temporary.  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  </details><br />  <details> <summary>Click to expand instructions for updating the flag lifecycle</summary>  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all users.  #### restoreFlag  Restores the feature flag if it was previously archived.  </details>  ### Example  The body of a single semantic patch can contain many different instructions.  <details> <summary>Click to expand example semantic patch request body</summary>  ```json {   \"environmentKey\": \"production\",   \"instructions\": [     {       \"kind\": \"turnFlagOn\"     },     {       \"kind\": \"turnFlagOff\"     },     {       \"kind\": \"addUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId\", \"userId2\"]     },     {       \"kind\": \"removeUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId3\", \"userId4\"]     },     {       \"kind\": \"updateFallthroughVariationOrRollout\",       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": null     },     {       \"kind\": \"addRule\",       \"clauses\": [         {           \"attribute\": \"segmentMatch\",           \"negate\": false,           \"values\": [\"test-segment\"]         }       ],       \"variationId\": null,       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": \"key\"     },     {       \"kind\": \"removeRule\",       \"ruleId\": \"99f12464-a429-40fc-86cc-b27612188955\"     },     {       \"kind\": \"reorderRules\",       \"ruleIds\": [\"2f72974e-de68-4243-8dd3-739582147a1f\", \"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"addClauses\",       \"ruleId\": \"1134\",       \"clauses\": [         {           \"attribute\": \"email\",           \"op\": \"in\",           \"negate\": false,           \"values\": [\"test@test.com\"]         }       ]     },     {       \"kind\": \"removeClauses\",       \"ruleId\": \"1242529\",       \"clauseIds\": [\"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"updateClause\",       \"ruleId\": \"2f72974e-de68-4243-8dd3-739582147a1f\",       \"clauseId\": \"309845\",       \"clause\": {         \"attribute\": \"segmentMatch\",         \"negate\": false,         \"values\": [\"test-segment\"]       }     },     {       \"kind\": \"updateRuleVariationOrRollout\",       \"ruleId\": \"2342\",       \"rolloutWeights\": null,       \"rolloutBucketBy\": null     },     {       \"kind\": \"updateOffVariation\",       \"variationId\": \"3242453\"     },     {       \"kind\": \"addPrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"updatePrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"removePrerequisite\",       \"key\": \"flagKey\"     }   ] } ``` </details>  ### Using JSON Patches on a feature flag If you do not include the header described above, you can use [JSON patch](/reference#updates-using-json-patch).  When using the update feature flag endpoint to add individual users to a specific variation, there are two different patch documents, depending on whether users are already being individually targeted for the variation.  If a flag variation already has users individually targeted, the path for the JSON Patch operation is:  ```json {   \"op\": \"add\",   \"path\": \"/environments/devint/targets/0/values/-\",   \"value\": \"TestClient10\" } ```  If a flag variation does not already have users individually targeted, the path for the JSON Patch operation is:  ```json [   {     \"op\": \"add\",     \"path\": \"/environments/devint/targets/-\",     \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }   } ] ```   ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows-(beta)).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`. 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a feature flag with the given name, key, and variations.
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFeatureFlag(projectKey, featureFlagBody, clone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureFlagsApi - factory interface
 * @export
 */
export const FeatureFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsApiFp(configuration)
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of user targets on a feature flag that are scheduled for removal.
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.getFeatureFlag(projectKey, featureFlagKey, env, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<FlagStatusRep> {
            return localVarFp.getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: any): AxiosPromise<FeatureFlagStatusAcrossEnvironments> {
            return localVarFp.getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: the feature flag was created within the last seven days, and has not been requested yet - `active`: the feature flag was requested by your servers or clients within the last seven days - `inactive`: the feature flag was created more than seven days ago, and hasn\'t been requested by your servers or clients within the past seven days - `launched`: one variation of the feature flag has been rolled out to all your users for at least 7 days 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: any): AxiosPromise<FeatureFlagStatuses> {
            return localVarFp.getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all features in the given project. By default, each feature includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the tag query parameter.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  - `query` is a string that matches against the flags\' keys and names. It is not case sensitive. - `archived` is a boolean with values of `true` or `false` that filters the list to archived flags. Setting the value to `true` returns only archived flags. When this is absent, only unarchived flags are returned. - `type` is a string allowing filtering to `temporary` or `permanent` flags. - `status` is a string allowing filtering to `new`, `inactive`, `active`, or `launched` flags in the specified environment. This filter also requires a `filterEnv` field to be set to a valid environment. For example: `filter=status:active,filterEnv:production`. - `tags` is a `+` separated list of tags. It filters the list to members who have all of the tags in the list. For example: `filter=tags:beta+test`. - `hasExperiment` is a boolean with values of `true` or `false` that returns any flags that are used in an experiment. - `hasDataExport` is a boolean with values of `true` or `false` that returns any flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter also requires that you set a `filterEnv` field to a valid environment key. For example: `filter=hasDataExport:true,filterEnv:production` - `evaluated` is an object that contains a key of `after` and a value in Unix time in milliseconds. This returns all flags that have been evaluated since the time you specify in the environment provided. This filter also requires you to set a `filterEnv` field to a valid environment. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production`. - `filterEnv` is a string with the key of a valid environment. You can use the `filterEnv` field for filters that are environment-specific. If there are multiple environment-specific filters, you should only declare this parameter once. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active`.  By default, this returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order. 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default in API version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, options?: any): AxiosPromise<FeatureFlags> {
            return localVarFp.getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a user for removal from individual targeting on a feature flag. The flag must already individually target the user.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch or JSON patch.  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for turning flags on and off</summary>  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  For example, to turn a flag off, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  For example, to turn a flag on, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for working with targeting and variations</summary>  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. - `beforeRuleId`: (Optional) ID of a flag rule. - `variationId`: ID of a variation of the flag. - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) User attribute.  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies.  ##### Parameters  - `variationId`: ID of a variation on the flag.  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  For example, to replace prerequisites, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key\",           \"variationId\": \"variation-1\"         },         {           \"key\": \"another-prereq-flag-key\",           \"variationId\": \"variation-2\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  For example, to replace rules, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"variation-1\",           \"description\": \"myRule\",           \"clauses\": [             {               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  For example, to replace user targets, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"variation-1\",           \"values\": [\"blah\", \"foo\", \"bar\"]         },         {           \"variationId\": \"variation-2\",           \"values\": [\"abc\", \"def\"]         }       ]     }       ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a user matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag. or - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  </details><br />  <details> <summary>Click to expand instructions for updating flag settings</summary>  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your users.  #### makeFlagTemporary  Marks the feature flag as temporary.  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  </details><br />  <details> <summary>Click to expand instructions for updating the flag lifecycle</summary>  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all users.  #### restoreFlag  Restores the feature flag if it was previously archived.  </details>  ### Example  The body of a single semantic patch can contain many different instructions.  <details> <summary>Click to expand example semantic patch request body</summary>  ```json {   \"environmentKey\": \"production\",   \"instructions\": [     {       \"kind\": \"turnFlagOn\"     },     {       \"kind\": \"turnFlagOff\"     },     {       \"kind\": \"addUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId\", \"userId2\"]     },     {       \"kind\": \"removeUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId3\", \"userId4\"]     },     {       \"kind\": \"updateFallthroughVariationOrRollout\",       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": null     },     {       \"kind\": \"addRule\",       \"clauses\": [         {           \"attribute\": \"segmentMatch\",           \"negate\": false,           \"values\": [\"test-segment\"]         }       ],       \"variationId\": null,       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": \"key\"     },     {       \"kind\": \"removeRule\",       \"ruleId\": \"99f12464-a429-40fc-86cc-b27612188955\"     },     {       \"kind\": \"reorderRules\",       \"ruleIds\": [\"2f72974e-de68-4243-8dd3-739582147a1f\", \"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"addClauses\",       \"ruleId\": \"1134\",       \"clauses\": [         {           \"attribute\": \"email\",           \"op\": \"in\",           \"negate\": false,           \"values\": [\"test@test.com\"]         }       ]     },     {       \"kind\": \"removeClauses\",       \"ruleId\": \"1242529\",       \"clauseIds\": [\"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"updateClause\",       \"ruleId\": \"2f72974e-de68-4243-8dd3-739582147a1f\",       \"clauseId\": \"309845\",       \"clause\": {         \"attribute\": \"segmentMatch\",         \"negate\": false,         \"values\": [\"test-segment\"]       }     },     {       \"kind\": \"updateRuleVariationOrRollout\",       \"ruleId\": \"2342\",       \"rolloutWeights\": null,       \"rolloutBucketBy\": null     },     {       \"kind\": \"updateOffVariation\",       \"variationId\": \"3242453\"     },     {       \"kind\": \"addPrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"updatePrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"removePrerequisite\",       \"key\": \"flagKey\"     }   ] } ``` </details>  ### Using JSON Patches on a feature flag If you do not include the header described above, you can use [JSON patch](/reference#updates-using-json-patch).  When using the update feature flag endpoint to add individual users to a specific variation, there are two different patch documents, depending on whether users are already being individually targeted for the variation.  If a flag variation already has users individually targeted, the path for the JSON Patch operation is:  ```json {   \"op\": \"add\",   \"path\": \"/environments/devint/targets/0/values/-\",   \"value\": \"TestClient10\" } ```  If a flag variation does not already have users individually targeted, the path for the JSON Patch operation is:  ```json [   {     \"op\": \"add\",     \"path\": \"/environments/devint/targets/-\",     \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }   } ] ```   ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows-(beta)).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`. 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a feature flag with the given name, key, and variations.
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsApi - object-oriented interface
 * @export
 * @class FeatureFlagsApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsApi extends BaseAPI {
    /**
     *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
     * @summary Copy feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {FlagCopyConfigPost} flagCopyConfigPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
     * @summary Delete feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of user targets on a feature flag that are scheduled for removal.
     * @summary Get expiring user targets for feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.
     * @summary Get feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [env] Filter configurations by environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlag(projectKey, featureFlagKey, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status for a particular feature flag.
     * @summary Get feature flag status
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status for a particular feature flag across environments.
     * @summary Get flag status across environments
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [env] Optional environment filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: the feature flag was created within the last seven days, and has not been requested yet - `active`: the feature flag was requested by your servers or clients within the last seven days - `inactive`: the feature flag was created more than seven days ago, and hasn\'t been requested by your servers or clients within the past seven days - `launched`: one variation of the feature flag has been rolled out to all your users for at least 7 days 
     * @summary List feature flag statuses
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all features in the given project. By default, each feature includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the tag query parameter.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  - `query` is a string that matches against the flags\' keys and names. It is not case sensitive. - `archived` is a boolean with values of `true` or `false` that filters the list to archived flags. Setting the value to `true` returns only archived flags. When this is absent, only unarchived flags are returned. - `type` is a string allowing filtering to `temporary` or `permanent` flags. - `status` is a string allowing filtering to `new`, `inactive`, `active`, or `launched` flags in the specified environment. This filter also requires a `filterEnv` field to be set to a valid environment. For example: `filter=status:active,filterEnv:production`. - `tags` is a `+` separated list of tags. It filters the list to members who have all of the tags in the list. For example: `filter=tags:beta+test`. - `hasExperiment` is a boolean with values of `true` or `false` that returns any flags that are used in an experiment. - `hasDataExport` is a boolean with values of `true` or `false` that returns any flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter also requires that you set a `filterEnv` field to a valid environment key. For example: `filter=hasDataExport:true,filterEnv:production` - `evaluated` is an object that contains a key of `after` and a value in Unix time in milliseconds. This returns all flags that have been evaluated since the time you specify in the environment provided. This filter also requires you to set a `filterEnv` field to a valid environment. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production`. - `filterEnv` is a string with the key of a valid environment. You can use the `filterEnv` field for filters that are environment-specific. If there are multiple environment-specific filters, you should only declare this parameter once. For example: `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active`.  By default, this returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order. 
     * @summary List feature flags
     * @param {string} projectKey The project key
     * @param {string} [env] Filter configurations by environment
     * @param {string} [tag] Filter feature flags by tag
     * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {boolean} [archived] A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
     * @param {boolean} [summary] By default in API version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
     * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a user for removal from individual targeting on a feature flag. The flag must already individually target the user.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag. * `userKey`: The user key for the user to remove from individual targeting 
     * @summary Update expiring user targets on feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {PatchFlagsRequest} patchFlagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a partial update to a feature flag. The request body must be a valid semantic patch or JSON patch.  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for turning flags on and off</summary>  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  For example, to turn a flag off, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  For example, to turn a flag on, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for working with targeting and variations</summary>  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. - `beforeRuleId`: (Optional) ID of a flag rule. - `variationId`: ID of a variation of the flag. - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) User attribute.  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies.  ##### Parameters  - `variationId`: ID of a variation on the flag.  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings.  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  For example, to replace prerequisites, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key\",           \"variationId\": \"variation-1\"         },         {           \"key\": \"another-prereq-flag-key\",           \"variationId\": \"variation-2\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  For example, to replace rules, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"variation-1\",           \"description\": \"myRule\",           \"clauses\": [             {               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  For example, to replace user targets, use this request body:  ```json {   \"environmentKey\": \"example-environment-key\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"variation-1\",           \"values\": [\"blah\", \"foo\", \"bar\"]         },         {           \"variationId\": \"variation-2\",           \"values\": [\"abc\", \"def\"]         }       ]     }       ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties.  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a user matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag. or - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: Optional user attribute.  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  </details><br />  <details> <summary>Click to expand instructions for updating flag settings</summary>  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your users.  #### makeFlagTemporary  Marks the feature flag as temporary.  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  </details><br />  <details> <summary>Click to expand instructions for updating the flag lifecycle</summary>  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all users.  #### restoreFlag  Restores the feature flag if it was previously archived.  </details>  ### Example  The body of a single semantic patch can contain many different instructions.  <details> <summary>Click to expand example semantic patch request body</summary>  ```json {   \"environmentKey\": \"production\",   \"instructions\": [     {       \"kind\": \"turnFlagOn\"     },     {       \"kind\": \"turnFlagOff\"     },     {       \"kind\": \"addUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId\", \"userId2\"]     },     {       \"kind\": \"removeUserTargets\",       \"variationId\": \"8bfb304e-d516-47e5-8727-e7f798e8992d\",       \"values\": [\"userId3\", \"userId4\"]     },     {       \"kind\": \"updateFallthroughVariationOrRollout\",       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": null     },     {       \"kind\": \"addRule\",       \"clauses\": [         {           \"attribute\": \"segmentMatch\",           \"negate\": false,           \"values\": [\"test-segment\"]         }       ],       \"variationId\": null,       \"rolloutWeights\": {         \"variationId\": 50000,         \"variationId2\": 50000       },       \"rolloutBucketBy\": \"key\"     },     {       \"kind\": \"removeRule\",       \"ruleId\": \"99f12464-a429-40fc-86cc-b27612188955\"     },     {       \"kind\": \"reorderRules\",       \"ruleIds\": [\"2f72974e-de68-4243-8dd3-739582147a1f\", \"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"addClauses\",       \"ruleId\": \"1134\",       \"clauses\": [         {           \"attribute\": \"email\",           \"op\": \"in\",           \"negate\": false,           \"values\": [\"test@test.com\"]         }       ]     },     {       \"kind\": \"removeClauses\",       \"ruleId\": \"1242529\",       \"clauseIds\": [\"8bfb304e-d516-47e5-8727-e7f798e8992d\"]     },     {       \"kind\": \"updateClause\",       \"ruleId\": \"2f72974e-de68-4243-8dd3-739582147a1f\",       \"clauseId\": \"309845\",       \"clause\": {         \"attribute\": \"segmentMatch\",         \"negate\": false,         \"values\": [\"test-segment\"]       }     },     {       \"kind\": \"updateRuleVariationOrRollout\",       \"ruleId\": \"2342\",       \"rolloutWeights\": null,       \"rolloutBucketBy\": null     },     {       \"kind\": \"updateOffVariation\",       \"variationId\": \"3242453\"     },     {       \"kind\": \"addPrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"updatePrerequisite\",       \"variationId\": \"234235\",       \"key\": \"flagKey2\"     },     {       \"kind\": \"removePrerequisite\",       \"key\": \"flagKey\"     }   ] } ``` </details>  ### Using JSON Patches on a feature flag If you do not include the header described above, you can use [JSON patch](/reference#updates-using-json-patch).  When using the update feature flag endpoint to add individual users to a specific variation, there are two different patch documents, depending on whether users are already being individually targeted for the variation.  If a flag variation already has users individually targeted, the path for the JSON Patch operation is:  ```json {   \"op\": \"add\",   \"path\": \"/environments/devint/targets/0/values/-\",   \"value\": \"TestClient10\" } ```  If a flag variation does not already have users individually targeted, the path for the JSON Patch operation is:  ```json [   {     \"op\": \"add\",     \"path\": \"/environments/devint/targets/-\",     \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }   } ] ```   ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows-(beta)).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`. 
     * @summary Update feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a feature flag with the given name, key, and variations.
     * @summary Create a feature flag
     * @param {string} projectKey The project key
     * @param {FeatureFlagBody} featureFlagBody 
     * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureFlagsBetaApi - axios parameter creator
 * @export
 */
export const FeatureFlagsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlags: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDependentFlags', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getDependentFlags', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/dependent-flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlagsByEnv: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsBetaApi - functional programming interface
 * @export
 */
export const FeatureFlagsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentFlags(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiEnvironmentDependentFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentFlags(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependentFlagsByEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureFlagsBetaApi - factory interface
 * @export
 */
export const FeatureFlagsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsBetaApiFp(configuration)
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlags(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<MultiEnvironmentDependentFlags> {
            return localVarFp.getDependentFlags(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<DependentFlagsByEnvironment> {
            return localVarFp.getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsBetaApi - object-oriented interface
 * @export
 * @class FeatureFlagsBetaApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsBetaApi extends BaseAPI {
    /**
     * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
     * @summary List dependent feature flags
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsBetaApi
     */
    public getDependentFlags(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsBetaApiFp(this.configuration).getDependentFlags(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/flags/prerequisites). 
     * @summary List dependent feature flags by environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsBetaApi
     */
    public getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsBetaApiFp(this.configuration).getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlagLinksBetaApi - axios parameter creator
 * @export
 */
export const FlagLinksBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlagLink: async (projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('createFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'flagLinkPost' is not null or undefined
            assertParamExists('createFlagLink', 'flagLinkPost', flagLinkPost)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagLinkPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagLink: async (projectKey: string, featureFlagKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFlagLink', 'id', id)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagLinks: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagLinks', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagLinks', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag link. The request body must be a valid JSON patch document. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlagLink: async (projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('updateFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('updateFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFlagLink', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('updateFlagLink', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlagLinksBetaApi - functional programming interface
 * @export
 */
export const FlagLinksBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlagLinksBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlagLink(projectKey, featureFlagKey, flagLinkPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagLink(projectKey, featureFlagKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagLinks(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagLinks(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag link. The request body must be a valid JSON patch document. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlagLinksBetaApi - factory interface
 * @export
 */
export const FlagLinksBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlagLinksBetaApiFp(configuration)
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: any): AxiosPromise<FlagLinkRep> {
            return localVarFp.createFlagLink(projectKey, featureFlagKey, flagLinkPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagLink(projectKey, featureFlagKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagLinks(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<FlagLinkCollectionRep> {
            return localVarFp.getFlagLinks(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag link. The request body must be a valid JSON patch document. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<FlagLinkRep> {
            return localVarFp.updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlagLinksBetaApi - object-oriented interface
 * @export
 * @class FlagLinksBetaApi
 * @extends {BaseAPI}
 */
export class FlagLinksBetaApi extends BaseAPI {
    /**
     * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
     * @summary Create flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {FlagLinkPost} flagLinkPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).createFlagLink(projectKey, featureFlagKey, flagLinkPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a flag link by ID or key.
     * @summary Delete flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag link ID or Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).deleteFlagLink(projectKey, featureFlagKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all flag links.
     * @summary List flag links
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public getFlagLinks(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).getFlagLinks(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag link. The request body must be a valid JSON patch document. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag link ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlagTriggersApi - axios parameter creator
 * @export
 */
export const FlagTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'triggerPost' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'triggerPost', triggerPost)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(triggerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'id', id)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflowById: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'id', id)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflows: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the trigger action instructions, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again. 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'id', id)
            // verify required parameter 'flagTriggerInput' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'flagTriggerInput', flagTriggerInput)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagTriggerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlagTriggersApi - functional programming interface
 * @export
 */
export const FlagTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlagTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the trigger action instructions, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again. 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlagTriggersApi - factory interface
 * @export
 */
export const FlagTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlagTriggersApiFp(configuration)
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<TriggerWorkflowCollectionRep> {
            return localVarFp.getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the trigger action instructions, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again. 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlagTriggersApi - object-oriented interface
 * @export
 * @class FlagTriggersApi
 * @extends {BaseAPI}
 */
export class FlagTriggersApi extends BaseAPI {
    /**
     * Create a new flag trigger.
     * @summary Create flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {TriggerPost} triggerPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a flag trigger by ID.
     * @summary Delete flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag trigger ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a flag trigger by ID.
     * @summary Get flag trigger by ID
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The flag trigger ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all flag triggers.
     * @summary List flag triggers
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the trigger action instructions, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again. 
     * @summary Update flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag trigger ID
     * @param {FlagTriggerInput} flagTriggerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FollowFlagsApi - axios parameter creator
 * @export
 */
export const FollowFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'environmentKey', environmentKey)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByProjEnv: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFollowersByProjEnv', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFollowersByProjEnv', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/followers`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'environmentKey', environmentKey)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('putFlagFollowers', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowFlagsApi - functional programming interface
 * @export
 */
export const FollowFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagFollowersGetRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagFollowers(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagFollowersByProjEnvGetRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersByProjEnv(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FollowFlagsApi - factory interface
 * @export
 */
export const FollowFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowFlagsApiFp(configuration)
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FlagFollowersGetRep> {
            return localVarFp.getFlagFollowers(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: any): AxiosPromise<FlagFollowersByProjEnvGetRep> {
            return localVarFp.getFollowersByProjEnv(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowFlagsApi - object-oriented interface
 * @export
 * @class FollowFlagsApi
 * @extends {BaseAPI}
 */
export class FollowFlagsApi extends BaseAPI {
    /**
     * Remove a member as a follower to a flag in a project and environment
     * @summary Remove a member as a follower of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} memberId The memberId of the member to remove as a follower of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of members following a flag in a project and environment
     * @summary Get followers of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).getFlagFollowers(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get followers of all flags in a given environment and project
     * @summary Get followers of all flags in a given project and environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).getFollowersByProjEnv(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a member as a follower to a flag in a project and environment
     * @summary Add a member as a follower of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} memberId The memberId of the member to add as a follower of the flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationAuditLogSubscriptionsApi - axios parameter creator
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (integrationKey: string, subscriptionPost: SubscriptionPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('createSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'subscriptionPost' is not null or undefined
            assertParamExists('createSubscription', 'subscriptionPost', subscriptionPost)
            const localVarPath = `/api/v2/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription: async (integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('deleteSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubscription', 'id', id)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByID: async (integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getSubscriptionByID', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionByID', 'id', id)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (integrationKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getSubscriptions', 'integrationKey', integrationKey)
            const localVarPath = `/api/v2/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an audit log subscription configuration. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the audit log subscription.
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('updateSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscription', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('updateSubscription', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationAuditLogSubscriptionsApi - functional programming interface
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationAuditLogSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(integrationKey, subscriptionPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscription(integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionByID(integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionByID(integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(integrationKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integrations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(integrationKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an audit log subscription configuration. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the audit log subscription.
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(integrationKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationAuditLogSubscriptionsApi - factory interface
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationAuditLogSubscriptionsApiFp(configuration)
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: any): AxiosPromise<Integration> {
            return localVarFp.createSubscription(integrationKey, subscriptionPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(integrationKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscription(integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByID(integrationKey: string, id: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.getSubscriptionByID(integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(integrationKey: string, options?: any): AxiosPromise<Integrations> {
            return localVarFp.getSubscriptions(integrationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an audit log subscription configuration. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the audit log subscription.
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Integration> {
            return localVarFp.updateSubscription(integrationKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationAuditLogSubscriptionsApi - object-oriented interface
 * @export
 * @class IntegrationAuditLogSubscriptionsApi
 * @extends {BaseAPI}
 */
export class IntegrationAuditLogSubscriptionsApi extends BaseAPI {
    /**
     * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
     * @summary Create audit log subscription
     * @param {string} integrationKey The integration key
     * @param {SubscriptionPost} subscriptionPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).createSubscription(integrationKey, subscriptionPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an audit log subscription.
     * @summary Delete audit log subscription
     * @param {string} integrationKey The integration key
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public deleteSubscription(integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).deleteSubscription(integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an audit log subscription by ID.
     * @summary Get audit log subscription by ID
     * @param {string} integrationKey The integration key
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public getSubscriptionByID(integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).getSubscriptionByID(integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all audit log subscriptions associated with a given integration.
     * @summary Get audit log subscriptions by integration
     * @param {string} integrationKey The integration key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public getSubscriptions(integrationKey: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).getSubscriptions(integrationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an audit log subscription configuration. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the audit log subscription.
     * @summary Update audit log subscription
     * @param {string} integrationKey The integration key
     * @param {string} id The ID of the audit log subscription
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).updateSubscription(integrationKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationDeliveryConfigurationsBetaApi - axios parameter creator
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationDeliveryConfigurationPost' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'integrationDeliveryConfigurationPost', integrationDeliveryConfigurationPost)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationDeliveryConfigurationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationByEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationByEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationByEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationById: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/integration-capabilities/featureStore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an integration delivery configuration.
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}/validate`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - functional programming interface
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationDeliveryConfigurationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an integration delivery configuration.
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - factory interface
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationDeliveryConfigurationsBetaApiFp(configuration)
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<IntegrationDeliveryConfigurationCollection> {
            return localVarFp.getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurations(options?: any): AxiosPromise<IntegrationDeliveryConfigurationCollection> {
            return localVarFp.getIntegrationDeliveryConfigurations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an integration delivery configuration.
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<IntegrationDeliveryConfigurationResponse> {
            return localVarFp.validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - object-oriented interface
 * @export
 * @class IntegrationDeliveryConfigurationsBetaApi
 * @extends {BaseAPI}
 */
export class IntegrationDeliveryConfigurationsBetaApi extends BaseAPI {
    /**
     * Create a delivery configuration.
     * @summary Create delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a delivery configuration.
     * @summary Delete delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get delivery configurations by environment.
     * @summary Get delivery configurations by environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get delivery configuration by ID.
     * @summary Get delivery configuration by ID
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all delivery configurations.
     * @summary List all delivery configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurations(options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an integration delivery configuration.
     * @summary Update delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
     * @summary Validate delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric: async (projectKey: string, metricKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('deleteMetric', 'metricKey', metricKey)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports two fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (projectKey: string, metricKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getMetric', 'metricKey', metricKey)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (projectKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetrics', 'projectKey', projectKey)
            const localVarPath = `/api/v2/metrics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch a metric by key.
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetric: async (projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('patchMetric', 'metricKey', metricKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchMetric', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric: async (projectKey: string, metricPost: MetricPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postMetric', 'projectKey', projectKey)
            // verify required parameter 'metricPost' is not null or undefined
            assertParamExists('postMetric', 'metricPost', metricPost)
            const localVarPath = `/api/v2/metrics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric(projectKey: string, metricKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric(projectKey, metricKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports two fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(projectKey: string, metricKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(projectKey, metricKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(projectKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(projectKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch a metric by key.
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMetric(projectKey, metricKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetric(projectKey: string, metricPost: MetricPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetric(projectKey, metricPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric(projectKey: string, metricKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMetric(projectKey, metricKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports two fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(projectKey: string, metricKey: string, expand?: string, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.getMetric(projectKey, metricKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(projectKey: string, expand?: string, options?: any): AxiosPromise<MetricCollectionRep> {
            return localVarFp.getMetrics(projectKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch a metric by key.
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.patchMetric(projectKey, metricKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric(projectKey: string, metricPost: MetricPost, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.postMetric(projectKey, metricPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Delete a metric by key.
     * @summary Delete metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public deleteMetric(projectKey: string, metricKey: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).deleteMetric(projectKey, metricKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports two fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
     * @summary Get metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(projectKey: string, metricKey: string, expand?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(projectKey, metricKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
     * @summary List metrics
     * @param {string} projectKey The project key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(projectKey: string, expand?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(projectKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch a metric by key.
     * @summary Update metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).patchMetric(projectKey, metricKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
     * @summary Create metric
     * @param {string} projectKey The project key
     * @param {MetricPost} metricPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public postMetric(projectKey: string, metricPost: MetricPost, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).postMetric(projectKey, metricPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuth2ClientsBetaApi - axios parameter creator
 * @export
 */
export const OAuth2ClientsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2Client: async (oauthClientPost: OauthClientPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthClientPost' is not null or undefined
            assertParamExists('createOAuth2Client', 'oauthClientPost', oauthClientPost)
            const localVarPath = `/api/v2/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauthClientPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthClient: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteOAuthClient', 'clientId', clientId)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClientById: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getOAuthClientById', 'clientId', clientId)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the client. Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOAuthClient: async (clientId: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('patchOAuthClient', 'clientId', clientId)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchOAuthClient', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ClientsBetaApi - functional programming interface
 * @export
 */
export const OAuth2ClientsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ClientsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOAuth2Client(oauthClientPost: OauthClientPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOAuth2Client(oauthClientPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOAuthClient(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOAuthClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthClientById(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthClientById(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthClients(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthClients(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the client. Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOAuthClient(clientId, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuth2ClientsBetaApi - factory interface
 * @export
 */
export const OAuth2ClientsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ClientsBetaApiFp(configuration)
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2Client(oauthClientPost: OauthClientPost, options?: any): AxiosPromise<Client> {
            return localVarFp.createOAuth2Client(oauthClientPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthClient(clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOAuthClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClientById(clientId: string, options?: any): AxiosPromise<Client> {
            return localVarFp.getOAuthClientById(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClients(options?: any): AxiosPromise<ClientCollection> {
            return localVarFp.getOAuthClients(options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the client. Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Client> {
            return localVarFp.patchOAuthClient(clientId, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2ClientsBetaApi - object-oriented interface
 * @export
 * @class OAuth2ClientsBetaApi
 * @extends {BaseAPI}
 */
export class OAuth2ClientsBetaApi extends BaseAPI {
    /**
     * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
     * @summary Create a LaunchDarkly OAuth 2.0 client
     * @param {OauthClientPost} oauthClientPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsBetaApi
     */
    public createOAuth2Client(oauthClientPost: OauthClientPost, options?: AxiosRequestConfig) {
        return OAuth2ClientsBetaApiFp(this.configuration).createOAuth2Client(oauthClientPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing OAuth 2.0 client by unique client ID.
     * @summary Delete OAuth 2.0 client
     * @param {string} clientId The client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsBetaApi
     */
    public deleteOAuthClient(clientId: string, options?: AxiosRequestConfig) {
        return OAuth2ClientsBetaApiFp(this.configuration).deleteOAuthClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a registered OAuth 2.0 client by unique client ID.
     * @summary Get client by ID
     * @param {string} clientId The client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsBetaApi
     */
    public getOAuthClientById(clientId: string, options?: AxiosRequestConfig) {
        return OAuth2ClientsBetaApiFp(this.configuration).getOAuthClientById(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all OAuth 2.0 clients registered by your account.
     * @summary Get clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsBetaApi
     */
    public getOAuthClients(options?: AxiosRequestConfig) {
        return OAuth2ClientsBetaApiFp(this.configuration).getOAuthClients(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an existing OAuth 2.0 client by client ID. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the client. Only `name`, `description`, and `redirectUri` may be patched.
     * @summary Patch client by ID
     * @param {string} clientId The client ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsBetaApi
     */
    public patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return OAuth2ClientsBetaApiFp(this.configuration).patchOAuthClient(clientId, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OtherApi - axios parameter creator
 * @export
 */
export const OtherApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/public-ip-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenapiSpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OtherApi - functional programming interface
 * @export
 */
export const OtherApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OtherApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIps(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIps(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenapiSpec(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenapiSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Link; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OtherApi - factory interface
 * @export
 */
export const OtherApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OtherApiFp(configuration)
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIps(options?: any): AxiosPromise<IpList> {
            return localVarFp.getIps(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenapiSpec(options?: any): AxiosPromise<void> {
            return localVarFp.getOpenapiSpec(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(options?: any): AxiosPromise<{ [key: string]: Link; }> {
            return localVarFp.getRoot(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): AxiosPromise<VersionsRep> {
            return localVarFp.getVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OtherApi - object-oriented interface
 * @export
 * @class OtherApi
 * @extends {BaseAPI}
 */
export class OtherApi extends BaseAPI {
    /**
     * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Gets the public IP list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getIps(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getIps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Gets the OpenAPI spec in json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getOpenapiSpec(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getOpenapiSpec(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Root resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getRoot(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getRoot(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
     * @summary Get version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getVersions(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getVersions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagDefaultsByProject: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagDefaultsByProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag default. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the flag default.
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagDefaultsByProject: async (projectKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFlagDefaultsByProject', 'projectKey', projectKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchFlagDefaultsByProject', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the project.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject: async (projectKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchProject', 'projectKey', projectKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchProject', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject: async (projectPost: ProjectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPost' is not null or undefined
            assertParamExists('postProject', 'projectPost', projectPost)
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagDefaultsByProject: async (projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagDefaultsByProject', 'projectKey', projectKey)
            // verify required parameter 'upsertFlagDefaultsPayload' is not null or undefined
            assertParamExists('putFlagDefaultsByProject', 'upsertFlagDefaultsPayload', upsertFlagDefaultsPayload)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertFlagDefaultsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagDefaultsByProject(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagDefaultsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagDefaultsByProject(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(limit, offset, filter, sort, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag default. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the flag default.
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertPayloadRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFlagDefaultsByProject(projectKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a project. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the project.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProject(projectKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProject(projectPost: ProjectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProject(projectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertPayloadRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagDefaultsByProject(projectKey: string, options?: any): AxiosPromise<FlagDefaultsRep> {
            return localVarFp.getFlagDefaultsByProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectKey: string, expand?: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: any): AxiosPromise<Projects> {
            return localVarFp.getProjects(limit, offset, filter, sort, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag default. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the flag default.
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<UpsertPayloadRep> {
            return localVarFp.patchFlagDefaultsByProject(projectKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a project. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the project.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<ProjectRep> {
            return localVarFp.patchProject(projectKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(projectPost: ProjectPost, options?: any): AxiosPromise<ProjectRep> {
            return localVarFp.postProject(projectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: any): AxiosPromise<UpsertPayloadRep> {
            return localVarFp.putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @summary Delete project
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectKey: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the flag defaults for a specific project.
     * @summary Get flag defaults for project
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getFlagDefaultsByProject(projectKey: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getFlagDefaultsByProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
     * @summary Get project
     * @param {string} projectKey The project key.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectKey: string, expand?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(projectKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+` separate list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
     * @summary List projects
     * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjects(limit, offset, filter, sort, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag default. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the flag default.
     * @summary Update flag default for project
     * @param {string} projectKey The project key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).patchFlagDefaultsByProject(projectKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a project. Requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the project.
     * @summary Update project
     * @param {string} projectKey The project key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).patchProject(projectKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new project with the given key and name. Project keys must be unique within an account.
     * @summary Create project
     * @param {ProjectPost} projectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public postProject(projectPost: ProjectPost, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).postProject(projectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update flag defaults for a project.
     * @summary Create or update flag defaults for project
     * @param {string} projectKey The project key
     * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelayProxyConfigurationsApi - axios parameter creator
 * @export
 */
export const RelayProxyConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayAutoConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRelayAutoConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRelayProxyConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Relay Proxy config using the JSON patch format.
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayAutoConfig: async (id: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRelayAutoConfig', 'id', id)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchRelayAutoConfig', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig: async (relayAutoConfigPost: RelayAutoConfigPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relayAutoConfigPost' is not null or undefined
            assertParamExists('postRelayAutoConfig', 'relayAutoConfigPost', relayAutoConfigPost)
            const localVarPath = `/api/v2/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relayAutoConfigPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayAutoConfig: async (id: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetRelayAutoConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelayProxyConfigurationsApi - functional programming interface
 * @export
 */
export const RelayProxyConfigurationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelayProxyConfigurationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelayAutoConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelayAutoConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayProxyConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfigs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayProxyConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Relay Proxy config using the JSON patch format.
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelayAutoConfig(id, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRelayAutoConfig(relayAutoConfigPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetRelayAutoConfig(id: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetRelayAutoConfig(id, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelayProxyConfigurationsApi - factory interface
 * @export
 */
export const RelayProxyConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelayProxyConfigurationsApiFp(configuration)
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayAutoConfig(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelayAutoConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig(id: string, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.getRelayProxyConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs(options?: any): AxiosPromise<RelayAutoConfigCollectionRep> {
            return localVarFp.getRelayProxyConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Relay Proxy config using the JSON patch format.
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.patchRelayAutoConfig(id, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.postRelayAutoConfig(relayAutoConfigPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayAutoConfig(id: string, expiry?: number, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.resetRelayAutoConfig(id, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelayProxyConfigurationsApi - object-oriented interface
 * @export
 * @class RelayProxyConfigurationsApi
 * @extends {BaseAPI}
 */
export class RelayProxyConfigurationsApi extends BaseAPI {
    /**
     * Delete a Relay Proxy config.
     * @summary Delete Relay Proxy config by ID
     * @param {string} id The relay auto config id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public deleteRelayAutoConfig(id: string, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).deleteRelayAutoConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Relay Proxy auto config by ID.
     * @summary Get Relay Proxy config
     * @param {string} id The relay auto config id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfig(id: string, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Relay Proxy configurations in the account.
     * @summary List Relay Proxy configs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfigs(options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Relay Proxy config using the JSON patch format.
     * @summary Update a Relay Proxy config
     * @param {string} id The relay auto config id
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).patchRelayAutoConfig(id, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Relay Proxy config.
     * @summary Create a new Relay Proxy config
     * @param {RelayAutoConfigPost} relayAutoConfigPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).postRelayAutoConfig(relayAutoConfigPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
     * @summary Reset Relay Proxy configuration key
     * @param {string} id The Relay Proxy configuration ID
     * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public resetRelayAutoConfig(id: string, expiry?: number, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).resetRelayAutoConfig(id, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledChangesApi - axios parameter creator
 * @export
 */
export const ScheduledChangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagScheduledChange: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  #### deleteScheduledChange  Removes the scheduled change.  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the scheduled changes, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds. 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagConfigScheduledChange: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'id', id)
            // verify required parameter 'flagScheduledChangesInput' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'flagScheduledChangesInput', flagScheduledChangesInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ignoreConflicts !== undefined) {
                localVarQueryParameter['ignoreConflicts'] = ignoreConflicts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagScheduledChangesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            // verify required parameter 'postFlagScheduledChangesInput' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'postFlagScheduledChangesInput', postFlagScheduledChangesInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ignoreConflicts !== undefined) {
                localVarQueryParameter['ignoreConflicts'] = ignoreConflicts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFlagScheduledChangesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledChangesApi - functional programming interface
 * @export
 */
export const ScheduledChangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledChangesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChanges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  #### deleteScheduledChange  Removes the scheduled change.  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the scheduled changes, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds. 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledChangesApi - factory interface
 * @export
 */
export const ScheduledChangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledChangesApiFp(configuration)
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FeatureFlagScheduledChanges> {
            return localVarFp.getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  #### deleteScheduledChange  Removes the scheduled change.  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the scheduled changes, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds. 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options).then((request) => request(axios, basePath));
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduledChangesApi - object-oriented interface
 * @export
 * @class ScheduledChangesApi
 * @extends {BaseAPI}
 */
export class ScheduledChangesApi extends BaseAPI {
    /**
     * Delete a scheduled changes workflow.
     * @summary Delete scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a scheduled change that will be applied to the feature flag by ID.
     * @summary Get a scheduled change
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of scheduled changes that will be applied to the feature flag.
     * @summary List scheduled changes
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  #### deleteScheduledChange  Removes the scheduled change.  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  For example, to replace the scheduled changes, use this request body:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds. 
     * @summary Update scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change ID
     * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
     * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
     * @summary Create scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
     * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('deleteSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of a segment\'s user targets that are scheduled for removal.
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single user segment by key.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the membership status (included/excluded) for a given user in this Big Segment. This operation does not support standard segments.
         * @summary Get Big Segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForUser: async (projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'segmentKey', segmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'userKey', userKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all user segments in the given project.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegments: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegments', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegments', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating user targets.  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'segmentKey', segmentKey)
            // verify required parameter 'patchSegmentRequest' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'patchSegmentRequest', patchSegmentRequest)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch.  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment.  ##### Parameters  - `values`: List of user keys.  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment.  ##### Parameters  - `values`: List of user keys.  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  ## Using JSON patches on a segment  You can also use JSON patch. To learn more, read [Updates using JSON patches](/reference#updates-using-json-patch).  For example, to update the description for a segment, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` adds the new entry to the beginning of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove users from segments, we recommend using semantic patch. Semantic patch for segments includes specific `instructions` for adding and removing both included and excluded users. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('patchSegment', 'segmentKey', segmentKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchSegment', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSegment: async (projectKey: string, environmentKey: string, segmentBody: SegmentBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentBody' is not null or undefined
            assertParamExists('postSegment', 'segmentBody', segmentBody)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update targets included or excluded in a Big Segment.
         * @summary Update targets on a Big Segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentTargets: async (projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'segmentKey', segmentKey)
            // verify required parameter 'segmentUserState' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'segmentUserState', segmentUserState)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentUserState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a user segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of a segment\'s user targets that are scheduled for removal.
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single user segment by key.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the membership status (included/excluded) for a given user in this Big Segment. This operation does not support standard segments.
         * @summary Get Big Segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all user segments in the given project.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegments(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegments(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating user targets.  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch.  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment.  ##### Parameters  - `values`: List of user keys.  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment.  ##### Parameters  - `values`: List of user keys.  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  ## Using JSON patches on a segment  You can also use JSON patch. To learn more, read [Updates using JSON patches](/reference#updates-using-json-patch).  For example, to update the description for a segment, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` adds the new entry to the beginning of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove users from segments, we recommend using semantic patch. Semantic patch for segments includes specific `instructions` for adding and removing both included and excluded users. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new user segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSegment(projectKey, environmentKey, segmentBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update targets included or excluded in a Big Segment.
         * @summary Update targets on a Big Segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * Delete a user segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of a segment\'s user targets that are scheduled for removal.
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single user segment by key.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.getSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the membership status (included/excluded) for a given user in this Big Segment. This operation does not support standard segments.
         * @summary Get Big Segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: any): AxiosPromise<BigSegmentTarget> {
            return localVarFp.getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all user segments in the given project.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegments(projectKey: string, environmentKey: string, options?: any): AxiosPromise<UserSegments> {
            return localVarFp.getSegments(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating user targets.  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch.  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment.  ##### Parameters  - `values`: List of user keys.  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment.  ##### Parameters  - `values`: List of user keys.  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  ## Using JSON patches on a segment  You can also use JSON patch. To learn more, read [Updates using JSON patches](/reference#updates-using-json-patch).  For example, to update the description for a segment, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` adds the new entry to the beginning of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove users from segments, we recommend using semantic patch. Semantic patch for segments includes specific `instructions` for adding and removing both included and excluded users. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.postSegment(projectKey, environmentKey, segmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update targets included or excluded in a Big Segment.
         * @summary Update targets on a Big Segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: any): AxiosPromise<void> {
            return localVarFp.updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * Delete a user segment.
     * @summary Delete segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of a segment\'s user targets that are scheduled for removal.
     * @summary Get expiring user targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single user segment by key.
     * @summary Get segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the membership status (included/excluded) for a given user in this Big Segment. This operation does not support standard segments.
     * @summary Get Big Segment membership for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all user segments in the given project.
     * @summary List segments
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegments(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegments(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating user targets.  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. 
     * @summary Update expiring user targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {PatchSegmentRequest} patchSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch.  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded.  ##### Parameters  - `values`: List of user keys.  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment.  ##### Parameters  - `values`: List of user keys.  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment.  ##### Parameters  - `values`: List of user keys.  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  ## Using JSON patches on a segment  You can also use JSON patch. To learn more, read [Updates using JSON patches](/reference#updates-using-json-patch).  For example, to update the description for a segment, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` adds the new entry to the beginning of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove users from segments, we recommend using semantic patch. Semantic patch for segments includes specific `instructions` for adding and removing both included and excluded users. 
     * @summary Patch segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user segment.
     * @summary Create segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {SegmentBody} segmentBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).postSegment(projectKey, environmentKey, segmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update targets included or excluded in a Big Segment.
     * @summary Update targets on a Big Segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {SegmentUserState} segmentUserState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsBetaApi - axios parameter creator
 * @export
 */
export const SegmentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Starts a new export process for a Big Segment
         * @summary Create Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentExport: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new import process for a Big Segment.
         * @summary Create Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentImport: async (projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (mode !== undefined) { 
                localVarFormParams.append('mode', mode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about a Big Segment export process.
         * @summary Get Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentExport: async (projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'segmentKey', segmentKey)
            // verify required parameter 'exportID' is not null or undefined
            assertParamExists('getBigSegmentExport', 'exportID', exportID)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports/{exportID}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"exportID"}}`, encodeURIComponent(String(exportID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about a Big Segment import process.
         * @summary Get Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentImport: async (projectKey: string, environmentKey: string, segmentKey: string, importID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'segmentKey', segmentKey)
            // verify required parameter 'importID' is not null or undefined
            assertParamExists('getBigSegmentImport', 'importID', importID)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports/{importID}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"importID"}}`, encodeURIComponent(String(importID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsBetaApi - functional programming interface
 * @export
 */
export const SegmentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Starts a new export process for a Big Segment
         * @summary Create Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigSegmentExport(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a new import process for a Big Segment.
         * @summary Create Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns info about a Big Segment export process.
         * @summary Get Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Export>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns info about a Big Segment import process.
         * @summary Get Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Import>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsBetaApi - factory interface
 * @export
 */
export const SegmentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsBetaApiFp(configuration)
    return {
        /**
         * Starts a new export process for a Big Segment
         * @summary Create Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.createBigSegmentExport(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new import process for a Big Segment.
         * @summary Create Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info about a Big Segment export process.
         * @summary Get Big Segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: any): AxiosPromise<Export> {
            return localVarFp.getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info about a Big Segment import process.
         * @summary Get Big Segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: any): AxiosPromise<Import> {
            return localVarFp.getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsBetaApi - object-oriented interface
 * @export
 * @class SegmentsBetaApi
 * @extends {BaseAPI}
 */
export class SegmentsBetaApi extends BaseAPI {
    /**
     * Starts a new export process for a Big Segment
     * @summary Create Big Segment export
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).createBigSegmentExport(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new import process for a Big Segment.
     * @summary Create Big Segment import
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {any} [file] CSV file containing keys
     * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info about a Big Segment export process.
     * @summary Get Big Segment export
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} exportID The export ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info about a Big Segment import process.
     * @summary Get Big Segment import
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} importID The import ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (kind?: string, pre?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (pre !== undefined) {
                localVarQueryParameter['pre'] = pre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(kind?: string, pre?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(kind, pre, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(kind?: string, pre?: string, options?: any): AxiosPromise<TagCollection> {
            return localVarFp.getTags(kind, pre, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Get a list of tags.
     * @summary List tags
     * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
     * @param {string} [pre] Return tags with the specified prefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(kind?: string, pre?: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(kind, pre, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (teamKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('deleteTeam', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeam', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMaintainers: async (teamKey: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeamMaintainers', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/maintainers`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRoles: async (teamKey: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeamRoles', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/roles`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (limit?: number, offset?: number, filter?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs.  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs.  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### removePermissionGrants  Removes permission grants from members for the team. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam: async (teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('patchTeam', 'teamKey', teamKey)
            // verify required parameter 'teamPatchInput' is not null or undefined
            assertParamExists('patchTeam', 'teamPatchInput', teamPatchInput)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam: async (teamPostInput: TeamPostInput, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamPostInput' is not null or undefined
            assertParamExists('postTeam', 'teamPostInput', teamPostInput)
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad user input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"a-valid-email@launchdarkly.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@launchdarkly.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamMembers: async (teamKey: string, file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('postTeamMembers', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/members`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(teamKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(teamKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamMaintainers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamMaintainers(teamKey, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamCustomRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamRoles(teamKey, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(limit, offset, filter, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs.  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs.  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### removePermissionGrants  Removes permission grants from members for the team. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTeam(teamKey, teamPatchInput, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeam(teamPostInput: TeamPostInput, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeam(teamPostInput, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad user input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"a-valid-email@launchdarkly.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@launchdarkly.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeamMembers(teamKey: string, file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamImportsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeamMembers(teamKey, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeam(teamKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamKey: string, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.getTeam(teamKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: any): AxiosPromise<TeamMaintainers> {
            return localVarFp.getTeamMaintainers(teamKey, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: any): AxiosPromise<TeamCustomRoles> {
            return localVarFp.getTeamRoles(teamKey, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: any): AxiosPromise<Teams> {
            return localVarFp.getTeams(limit, offset, filter, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs.  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs.  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### removePermissionGrants  Removes permission grants from members for the team. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.patchTeam(teamKey, teamPatchInput, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam(teamPostInput: TeamPostInput, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.postTeam(teamPostInput, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad user input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"a-valid-email@launchdarkly.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@launchdarkly.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamMembers(teamKey: string, file?: any, options?: any): AxiosPromise<TeamImportsRep> {
            return localVarFp.postTeamMembers(teamKey, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
     * @summary Delete team
     * @param {string} teamKey The team key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(teamKey: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).deleteTeam(teamKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Get team
     * @param {string} teamKey The team key.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeam(teamKey: string, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeam(teamKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
     * @summary Get team maintainers
     * @param {string} teamKey The team key
     * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamMaintainers(teamKey, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
     * @summary Get team custom roles
     * @param {string} teamKey The team key
     * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamRoles(teamKey, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary List teams
     * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeams(limit, offset, filter, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs.  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs.  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### removePermissionGrants  Removes permission grants from members for the team. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Update team
     * @param {string} teamKey The team key
     * @param {TeamPatchInput} teamPatchInput 
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).patchTeam(teamKey, teamPatchInput, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Create team
     * @param {TeamPostInput} teamPostInput 
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public postTeam(teamPostInput: TeamPostInput, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).postTeam(teamPostInput, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad user input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"a-valid-email@launchdarkly.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@launchdarkly.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
     * @summary Add multiple members to team
     * @param {string} teamKey The team key
     * @param {any} [file] CSV file containing email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public postTeamMembers(teamKey: string, file?: any, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).postTeamMembers(teamKey, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsBetaApi - axios parameter creator
 * @export
 */
export const TeamsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are excluded from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeams: async (teamsPatchInput: TeamsPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamsPatchInput' is not null or undefined
            assertParamExists('patchTeams', 'teamsPatchInput', teamsPatchInput)
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamsPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsBetaApi - functional programming interface
 * @export
 */
export const TeamsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are excluded from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTeams(teamsPatchInput: TeamsPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkEditTeamsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTeams(teamsPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsBetaApi - factory interface
 * @export
 */
export const TeamsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsBetaApiFp(configuration)
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are excluded from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeams(teamsPatchInput: TeamsPatchInput, options?: any): AxiosPromise<BulkEditTeamsRep> {
            return localVarFp.patchTeams(teamsPatchInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsBetaApi - object-oriented interface
 * @export
 * @class TeamsBetaApi
 * @extends {BaseAPI}
 */
export class TeamsBetaApi extends BaseAPI {
    /**
     * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are excluded from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs. 
     * @summary Update teams
     * @param {TeamsPatchInput} teamsPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsBetaApi
     */
    public patchTeams(teamsPatchInput: TeamsPatchInput, options?: AxiosRequestConfig) {
        return TeamsBetaApiFp(this.configuration).patchTeams(teamsPatchInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringFlagsForUser: async (projectKey: string, userKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'projectKey', projectKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'userKey', userKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'userKey', userKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSettings: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled. 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringFlagsForUser: async (projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'projectKey', projectKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'userKey', userKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'environmentKey', environmentKey)
            // verify required parameter 'patchUsersRequest' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'patchUsersRequest', patchUsersRequest)
            const localVarPath = `/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagSetting', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('putFlagSetting', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('putFlagSetting', 'userKey', userKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('putFlagSetting', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'valuePut' is not null or undefined
            assertParamExists('putFlagSetting', 'valuePut', valuePut)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringFlagsForUser(projectKey, userKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFlagSettings(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled. 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSettingsApiFp(configuration)
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringFlagsForUser(projectKey, userKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: any): AxiosPromise<UserFlagSetting> {
            return localVarFp.getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserFlagSettings> {
            return localVarFp.getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled. 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: any): AxiosPromise<void> {
            return localVarFp.putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     * Get a list of flags for which the given user is scheduled for removal.
     * @summary Get expiring dates on flags for user
     * @param {string} projectKey The project key
     * @param {string} userKey The user key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getExpiringFlagsForUser(projectKey, userKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
     * @summary Get flag setting for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
     * @summary List flag settings for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  This request only supports semantic patches. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the flag variation to update. You can retrieve this by making a GET request for the flag.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled. 
     * @summary Update expiring user target for flags
     * @param {string} projectKey The project key
     * @param {string} userKey The user key
     * @param {string} environmentKey The environment key
     * @param {PatchUsersRequest} patchUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
     * @summary Update flag settings for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {string} featureFlagKey The feature flag key
     * @param {ValuePut} valuePut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user by key.
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteUser', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('deleteUser', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations).  > ### `offset` is deprecated > > `offset` is deprecated and will be removed in a future API version. You can still use `offset` and `limit` for pagination, but we recommend you use `sort` and `searchAfter` instead. `searchAfter` allows you to page through more than 10,000 users, but `offset` and `limit` do not. 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Specifies the first item to return in the collection
         * @param {number} [after] A unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUsers: async (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSearchUsers', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSearchUsers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/user-search/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchAfter !== undefined) {
                localVarQueryParameter['searchAfter'] = searchAfter;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key.
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUser', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUser', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUsers', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUsers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchAfter !== undefined) {
                localVarQueryParameter['searchAfter'] = searchAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a user by key.
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations).  > ### `offset` is deprecated > > `offset` is deprecated and will be removed in a future API version. You can still use `offset` and `limit` for pagination, but we recommend you use `sort` and `searchAfter` instead. `searchAfter` allows you to page through more than 10,000 users, but `offset` and `limit` do not. 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Specifies the first item to return in the collection
         * @param {number} [after] A unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key.
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(projectKey, environmentKey, limit, searchAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Delete a user by key.
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations).  > ### `offset` is deprecated > > `offset` is deprecated and will be removed in a future API version. You can still use `offset` and `limit` for pagination, but we recommend you use `sort` and `searchAfter` instead. `searchAfter` allows you to page through more than 10,000 users, but `offset` and `limit` do not. 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Specifies the first item to return in the collection
         * @param {number} [after] A unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: any): AxiosPromise<Users> {
            return localVarFp.getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key.
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserRecord> {
            return localVarFp.getUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: any): AxiosPromise<UsersRep> {
            return localVarFp.getUsers(projectKey, environmentKey, limit, searchAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Delete a user by key.
     * @summary Delete user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations).  > ### `offset` is deprecated > > `offset` is deprecated and will be removed in a future API version. You can still use `offset` and `limit` for pagination, but we recommend you use `sort` and `searchAfter` instead. `searchAfter` allows you to page through more than 10,000 users, but `offset` and `limit` do not. 
     * @summary Find users
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
     * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @param {number} [offset] Specifies the first item to return in the collection
     * @param {number} [after] A unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key.
     * @summary Get user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
     * @summary List users
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [limit] The number of elements to return per page
     * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(projectKey, environmentKey, limit, searchAfter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersBetaApi - axios parameter creator
 * @export
 */
export const UsersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days.
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAttributeNames: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserAttributeNames', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserAttributeNames', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/user-attributes/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersBetaApi - functional programming interface
 * @export
 */
export const UsersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days.
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAttributeNames(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAttributeNamesRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAttributeNames(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersBetaApi - factory interface
 * @export
 */
export const UsersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersBetaApiFp(configuration)
    return {
        /**
         * Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days.
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAttributeNames(projectKey: string, environmentKey: string, options?: any): AxiosPromise<UserAttributeNamesRep> {
            return localVarFp.getUserAttributeNames(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersBetaApi - object-oriented interface
 * @export
 * @class UsersBetaApi
 * @extends {BaseAPI}
 */
export class UsersBetaApi extends BaseAPI {
    /**
     * Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days.
     * @summary Get user attribute names
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersBetaApi
     */
    public getUserAttributeNames(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return UsersBetaApiFp(this.configuration).getUserAttributeNames(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the webhook.
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchWebhook', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchWebhook', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (webhookPost: WebhookPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookPost' is not null or undefined
            assertParamExists('postWebhook', 'webhookPost', webhookPost)
            const localVarPath = `/api/v2/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWebhooks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhooks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWebhooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the webhook.
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWebhook(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(webhookPost: WebhookPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhook(webhookPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(options?: any): AxiosPromise<Webhooks> {
            return localVarFp.getAllWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the webhook.
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Webhook> {
            return localVarFp.patchWebhook(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookPost: WebhookPost, options?: any): AxiosPromise<Webhook> {
            return localVarFp.postWebhook(webhookPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a webhook by ID.
     * @summary Delete webhook
     * @param {string} id The ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all webhooks.
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getAllWebhooks(options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getAllWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single webhook by ID.
     * @summary Get webhook
     * @param {string} id The ID of the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a webhook\'s settings. The request should be a valid JSON Patch document describing the changes to be made to the webhook.
     * @summary Update webhook
     * @param {string} id The ID of the webhook to update
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).patchWebhook(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new webhook.
     * @summary Creates a webhook
     * @param {WebhookPost} webhookPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhook(webhookPost: WebhookPost, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhook(webhookPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowTemplatesBetaApi - axios parameter creator
 * @export
 */
export const WorkflowTemplatesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate: async (createWorkflowTemplateInput: CreateWorkflowTemplateInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowTemplateInput' is not null or undefined
            assertParamExists('createWorkflowTemplate', 'createWorkflowTemplateInput', createWorkflowTemplateInput)
            const localVarPath = `/api/v2/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowTemplateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate: async (templateKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateKey' is not null or undefined
            assertParamExists('deleteWorkflowTemplate', 'templateKey', templateKey)
            const localVarPath = `/api/v2/templates/{templateKey}`
                .replace(`{${"templateKey"}}`, encodeURIComponent(String(templateKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplates: async (search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowTemplatesBetaApi - functional programming interface
 * @export
 */
export const WorkflowTemplatesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowTemplatesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowTemplate(createWorkflowTemplateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowTemplate(templateKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowTemplate(templateKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowTemplates(search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplatesListingOutputRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowTemplates(search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowTemplatesBetaApi - factory interface
 * @export
 */
export const WorkflowTemplatesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowTemplatesBetaApiFp(configuration)
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: any): AxiosPromise<WorkflowTemplateOutput> {
            return localVarFp.createWorkflowTemplate(createWorkflowTemplateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate(templateKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflowTemplate(templateKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplates(search?: string, options?: any): AxiosPromise<WorkflowTemplatesListingOutputRep> {
            return localVarFp.getWorkflowTemplates(search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowTemplatesBetaApi - object-oriented interface
 * @export
 * @class WorkflowTemplatesBetaApi
 * @extends {BaseAPI}
 */
export class WorkflowTemplatesBetaApi extends BaseAPI {
    /**
     * Create a template for a feature flag workflow
     * @summary Create workflow template
     * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesBetaApi
     */
    public createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: AxiosRequestConfig) {
        return WorkflowTemplatesBetaApiFp(this.configuration).createWorkflowTemplate(createWorkflowTemplateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow template
     * @summary Delete workflow template
     * @param {string} templateKey The template key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesBetaApi
     */
    public deleteWorkflowTemplate(templateKey: string, options?: AxiosRequestConfig) {
        return WorkflowTemplatesBetaApiFp(this.configuration).deleteWorkflowTemplate(templateKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
     * @summary Get workflow templates
     * @param {string} [search] The substring in either the name or description of a template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesBetaApi
     */
    public getWorkflowTemplates(search?: string, options?: AxiosRequestConfig) {
        return WorkflowTemplatesBetaApiFp(this.configuration).getWorkflowTemplates(search, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsBetaApi - axios parameter creator
 * @export
 */
export const WorkflowsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getCustomWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getWorkflows', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getWorkflows', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getWorkflows', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag on for 10% of users each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\",           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ```  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dry-run` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dry-run` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ```  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'customWorkflowInput' is not null or undefined
            assertParamExists('postWorkflow', 'customWorkflowInput', customWorkflowInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (templateKey !== undefined) {
                localVarQueryParameter['templateKey'] = templateKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customWorkflowInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsBetaApi - functional programming interface
 * @export
 */
export const WorkflowsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowsListingOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag on for 10% of users each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\",           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ```  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dry-run` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dry-run` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ```  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsBetaApi - factory interface
 * @export
 */
export const WorkflowsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsBetaApiFp(configuration)
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: any): AxiosPromise<CustomWorkflowOutput> {
            return localVarFp.getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<CustomWorkflowsListingOutput> {
            return localVarFp.getWorkflows(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag on for 10% of users each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\",           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ```  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dry-run` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dry-run` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ```  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, options?: any): AxiosPromise<CustomWorkflowOutput> {
            return localVarFp.postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsBetaApi - object-oriented interface
 * @export
 * @class WorkflowsBetaApi
 * @extends {BaseAPI}
 */
export class WorkflowsBetaApi extends BaseAPI {
    /**
     * Delete a workflow from a feature flag.
     * @summary Delete workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} workflowId The workflow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific workflow by ID.
     * @summary Get custom workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} workflowId The workflow ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Display workflows associated with a feature flag.
     * @summary Get workflows
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).getWorkflows(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag on for 10% of users each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\",           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ```  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dry-run` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dry-run` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ```  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
     * @summary Create workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {CustomWorkflowInput} customWorkflowInput 
     * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsBetaApi
     */
    public postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, options?: AxiosRequestConfig) {
        return WorkflowsBetaApiFp(this.configuration).postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, options).then((request) => request(this.axios, this.basePath));
    }
}


