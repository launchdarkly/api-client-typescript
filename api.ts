/* tslint:disable */
/* eslint-disable */
/**
 * LaunchDarkly REST API
 * # Overview  ## Authentication  LaunchDarkly\'s REST API uses the HTTPS protocol with a minimum TLS version of 1.2.  All REST API resources are authenticated with either [personal or service access tokens](https://docs.launchdarkly.com/home/account-security/api-access-tokens), or session cookies. Other authentication mechanisms are not supported. You can manage personal access tokens on your [**Account settings**](https://app.launchdarkly.com/settings/tokens) page.  LaunchDarkly also has SDK keys, mobile keys, and client-side IDs that are used by our server-side SDKs, mobile SDKs, and JavaScript-based SDKs, respectively. **These keys cannot be used to access our REST API**. These keys are environment-specific, and can only perform read-only operations such as fetching feature flag settings.  | Auth mechanism                                                                                  | Allowed resources                                                                                     | Use cases                                          | | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | -------------------------------------------------- | | [Personal or service access tokens](https://docs.launchdarkly.com/home/account-security/api-access-tokens) | Can be customized on a per-token basis                                                                | Building scripts, custom integrations, data export. | | SDK keys                                                                                        | Can only access read-only resources specific to server-side SDKs. Restricted to a single environment. | Server-side SDKs                     | | Mobile keys                                                                                     | Can only access read-only resources specific to mobile SDKs, and only for flags marked available to mobile keys. Restricted to a single environment.           | Mobile SDKs                                        | | Client-side ID                                                                                  | Can only access read-only resources specific to JavaScript-based client-side SDKs, and only for flags marked available to client-side. Restricted to a single environment.           | Client-side JavaScript                             |  > #### Keep your access tokens and SDK keys private > > Access tokens should _never_ be exposed in untrusted contexts. Never put an access token in client-side JavaScript, or embed it in a mobile application. LaunchDarkly has special mobile keys that you can embed in mobile apps. If you accidentally expose an access token or SDK key, you can reset it from your [**Account settings**](https://app.launchdarkly.com/settings/tokens) page. > > The client-side ID is safe to embed in untrusted contexts. It\'s designed for use in client-side JavaScript.  ### Authentication using request header  The preferred way to authenticate with the API is by adding an `Authorization` header containing your access token to your requests. The value of the `Authorization` header must be your access token.  Manage personal access tokens from the [**Account settings**](https://app.launchdarkly.com/settings/tokens) page.  ### Authentication using session cookie  For testing purposes, you can make API calls directly from your web browser. If you are logged in to the LaunchDarkly application, the API will use your existing session to authenticate calls.  If you have a [role](https://docs.launchdarkly.com/home/team/built-in-roles) other than Admin, or have a [custom role](https://docs.launchdarkly.com/home/team/custom-roles) defined, you may not have permission to perform some API calls. You will receive a `401` response code in that case.  > ### Modifying the Origin header causes an error > > LaunchDarkly validates that the Origin header for any API request authenticated by a session cookie matches the expected Origin header. The expected Origin header is `https://app.launchdarkly.com`. > > If the Origin header does not match what\'s expected, LaunchDarkly returns an error. This error can prevent the LaunchDarkly app from working correctly. > > Any browser extension that intentionally changes the Origin header can cause this problem. For example, the `Allow-Control-Allow-Origin: *` Chrome extension changes the Origin header to `http://evil.com` and causes the app to fail. > > To prevent this error, do not modify your Origin header. > > LaunchDarkly does not require origin matching when authenticating with an access token, so this issue does not affect normal API usage.  ## Representations  All resources expect and return JSON response bodies. Error responses also send a JSON body. To learn more about the error format of the API, read [Errors](/#section/Overview/Errors).  In practice this means that you always get a response with a `Content-Type` header set to `application/json`.  In addition, request bodies for `PATCH`, `POST`, and `PUT` requests must be encoded as JSON with a `Content-Type` header set to `application/json`.  ### Summary and detailed representations  When you fetch a list of resources, the response includes only the most important attributes of each resource. This is a _summary representation_ of the resource. When you fetch an individual resource, such as a single feature flag, you receive a _detailed representation_ of the resource.  The best way to find a detailed representation is to follow links. Every summary representation includes a link to its detailed representation.  ### Expanding responses  Sometimes the detailed representation of a resource does not include all of the attributes of the resource by default. If this is the case, the request method will clearly document this and describe which attributes you can include in an expanded response.  To include the additional attributes, append the `expand` request parameter to your request and add a comma-separated list of the attributes to include. For example, when you append `?expand=members,roles` to the [Get team](/tag/Teams#operation/getTeam) endpoint, the expanded response includes both of these attributes.  ### Links and addressability  The best way to navigate the API is by following links. These are attributes in representations that link to other resources. The API always uses the same format for links:  - Links to other resources within the API are encapsulated in a `_links` object - If the resource has a corresponding link to HTML content on the site, it is stored in a special `_site` link  Each link has two attributes:  - An `href`, which contains the URL - A `type`, which describes the content type  For example, a feature resource might return the following:  ```json {   \"_links\": {     \"parent\": {       \"href\": \"/api/features\",       \"type\": \"application/json\"     },     \"self\": {       \"href\": \"/api/features/sort.order\",       \"type\": \"application/json\"     }   },   \"_site\": {     \"href\": \"/features/sort.order\",     \"type\": \"text/html\"   } } ```  From this, you can navigate to the parent collection of features by following the `parent` link, or navigate to the site page for the feature by following the `_site` link.  Collections are always represented as a JSON object with an `items` attribute containing an array of representations. Like all other representations, collections have `_links` defined at the top level.  Paginated collections include `first`, `last`, `next`, and `prev` links containing a URL with the respective set of elements in the collection.  ## Updates  Resources that accept partial updates use the `PATCH` verb. Most resources support the [JSON patch](/reference#updates-using-json-patch) format. Some resources also support the [JSON merge patch](/reference#updates-using-json-merge-patch) format, and some resources support the [semantic patch](/reference#updates-using-semantic-patch) format, which is a way to specify the modifications to perform as a set of executable instructions. Each resource supports optional [comments](/reference#updates-with-comments) that you can submit with updates. Comments appear in outgoing webhooks, the audit log, and other integrations.  When a resource supports both JSON patch and semantic patch, we document both in the request method. However, the specific request body fields and descriptions included in our documentation only match one type of patch or the other.  ### Updates using JSON patch  [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) is a way to specify the modifications to perform on a resource. JSON patch uses paths and a limited set of operations to describe how to transform the current state of the resource into a new state. JSON patch documents are always arrays, where each element contains an operation, a path to the field to update, and the new value.  For example, in this feature flag representation:  ```json {     \"name\": \"New recommendations engine\",     \"key\": \"engine.enable\",     \"description\": \"This is the description\",     ... } ``` You can change the feature flag\'s description with the following patch document:  ```json [{ \"op\": \"replace\", \"path\": \"/description\", \"value\": \"This is the new description\" }] ```  You can specify multiple modifications to perform in a single request. You can also test that certain preconditions are met before applying the patch:  ```json [   { \"op\": \"test\", \"path\": \"/version\", \"value\": 10 },   { \"op\": \"replace\", \"path\": \"/description\", \"value\": \"The new description\" } ] ```  The above patch request tests whether the feature flag\'s `version` is `10`, and if so, changes the feature flag\'s description.  Attributes that are not editable, such as a resource\'s `_links`, have names that start with an underscore.  ### Updates using JSON merge patch  [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) is another format for specifying the modifications to perform on a resource. JSON merge patch is less expressive than JSON patch. However, in many cases it is simpler to construct a merge patch document. For example, you can change a feature flag\'s description with the following merge patch document:  ```json {   \"description\": \"New flag description\" } ```  ### Updates using semantic patch  Some resources support the semantic patch format. A semantic patch is a way to specify the modifications to perform on a resource as a set of executable instructions.  Semantic patch allows you to be explicit about intent using precise, custom instructions. In many cases, you can define semantic patch instructions independently of the current state of the resource. This can be useful when defining a change that may be applied at a future date.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header.  Here\'s how:  ``` Content-Type: application/json; domain-model=launchdarkly.semanticpatch ```  If you call a semantic patch resource without this header, you will receive a `400` response because your semantic patch will be interpreted as a JSON patch.  The body of a semantic patch request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some resources only) The environment key. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the instruction requires parameters, you must include those parameters as additional fields in the object. The documentation for each resource that supports semantic patch includes the available instructions and any additional parameters.  For example:  ```json {   \"comment\": \"optional comment\",   \"instructions\": [ {\"kind\": \"turnFlagOn\"} ] } ```  If any instruction in the patch encounters an error, the endpoint returns an error and will not change the resource. In general, each instruction silently does nothing if the resource is already in the state you request.  ### Updates with comments  You can submit optional comments with `PATCH` changes.  To submit a comment along with a JSON patch document, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"patch\": [{ \"op\": \"replace\", \"path\": \"/description\", \"value\": \"The new description\" }] } ```  To submit a comment along with a JSON merge patch document, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"merge\": { \"description\": \"New flag description\" } } ```  To submit a comment along with a semantic patch, use the following format:  ```json {   \"comment\": \"This is a comment string\",   \"instructions\": [ {\"kind\": \"turnFlagOn\"} ] } ```  ## Errors  The API always returns errors in a common format. Here\'s an example:  ```json {   \"code\": \"invalid_request\",   \"message\": \"A feature with that key already exists\",   \"id\": \"30ce6058-87da-11e4-b116-123b93f75cba\" } ```  The `code` indicates the general class of error. The `message` is a human-readable explanation of what went wrong. The `id` is a unique identifier. Use it when you\'re working with LaunchDarkly Support to debug a problem with a specific API call.  ### HTTP status error response codes  | Code | Definition        | Description                                                                                       | Possible Solution                                                | | ---- | ----------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | | 400  | Invalid request       | The request cannot be understood.                                    | Ensure JSON syntax in request body is correct.                   | | 401  | Invalid access token      | Requestor is unauthorized or does not have permission for this API call.                                                | Ensure your API access token is valid and has the appropriate permissions.                                     | | 403  | Forbidden         | Requestor does not have access to this resource.                                                | Ensure that the account member or access token has proper permissions set. | | 404  | Invalid resource identifier | The requested resource is not valid. | Ensure that the resource is correctly identified by ID or key. | | 405  | Method not allowed | The request method is not allowed on this resource. | Ensure that the HTTP verb is correct. | | 409  | Conflict          | The API request can not be completed because it conflicts with a concurrent API request. | Retry your request.                                              | | 422  | Unprocessable entity | The API request can not be completed because the update description can not be understood. | Ensure that the request body is correct for the type of patch you are using, either JSON patch or semantic patch. | 429  | Too many requests | Read [Rate limiting](/#section/Overview/Rate-limiting).                                               | Wait and try again later.                                        |  ## CORS  The LaunchDarkly API supports Cross Origin Resource Sharing (CORS) for AJAX requests from any origin. If an `Origin` header is given in a request, it will be echoed as an explicitly allowed origin. Otherwise the request returns a wildcard, `Access-Control-Allow-Origin: *`. For more information on CORS, read the [CORS W3C Recommendation](http://www.w3.org/TR/cors). Example CORS headers might look like:  ```http Access-Control-Allow-Headers: Accept, Content-Type, Content-Length, Accept-Encoding, Authorization Access-Control-Allow-Methods: OPTIONS, GET, DELETE, PATCH Access-Control-Allow-Origin: * Access-Control-Max-Age: 300 ```  You can make authenticated CORS calls just as you would make same-origin calls, using either [token or session-based authentication](/#section/Overview/Authentication). If you are using session authentication, you should set the `withCredentials` property for your `xhr` request to `true`. You should never expose your access tokens to untrusted entities.  ## Rate limiting  We use several rate limiting strategies to ensure the availability of our APIs. Rate-limited calls to our APIs return a `429` status code. Calls to our APIs include headers indicating the current rate limit status. The specific headers returned depend on the API route being called. The limits differ based on the route, authentication mechanism, and other factors. Routes that are not rate limited may not contain any of the headers described below.  > ### Rate limiting and SDKs > > LaunchDarkly SDKs are never rate limited and do not use the API endpoints defined here. LaunchDarkly uses a different set of approaches, including streaming/server-sent events and a global CDN, to ensure availability to the routes used by LaunchDarkly SDKs.  ### Global rate limits  Authenticated requests are subject to a global limit. This is the maximum number of calls that your account can make to the API per ten seconds. All service and personal access tokens on the account share this limit, so exceeding the limit with one access token will impact other tokens. Calls that are subject to global rate limits may return the headers below:  | Header name                    | Description                                                                      | | ------------------------------ | -------------------------------------------------------------------------------- | | `X-Ratelimit-Global-Remaining` | The maximum number of requests the account is permitted to make per ten seconds. | | `X-Ratelimit-Reset`            | The time at which the current rate limit window resets in epoch milliseconds.    |  We do not publicly document the specific number of calls that can be made globally. This limit may change, and we encourage clients to program against the specification, relying on the two headers defined above, rather than hardcoding to the current limit.  ### Route-level rate limits  Some authenticated routes have custom rate limits. These also reset every ten seconds. Any service or personal access tokens hitting the same route share this limit, so exceeding the limit with one access token may impact other tokens. Calls that are subject to route-level rate limits return the headers below:  | Header name                   | Description                                                                                           | | ----------------------------- | ----------------------------------------------------------------------------------------------------- | | `X-Ratelimit-Route-Remaining` | The maximum number of requests to the current route the account is permitted to make per ten seconds. | | `X-Ratelimit-Reset`           | The time at which the current rate limit window resets in epoch milliseconds.                         |  A _route_ represents a specific URL pattern and verb. For example, the [Delete environment](/tag/Environments#operation/deleteEnvironment) endpoint is considered a single route, and each call to delete an environment counts against your route-level rate limit for that route.  We do not publicly document the specific number of calls that an account can make to each endpoint per ten seconds. These limits may change, and we encourage clients to program against the specification, relying on the two headers defined above, rather than hardcoding to the current limits.  ### IP-based rate limiting  We also employ IP-based rate limiting on some API routes. If you hit an IP-based rate limit, your API response will include a `Retry-After` header indicating how long to wait before re-trying the call. Clients must wait at least `Retry-After` seconds before making additional calls to our API, and should employ jitter and backoff strategies to avoid triggering rate limits again.  ## OpenAPI (Swagger) and client libraries  We have a [complete OpenAPI (Swagger) specification](https://app.launchdarkly.com/api/v2/openapi.json) for our API.  We auto-generate multiple client libraries based on our OpenAPI specification. To learn more, visit the [collection of client libraries on GitHub](https://github.com/search?q=topic%3Alaunchdarkly-api+org%3Alaunchdarkly&type=Repositories). You can also use this specification to generate client libraries to interact with our REST API in your language of choice.  Our OpenAPI specification is supported by several API-based tools such as Postman and Insomnia. In many cases, you can directly import our specification to explore our APIs.  ## Method overriding  Some firewalls and HTTP clients restrict the use of verbs other than `GET` and `POST`. In those environments, our API endpoints that use `DELETE`, `PATCH`, and `PUT` verbs are inaccessible.  To avoid this issue, our API supports the `X-HTTP-Method-Override` header, allowing clients to \"tunnel\" `DELETE`, `PATCH`, and `PUT` requests using a `POST` request.  For example, to call a `PATCH` endpoint using a `POST` request, you can include `X-HTTP-Method-Override:PATCH` as a header.  ## Beta resources  We sometimes release new API resources in **beta** status before we release them with general availability.  Resources that are in beta are still undergoing testing and development. They may change without notice, including becoming backwards incompatible.  We try to promote resources into general availability as quickly as possible. This happens after sufficient testing and when we\'re satisfied that we no longer need to make backwards-incompatible changes.  We mark beta resources with a \"Beta\" callout in our documentation, pictured below:  > ### This feature is in beta > > To use this feature, pass in a header including the `LD-API-Version` key with value set to `beta`. Use this header with each call. To learn more, read [Beta resources](/#section/Overview/Beta-resources). > > Resources that are in beta are still undergoing testing and development. They may change without notice, including becoming backwards incompatible.  ### Using beta resources  To use a beta resource, you must include a header in the request. If you call a beta resource without this header, you receive a `403` response.  Use this header:  ``` LD-API-Version: beta ```  ## Federal environments  The version of LaunchDarkly that is available on domains controlled by the United States government is different from the version of LaunchDarkly available to the general public. If you are an employee or contractor for a United States federal agency and use LaunchDarkly in your work, you likely use the federal instance of LaunchDarkly.  If you are working in the federal instance of LaunchDarkly, the base URI for each request is `https://app.launchdarkly.us`. In the \"Try it\" sandbox for each request, click the request path to view the complete resource path for the federal environment.  To learn more, read [LaunchDarkly in federal environments](https://docs.launchdarkly.com/home/advanced/federal).  ## Versioning  We try hard to keep our REST API backwards compatible, but we occasionally have to make backwards-incompatible changes in the process of shipping new features. These breaking changes can cause unexpected behavior if you don\'t prepare for them accordingly.  Updates to our REST API include support for the latest features in LaunchDarkly. We also release a new version of our REST API every time we make a breaking change. We provide simultaneous support for multiple API versions so you can migrate from your current API version to a new version at your own pace.  ### Setting the API version per request  You can set the API version on a specific request by sending an `LD-API-Version` header, as shown in the example below:  ``` LD-API-Version: 20220603 ```  The header value is the version number of the API version you would like to request. The number for each version corresponds to the date the version was released in `yyyymmdd` format. In the example above the version `20220603` corresponds to June 03, 2022.  ### Setting the API version per access token  When you create an access token, you must specify a specific version of the API to use. This ensures that integrations using this token cannot be broken by version changes.  Tokens created before versioning was released have their version set to `20160426`, which is the version of the API that existed before the current versioning scheme, so that they continue working the same way they did before versioning.  If you would like to upgrade your integration to use a new API version, you can explicitly set the header described above.  > ### Best practice: Set the header for every client or integration > > We recommend that you set the API version header explicitly in any client or integration you build. > > Only rely on the access token API version during manual testing.  ### API version changelog  |<div style=\"width:75px\">Version</div> | Changes | End of life (EOL) |---|---|---| | `20220603` | <ul><li>Changed the [list projects](/tag/Projects#operation/getProjects) return value:<ul><li>Response is now paginated with a default limit of `20`.</li><li>Added support for filter and sort.</li><li>The project `environments` field is now expandable. This field is omitted by default.</li></ul></li><li>Changed the [get project](/tag/Projects#operation/getProject) return value:<ul><li>The `environments` field is now expandable. This field is omitted by default.</li></ul></li></ul> | Current | | `20210729` | <ul><li>Changed the [create approval request](/tag/Approvals#operation/postApprovalRequest) return value. It now returns HTTP Status Code `201` instead of `200`.</li><li> Changed the [get users](/tag/Users#operation/getUser) return value. It now returns a user record, not a user. </li><li>Added additional optional fields to environment, segments, flags, members, and segments, including the ability to create big segments. </li><li> Added default values for flag variations when new environments are created. </li><li>Added filtering and pagination for getting flags and members, including `limit`, `number`, `filter`, and `sort` query parameters. </li><li>Added endpoints for expiring user targets for flags and segments, scheduled changes, access tokens, Relay Proxy configuration, integrations and subscriptions, and approvals. </li></ul> | 2023-06-03 | | `20191212` | <ul><li>[List feature flags](/tag/Feature-flags#operation/getFeatureFlags) now defaults to sending summaries of feature flag configurations, equivalent to setting the query parameter `summary=true`. Summaries omit flag targeting rules and individual user targets from the payload. </li><li> Added endpoints for flags, flag status, projects, environments, audit logs, members, users, custom roles, segments, usage, streams, events, and data export. </li></ul> | 2022-07-29 | | `20160426` | <ul><li>Initial versioning of API. Tokens created before versioning have their version set to this.</li></ul> | 2020-12-12 | 
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<AccessDenied>}
     * @memberof Access
     */
    'denied': Array<AccessDenied>;
    /**
     * 
     * @type {Array<AccessAllowedRep>}
     * @memberof Access
     */
    'allowed': Array<AccessAllowedRep>;
}
/**
 * 
 * @export
 * @interface AccessAllowedReason
 */
export interface AccessAllowedReason {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessAllowedReason
     */
    'notActions'?: Array<string>;
    /**
     * Whether this statement should allow or deny actions on the resources.
     * @type {string}
     * @memberof AccessAllowedReason
     */
    'effect': AccessAllowedReasonEffectEnum;
    /**
     * 
     * @type {string}
     * @memberof AccessAllowedReason
     */
    'role_name'?: string;
}

export const AccessAllowedReasonEffectEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type AccessAllowedReasonEffectEnum = typeof AccessAllowedReasonEffectEnum[keyof typeof AccessAllowedReasonEffectEnum];

/**
 * 
 * @export
 * @interface AccessAllowedRep
 */
export interface AccessAllowedRep {
    /**
     * 
     * @type {string}
     * @memberof AccessAllowedRep
     */
    'action': string;
    /**
     * 
     * @type {AccessAllowedReason}
     * @memberof AccessAllowedRep
     */
    'reason': AccessAllowedReason;
}
/**
 * 
 * @export
 * @interface AccessDenied
 */
export interface AccessDenied {
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'action': string;
    /**
     * 
     * @type {AccessDeniedReason}
     * @memberof AccessDenied
     */
    'reason': AccessDeniedReason;
}
/**
 * 
 * @export
 * @interface AccessDeniedReason
 */
export interface AccessDeniedReason {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof AccessDeniedReason
     */
    'notActions'?: Array<string>;
    /**
     * Whether this statement should allow or deny actions on the resources.
     * @type {string}
     * @memberof AccessDeniedReason
     */
    'effect': AccessDeniedReasonEffectEnum;
    /**
     * 
     * @type {string}
     * @memberof AccessDeniedReason
     */
    'role_name'?: string;
}

export const AccessDeniedReasonEffectEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type AccessDeniedReasonEffectEnum = typeof AccessDeniedReasonEffectEnum[keyof typeof AccessDeniedReasonEffectEnum];

/**
 * 
 * @export
 * @interface AccessTokenPost
 */
export interface AccessTokenPost {
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'name'?: string;
    /**
     * A description for the access token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'description'?: string;
    /**
     * Built-in role for the token
     * @type {string}
     * @memberof AccessTokenPost
     */
    'role'?: AccessTokenPostRoleEnum;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof AccessTokenPost
     */
    'customRoleIds'?: Array<string>;
    /**
     * A JSON array of statements represented as JSON objects with three attributes: effect, resources, actions. May be used in place of a built-in or custom role.
     * @type {Array<StatementPost>}
     * @memberof AccessTokenPost
     */
    'inlineRole'?: Array<StatementPost>;
    /**
     * Whether the token is a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
     * @type {boolean}
     * @memberof AccessTokenPost
     */
    'serviceToken'?: boolean;
    /**
     * The default API version for this token
     * @type {number}
     * @memberof AccessTokenPost
     */
    'defaultApiVersion'?: number;
}

export const AccessTokenPostRoleEnum = {
    Reader: 'reader',
    Writer: 'writer',
    Admin: 'admin'
} as const;

export type AccessTokenPostRoleEnum = typeof AccessTokenPostRoleEnum[keyof typeof AccessTokenPostRoleEnum];

/**
 * 
 * @export
 * @interface ActionInput
 */
export interface ActionInput {
    /**
     * An array of instructions for the stage. Each object in the array uses the semantic patch format for updating a feature flag.
     * @type {any}
     * @memberof ActionInput
     */
    'instructions'?: any;
}
/**
 * 
 * @export
 * @interface ActionOutput
 */
export interface ActionOutput {
    /**
     * The type of action for this stage
     * @type {string}
     * @memberof ActionOutput
     */
    'kind': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ActionOutput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface ApplicationCollectionRep
 */
export interface ApplicationCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ApplicationCollectionRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A list of applications
     * @type {Array<ApplicationRep>}
     * @memberof ApplicationCollectionRep
     */
    'items'?: Array<ApplicationRep>;
    /**
     * The number of applications
     * @type {number}
     * @memberof ApplicationCollectionRep
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationFlagCollectionRep
 */
export interface ApplicationFlagCollectionRep {
    /**
     * A list of the flags that have been evaluated by the application
     * @type {Array<FlagListingRep>}
     * @memberof ApplicationFlagCollectionRep
     */
    'items'?: Array<FlagListingRep>;
    /**
     * The number of flags that have been evaluated by the application
     * @type {number}
     * @memberof ApplicationFlagCollectionRep
     */
    'totalCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ApplicationFlagCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ApplicationRep
 */
export interface ApplicationRep {
    /**
     * 
     * @type {ApplicationFlagCollectionRep}
     * @memberof ApplicationRep
     */
    'flags'?: ApplicationFlagCollectionRep;
    /**
     * 
     * @type {Access}
     * @memberof ApplicationRep
     */
    '_access'?: Access;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ApplicationRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * Version of the application
     * @type {number}
     * @memberof ApplicationRep
     */
    '_version'?: number;
    /**
     * Whether the application was automatically created because it was included in a context when a LaunchDarkly SDK evaluated a feature flag, or was created through the LaunchDarkly UI or REST API.
     * @type {boolean}
     * @memberof ApplicationRep
     */
    'autoAdded': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationRep
     */
    'creationDate'?: number;
    /**
     * The application description
     * @type {string}
     * @memberof ApplicationRep
     */
    'description'?: string;
    /**
     * The unique identifier of this application
     * @type {string}
     * @memberof ApplicationRep
     */
    'key': string;
    /**
     * To distinguish the kind of application
     * @type {string}
     * @memberof ApplicationRep
     */
    'kind': ApplicationRepKindEnum;
    /**
     * 
     * @type {MaintainerRep}
     * @memberof ApplicationRep
     */
    '_maintainer'?: MaintainerRep;
    /**
     * The name of the application
     * @type {string}
     * @memberof ApplicationRep
     */
    'name': string;
}

export const ApplicationRepKindEnum = {
    Browser: 'browser',
    Mobile: 'mobile',
    Server: 'server'
} as const;

export type ApplicationRepKindEnum = typeof ApplicationRepKindEnum[keyof typeof ApplicationRepKindEnum];

/**
 * 
 * @export
 * @interface ApplicationVersionRep
 */
export interface ApplicationVersionRep {
    /**
     * 
     * @type {Access}
     * @memberof ApplicationVersionRep
     */
    '_access'?: Access;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ApplicationVersionRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * Version of the application version
     * @type {number}
     * @memberof ApplicationVersionRep
     */
    '_version'?: number;
    /**
     * Whether the application version was automatically created, because it was included in a context when a LaunchDarkly SDK evaluated a feature flag, or if the application version was created through the LaunchDarkly UI or REST API. 
     * @type {boolean}
     * @memberof ApplicationVersionRep
     */
    'autoAdded': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationVersionRep
     */
    'creationDate'?: number;
    /**
     * The unique identifier of this application version
     * @type {string}
     * @memberof ApplicationVersionRep
     */
    'key': string;
    /**
     * The name of this version
     * @type {string}
     * @memberof ApplicationVersionRep
     */
    'name': string;
    /**
     * Whether this version is supported. Only applicable if the application <code>kind</code> is <code>mobile</code>.
     * @type {boolean}
     * @memberof ApplicationVersionRep
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationVersionsCollectionRep
 */
export interface ApplicationVersionsCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ApplicationVersionsCollectionRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A list of the versions for this application
     * @type {Array<ApplicationVersionRep>}
     * @memberof ApplicationVersionsCollectionRep
     */
    'items'?: Array<ApplicationVersionRep>;
    /**
     * The number of versions for this application
     * @type {number}
     * @memberof ApplicationVersionsCollectionRep
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ApprovalRequestResponse
 */
export interface ApprovalRequestResponse {
    /**
     * The ID of this approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    '_id': string;
    /**
     * Version of the approval request
     * @type {number}
     * @memberof ApprovalRequestResponse
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ApprovalRequestResponse
     */
    'creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'serviceKind': string;
    /**
     * The ID of the member who requested the approval
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'requestorId'?: string;
    /**
     * A human-friendly name for the approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'description'?: string;
    /**
     * Current status of the review of this approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'reviewStatus': ApprovalRequestResponseReviewStatusEnum;
    /**
     * An array of individual reviews of this approval request
     * @type {Array<ReviewResponse>}
     * @memberof ApprovalRequestResponse
     */
    'allReviews': Array<ReviewResponse>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof ApprovalRequestResponse
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ApprovalRequestResponse
     */
    'appliedDate'?: number;
    /**
     * The member ID of the member who applied the approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'appliedByMemberId'?: string;
    /**
     * The service token ID of the service token which applied the approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'appliedByServiceTokenId'?: string;
    /**
     * Current status of the approval request
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'status': ApprovalRequestResponseStatusEnum;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ApprovalRequestResponse
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting approval requests
     * @type {Array<Conflict>}
     * @memberof ApprovalRequestResponse
     */
    'conflicts': Array<Conflict>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof ApprovalRequestResponse
     */
    '_links': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ApprovalRequestResponse
     */
    'executionDate'?: number;
    /**
     * ID of scheduled change to edit or delete
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof ApprovalRequestResponse
     */
    'integrationMetadata'?: IntegrationMetadata;
    /**
     * 
     * @type {CopiedFromEnv}
     * @memberof ApprovalRequestResponse
     */
    'source'?: CopiedFromEnv;
    /**
     * 
     * @type {CustomWorkflowMeta}
     * @memberof ApprovalRequestResponse
     */
    'customWorkflowMetadata'?: CustomWorkflowMeta;
    /**
     * String representation of a resource
     * @type {string}
     * @memberof ApprovalRequestResponse
     */
    'resourceId'?: string;
    /**
     * 
     * @type {ApprovalSettings}
     * @memberof ApprovalRequestResponse
     */
    'approvalSettings'?: ApprovalSettings;
}

export const ApprovalRequestResponseReviewStatusEnum = {
    Approved: 'approved',
    Declined: 'declined',
    Pending: 'pending'
} as const;

export type ApprovalRequestResponseReviewStatusEnum = typeof ApprovalRequestResponseReviewStatusEnum[keyof typeof ApprovalRequestResponseReviewStatusEnum];
export const ApprovalRequestResponseStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed',
    Scheduled: 'scheduled'
} as const;

export type ApprovalRequestResponseStatusEnum = typeof ApprovalRequestResponseStatusEnum[keyof typeof ApprovalRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApprovalSettings
 */
export interface ApprovalSettings {
    /**
     * If approvals are required for this environment
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'required': boolean;
    /**
     * Whether to skip approvals for pending changes
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'bypassApprovalsForPendingChanges': boolean;
    /**
     * Sets the amount of approvals required before a member can apply a change. The minimum is one and the maximum is five.
     * @type {number}
     * @memberof ApprovalSettings
     */
    'minNumApprovals': number;
    /**
     * Allow someone who makes an approval request to apply their own change
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'canReviewOwnRequest': boolean;
    /**
     * Allow applying the change as long as at least one person has approved
     * @type {boolean}
     * @memberof ApprovalSettings
     */
    'canApplyDeclinedChanges': boolean;
    /**
     * Which service to use for managing approvals
     * @type {string}
     * @memberof ApprovalSettings
     */
    'serviceKind': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApprovalSettings
     */
    'serviceConfig': { [key: string]: any; };
    /**
     * Require approval only on flags with the provided tags. Otherwise all flags will require approval.
     * @type {Array<string>}
     * @memberof ApprovalSettings
     */
    'requiredApprovalTags': Array<string>;
}
/**
 * 
 * @export
 * @interface Audience
 */
export interface Audience {
    /**
     * 
     * @type {EnvironmentSummary}
     * @memberof Audience
     */
    'environment': EnvironmentSummary;
    /**
     * The release phase name
     * @type {string}
     * @memberof Audience
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AudiencePost
 */
export interface AudiencePost {
    /**
     * A project-unique key for the environment.
     * @type {string}
     * @memberof AudiencePost
     */
    'environmentKey': string;
    /**
     * The audience name
     * @type {string}
     * @memberof AudiencePost
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AuditLogEntryListingRep
 */
export interface AuditLogEntryListingRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryListingRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    '_id': string;
    /**
     * The ID of the account to which this audit log entry belongs
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    '_accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntryListingRep
     */
    'date': number;
    /**
     * Details on the actions performed and resources acted on in this audit log entry
     * @type {Array<ResourceAccess>}
     * @memberof AuditLogEntryListingRep
     */
    'accesses': Array<ResourceAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'kind': string;
    /**
     * The name of the resource this audit log entry refers to
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'name': string;
    /**
     * Description of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'description': string;
    /**
     * Shorter version of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'shortDescription': string;
    /**
     * Optional comment for the audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'comment'?: string;
    /**
     * 
     * @type {SubjectDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'subject'?: SubjectDataRep;
    /**
     * 
     * @type {MemberDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'member'?: MemberDataRep;
    /**
     * 
     * @type {TokenSummary}
     * @memberof AuditLogEntryListingRep
     */
    'token'?: TokenSummary;
    /**
     * 
     * @type {AuthorizedAppDataRep}
     * @memberof AuditLogEntryListingRep
     */
    'app'?: AuthorizedAppDataRep;
    /**
     * The action and resource recorded in this audit log entry
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'titleVerb'?: string;
    /**
     * A description of what occurred, in the format <code>member</code> <code>titleVerb</code> <code>target</code>
     * @type {string}
     * @memberof AuditLogEntryListingRep
     */
    'title'?: string;
    /**
     * 
     * @type {TargetResourceRep}
     * @memberof AuditLogEntryListingRep
     */
    'target'?: TargetResourceRep;
    /**
     * 
     * @type {ParentResourceRep}
     * @memberof AuditLogEntryListingRep
     */
    'parent'?: ParentResourceRep;
}
/**
 * 
 * @export
 * @interface AuditLogEntryListingRepCollection
 */
export interface AuditLogEntryListingRepCollection {
    /**
     * An array of audit log entries
     * @type {Array<AuditLogEntryListingRep>}
     * @memberof AuditLogEntryListingRepCollection
     */
    'items': Array<AuditLogEntryListingRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryListingRepCollection
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface AuditLogEntryRep
 */
export interface AuditLogEntryRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof AuditLogEntryRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    '_id': string;
    /**
     * The ID of the account to which this audit log entry belongs
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    '_accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntryRep
     */
    'date': number;
    /**
     * Details on the actions performed and resources acted on in this audit log entry
     * @type {Array<ResourceAccess>}
     * @memberof AuditLogEntryRep
     */
    'accesses': Array<ResourceAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'kind': string;
    /**
     * The name of the resource this audit log entry refers to
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'name': string;
    /**
     * Description of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'description': string;
    /**
     * Shorter version of the change recorded in the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'shortDescription': string;
    /**
     * Optional comment for the audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'comment'?: string;
    /**
     * 
     * @type {SubjectDataRep}
     * @memberof AuditLogEntryRep
     */
    'subject'?: SubjectDataRep;
    /**
     * 
     * @type {MemberDataRep}
     * @memberof AuditLogEntryRep
     */
    'member'?: MemberDataRep;
    /**
     * 
     * @type {TokenSummary}
     * @memberof AuditLogEntryRep
     */
    'token'?: TokenSummary;
    /**
     * 
     * @type {AuthorizedAppDataRep}
     * @memberof AuditLogEntryRep
     */
    'app'?: AuthorizedAppDataRep;
    /**
     * The action and resource recorded in this audit log entry
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'titleVerb'?: string;
    /**
     * A description of what occurred, in the format <code>member</code> <code>titleVerb</code> <code>target</code>
     * @type {string}
     * @memberof AuditLogEntryRep
     */
    'title'?: string;
    /**
     * 
     * @type {TargetResourceRep}
     * @memberof AuditLogEntryRep
     */
    'target'?: TargetResourceRep;
    /**
     * 
     * @type {ParentResourceRep}
     * @memberof AuditLogEntryRep
     */
    'parent'?: ParentResourceRep;
    /**
     * If the audit log entry has been updated, this is the JSON patch body that was used in the request to update the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'delta'?: any;
    /**
     * A JSON representation of the external trigger for this audit log entry, if any
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'triggerBody'?: any;
    /**
     * A JSON representation of the merge information for this audit log entry, if any
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'merge'?: any;
    /**
     * If the audit log entry has been updated, this is a JSON representation of the previous version of the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'previousVersion'?: any;
    /**
     * If the audit log entry has been updated, this is a JSON representation of the current version of the entity
     * @type {any}
     * @memberof AuditLogEntryRep
     */
    'currentVersion'?: any;
    /**
     * 
     * @type {Array<AuditLogEntryListingRep>}
     * @memberof AuditLogEntryRep
     */
    'subentries'?: Array<AuditLogEntryListingRep>;
}
/**
 * 
 * @export
 * @interface AuthorizedAppDataRep
 */
export interface AuthorizedAppDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof AuthorizedAppDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The ID of the authorized application
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    '_id'?: string;
    /**
     * Whether the application is authorized through SCIM
     * @type {boolean}
     * @memberof AuthorizedAppDataRep
     */
    'isScim'?: boolean;
    /**
     * The authorized application name
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    'name'?: string;
    /**
     * The name of the maintainer for this authorized application
     * @type {string}
     * @memberof AuthorizedAppDataRep
     */
    'maintainerName'?: string;
}
/**
 * 
 * @export
 * @interface BigSegmentStoreIntegration
 */
export interface BigSegmentStoreIntegration {
    /**
     * 
     * @type {BigSegmentStoreIntegrationLinks}
     * @memberof BigSegmentStoreIntegration
     */
    '_links': BigSegmentStoreIntegrationLinks;
    /**
     * The integration ID
     * @type {string}
     * @memberof BigSegmentStoreIntegration
     */
    '_id': string;
    /**
     * The integration key
     * @type {string}
     * @memberof BigSegmentStoreIntegration
     */
    'integrationKey': BigSegmentStoreIntegrationIntegrationKeyEnum;
    /**
     * The project key
     * @type {string}
     * @memberof BigSegmentStoreIntegration
     */
    'projectKey': string;
    /**
     * The environment key
     * @type {string}
     * @memberof BigSegmentStoreIntegration
     */
    'environmentKey': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BigSegmentStoreIntegration
     */
    'config': { [key: string]: any; };
    /**
     * Whether the configuration is turned on
     * @type {boolean}
     * @memberof BigSegmentStoreIntegration
     */
    'on': boolean;
    /**
     * List of tags for this configuration
     * @type {Array<string>}
     * @memberof BigSegmentStoreIntegration
     */
    'tags': Array<string>;
    /**
     * Name of the configuration
     * @type {string}
     * @memberof BigSegmentStoreIntegration
     */
    'name': string;
    /**
     * Version of the current configuration
     * @type {number}
     * @memberof BigSegmentStoreIntegration
     */
    'version': number;
    /**
     * 
     * @type {Access}
     * @memberof BigSegmentStoreIntegration
     */
    '_access'?: Access;
    /**
     * 
     * @type {BigSegmentStoreStatus}
     * @memberof BigSegmentStoreIntegration
     */
    '_status': BigSegmentStoreStatus;
}

export const BigSegmentStoreIntegrationIntegrationKeyEnum = {
    Redis: 'redis',
    Dynamodb: 'dynamodb'
} as const;

export type BigSegmentStoreIntegrationIntegrationKeyEnum = typeof BigSegmentStoreIntegrationIntegrationKeyEnum[keyof typeof BigSegmentStoreIntegrationIntegrationKeyEnum];

/**
 * 
 * @export
 * @interface BigSegmentStoreIntegrationCollection
 */
export interface BigSegmentStoreIntegrationCollection {
    /**
     * 
     * @type {BigSegmentStoreIntegrationCollectionLinks}
     * @memberof BigSegmentStoreIntegrationCollection
     */
    '_links': BigSegmentStoreIntegrationCollectionLinks;
    /**
     * An array of persistent store integration configurations
     * @type {Array<BigSegmentStoreIntegration>}
     * @memberof BigSegmentStoreIntegrationCollection
     */
    'items': Array<BigSegmentStoreIntegration>;
}
/**
 * 
 * @export
 * @interface BigSegmentStoreIntegrationCollectionLinks
 */
export interface BigSegmentStoreIntegrationCollectionLinks {
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationCollectionLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationCollectionLinks
     */
    'parent'?: Link;
}
/**
 * 
 * @export
 * @interface BigSegmentStoreIntegrationLinks
 */
export interface BigSegmentStoreIntegrationLinks {
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationLinks
     */
    'parent': Link;
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationLinks
     */
    'project': Link;
    /**
     * 
     * @type {Link}
     * @memberof BigSegmentStoreIntegrationLinks
     */
    'environment': Link;
}
/**
 * 
 * @export
 * @interface BigSegmentStoreStatus
 */
export interface BigSegmentStoreStatus {
    /**
     * Whether the persistent store integration is fully synchronized with the LaunchDarkly environment, and the <code>lastSync</code> occurred within a few minutes
     * @type {boolean}
     * @memberof BigSegmentStoreStatus
     */
    'available'?: boolean;
    /**
     * Whether the persistent store integration may not be fully synchronized with the LaunchDarkly environment. <code>true</code> if the integration could be stale.
     * @type {boolean}
     * @memberof BigSegmentStoreStatus
     */
    'potentiallyStale'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BigSegmentStoreStatus
     */
    'lastSync'?: number;
    /**
     * 
     * @type {number}
     * @memberof BigSegmentStoreStatus
     */
    'lastError'?: number;
    /**
     * 
     * @type {Array<StoreIntegrationError>}
     * @memberof BigSegmentStoreStatus
     */
    'errors'?: Array<StoreIntegrationError>;
}
/**
 * 
 * @export
 * @interface BigSegmentTarget
 */
export interface BigSegmentTarget {
    /**
     * The target key
     * @type {string}
     * @memberof BigSegmentTarget
     */
    'userKey': string;
    /**
     * Indicates whether the target is included.<br />Included targets are always segment members, regardless of segment rules.
     * @type {boolean}
     * @memberof BigSegmentTarget
     */
    'included': boolean;
    /**
     * Indicates whether the target is excluded.<br />Segment rules bypass excluded targets, so they will never be included based on rules. Excluded targets may still be included explicitly.
     * @type {boolean}
     * @memberof BigSegmentTarget
     */
    'excluded': boolean;
}
/**
 * 
 * @export
 * @interface BooleanDefaults
 */
export interface BooleanDefaults {
    /**
     * The display name for the true variation, displayed in the LaunchDarkly user interface
     * @type {string}
     * @memberof BooleanDefaults
     */
    'trueDisplayName'?: string;
    /**
     * The display name for the false variation, displayed in the LaunchDarkly user interface
     * @type {string}
     * @memberof BooleanDefaults
     */
    'falseDisplayName'?: string;
    /**
     * The description for the true variation
     * @type {string}
     * @memberof BooleanDefaults
     */
    'trueDescription'?: string;
    /**
     * The description for the false variation
     * @type {string}
     * @memberof BooleanDefaults
     */
    'falseDescription'?: string;
    /**
     * The variation index of the flag variation to use for the default targeting behavior when a flag\'s targeting is on and the target did not match any rules
     * @type {number}
     * @memberof BooleanDefaults
     */
    'onVariation'?: number;
    /**
     * The variation index of the flag variation to use for the default targeting behavior when a flag\'s targeting is off
     * @type {number}
     * @memberof BooleanDefaults
     */
    'offVariation'?: number;
}
/**
 * 
 * @export
 * @interface BooleanFlagDefaults
 */
export interface BooleanFlagDefaults {
    /**
     * The display name for the true variation, displayed in the LaunchDarkly user interface
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'trueDisplayName': string;
    /**
     * The display name for the false variation, displayed in the LaunchDarkly user interface
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'falseDisplayName': string;
    /**
     * The description for the true variation
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'trueDescription': string;
    /**
     * The description for the false variation
     * @type {string}
     * @memberof BooleanFlagDefaults
     */
    'falseDescription': string;
    /**
     * The variation index of the flag variation to use for the default targeting behavior when a flag\'s targeting is on and the target did not match any rules
     * @type {number}
     * @memberof BooleanFlagDefaults
     */
    'onVariation': number;
    /**
     * The variation index of the flag variation to use for the default targeting behavior when a flag\'s targeting is off
     * @type {number}
     * @memberof BooleanFlagDefaults
     */
    'offVariation': number;
}
/**
 * 
 * @export
 * @interface BranchCollectionRep
 */
export interface BranchCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof BranchCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of branches
     * @type {Array<BranchRep>}
     * @memberof BranchCollectionRep
     */
    'items': Array<BranchRep>;
}
/**
 * 
 * @export
 * @interface BranchRep
 */
export interface BranchRep {
    /**
     * The branch name
     * @type {string}
     * @memberof BranchRep
     */
    'name': string;
    /**
     * An ID representing the branch HEAD. For example, a commit SHA.
     * @type {string}
     * @memberof BranchRep
     */
    'head': string;
    /**
     * An optional ID used to prevent older data from overwriting newer data
     * @type {number}
     * @memberof BranchRep
     */
    'updateSequenceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof BranchRep
     */
    'syncTime': number;
    /**
     * An array of flag references found on the branch
     * @type {Array<ReferenceRep>}
     * @memberof BranchRep
     */
    'references'?: Array<ReferenceRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof BranchRep
     */
    '_links': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BulkEditMembersRep
 */
export interface BulkEditMembersRep {
    /**
     * A list of members IDs of the members who were successfully updated.
     * @type {Array<string>}
     * @memberof BulkEditMembersRep
     */
    'members'?: Array<string>;
    /**
     * A list of member IDs and errors for the members whose updates failed.
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BulkEditMembersRep
     */
    'errors'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface BulkEditTeamsRep
 */
export interface BulkEditTeamsRep {
    /**
     * A list of member IDs of the members who were added to the teams.
     * @type {Array<string>}
     * @memberof BulkEditTeamsRep
     */
    'memberIDs'?: Array<string>;
    /**
     * A list of team keys of the teams that were successfully updated.
     * @type {Array<string>}
     * @memberof BulkEditTeamsRep
     */
    'teamKeys'?: Array<string>;
    /**
     * A list of team keys and errors for the teams whose updates failed.
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BulkEditTeamsRep
     */
    'errors'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface Clause
 */
export interface Clause {
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    'attribute': string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    'op': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof Clause
     */
    'values': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    'contextKind'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Clause
     */
    'negate': boolean;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Client
     */
    '_links': { [key: string]: Link; };
    /**
     * Client name
     * @type {string}
     * @memberof Client
     */
    'name': string;
    /**
     * Client description
     * @type {string}
     * @memberof Client
     */
    'description'?: string;
    /**
     * The account ID the client is registered under
     * @type {string}
     * @memberof Client
     */
    '_accountId': string;
    /**
     * The client\'s unique ID
     * @type {string}
     * @memberof Client
     */
    '_clientId': string;
    /**
     * The client secret. This will only be shown upon creation.
     * @type {string}
     * @memberof Client
     */
    '_clientSecret'?: string;
    /**
     * The client\'s redirect URI
     * @type {string}
     * @memberof Client
     */
    'redirectUri': string;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    '_creationDate': number;
}
/**
 * 
 * @export
 * @interface ClientCollection
 */
export interface ClientCollection {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ClientCollection
     */
    '_links': { [key: string]: Link; };
    /**
     * List of client objects
     * @type {Array<Client>}
     * @memberof ClientCollection
     */
    'items': Array<Client>;
}
/**
 * 
 * @export
 * @interface ClientSideAvailability
 */
export interface ClientSideAvailability {
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    'usingMobileKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    'usingEnvironmentId'?: boolean;
}
/**
 * 
 * @export
 * @interface ClientSideAvailabilityPost
 */
export interface ClientSideAvailabilityPost {
    /**
     * Whether to enable availability for client-side SDKs. Defaults to <code>false</code>.
     * @type {boolean}
     * @memberof ClientSideAvailabilityPost
     */
    'usingEnvironmentId': boolean;
    /**
     * Whether to enable availability for mobile SDKs. Defaults to <code>true</code>.
     * @type {boolean}
     * @memberof ClientSideAvailabilityPost
     */
    'usingMobileKey': boolean;
}
/**
 * 
 * @export
 * @interface CompletedBy
 */
export interface CompletedBy {
    /**
     * 
     * @type {MemberSummary}
     * @memberof CompletedBy
     */
    'member'?: MemberSummary;
    /**
     * 
     * @type {TokenSummary}
     * @memberof CompletedBy
     */
    'token'?: TokenSummary;
}
/**
 * 
 * @export
 * @interface ConditionInput
 */
export interface ConditionInput {
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionInput
     */
    'executionDate'?: number;
    /**
     * For workflow stages whose scheduled execution is relative, how far in the future the stage should start.
     * @type {number}
     * @memberof ConditionInput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'waitDurationUnit'?: string;
    /**
     * Whether the workflow stage should be executed immediately
     * @type {boolean}
     * @memberof ConditionInput
     */
    'executeNow'?: boolean;
    /**
     * A description of the approval required for this stage
     * @type {string}
     * @memberof ConditionInput
     */
    'description'?: string;
    /**
     * A list of member IDs for the members to request approval from for this stage
     * @type {Array<string>}
     * @memberof ConditionInput
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * A list of team keys for the teams to request approval from for this stage
     * @type {Array<string>}
     * @memberof ConditionInput
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConditionInput
     */
    'kind'?: string;
}
/**
 * 
 * @export
 * @interface ConditionOutput
 */
export interface ConditionOutput {
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'kind'?: string;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof ConditionOutput
     */
    '_execution': ExecutionOutput;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'scheduleKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'executionDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'waitDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'waitDurationUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionOutput
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {Array<ReviewOutput>}
     * @memberof ConditionOutput
     */
    'allReviews': Array<ReviewOutput>;
    /**
     * 
     * @type {string}
     * @memberof ConditionOutput
     */
    'reviewStatus': string;
    /**
     * 
     * @type {number}
     * @memberof ConditionOutput
     */
    'appliedDate'?: number;
}
/**
 * 
 * @export
 * @interface ConfidenceIntervalRep
 */
export interface ConfidenceIntervalRep {
    /**
     * 
     * @type {number}
     * @memberof ConfidenceIntervalRep
     */
    'upper'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfidenceIntervalRep
     */
    'lower'?: number;
}
/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Conflict
     */
    'instruction'?: { [key: string]: any; };
    /**
     * Reason why the conflict exists
     * @type {string}
     * @memberof Conflict
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface ConflictOutput
 */
export interface ConflictOutput {
    /**
     * The stage ID
     * @type {string}
     * @memberof ConflictOutput
     */
    'stageId': string;
    /**
     * Message about the conflict
     * @type {string}
     * @memberof ConflictOutput
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ContextAttributeName
 */
export interface ContextAttributeName {
    /**
     * A context attribute\'s name.
     * @type {string}
     * @memberof ContextAttributeName
     */
    'name': string;
    /**
     * A relative estimate of the number of contexts seen recently that have an attribute with the associated name.
     * @type {number}
     * @memberof ContextAttributeName
     */
    'weight': number;
    /**
     * Whether or not the attribute has one or more redacted values.
     * @type {boolean}
     * @memberof ContextAttributeName
     */
    'redacted'?: boolean;
}
/**
 * 
 * @export
 * @interface ContextAttributeNames
 */
export interface ContextAttributeNames {
    /**
     * The kind associated with this collection of context attribute names.
     * @type {string}
     * @memberof ContextAttributeNames
     */
    'kind': string;
    /**
     * A collection of context attribute names.
     * @type {Array<ContextAttributeName>}
     * @memberof ContextAttributeNames
     */
    'names': Array<ContextAttributeName>;
}
/**
 * 
 * @export
 * @interface ContextAttributeNamesCollection
 */
export interface ContextAttributeNamesCollection {
    /**
     * A collection of context attribute name data grouped by kind.
     * @type {Array<ContextAttributeNames>}
     * @memberof ContextAttributeNamesCollection
     */
    'items': Array<ContextAttributeNames>;
}
/**
 * 
 * @export
 * @interface ContextAttributeValue
 */
export interface ContextAttributeValue {
    /**
     * A value for a context attribute.
     * @type {any}
     * @memberof ContextAttributeValue
     */
    'name': any;
    /**
     * A relative estimate of the number of contexts seen recently that have a matching value for a given attribute.
     * @type {number}
     * @memberof ContextAttributeValue
     */
    'weight': number;
}
/**
 * 
 * @export
 * @interface ContextAttributeValues
 */
export interface ContextAttributeValues {
    /**
     * The kind associated with this collection of context attribute values.
     * @type {string}
     * @memberof ContextAttributeValues
     */
    'kind': string;
    /**
     * A collection of context attribute values.
     * @type {Array<ContextAttributeValue>}
     * @memberof ContextAttributeValues
     */
    'values': Array<ContextAttributeValue>;
}
/**
 * 
 * @export
 * @interface ContextAttributeValuesCollection
 */
export interface ContextAttributeValuesCollection {
    /**
     * A collection of context attribute value data grouped by kind.
     * @type {Array<ContextAttributeValues>}
     * @memberof ContextAttributeValuesCollection
     */
    'items': Array<ContextAttributeValues>;
}
/**
 * 
 * @export
 * @interface ContextInstanceEvaluation
 */
export interface ContextInstanceEvaluation {
    /**
     * Name of the flag.
     * @type {string}
     * @memberof ContextInstanceEvaluation
     */
    'name': string;
    /**
     * Key of the flag.
     * @type {string}
     * @memberof ContextInstanceEvaluation
     */
    'key': string;
    /**
     * The value of the flag variation that the context receives. If there is no defined default rule, this is null.
     * @type {any}
     * @memberof ContextInstanceEvaluation
     */
    '_value': any;
    /**
     * 
     * @type {ContextInstanceEvaluationReason}
     * @memberof ContextInstanceEvaluation
     */
    'reason'?: ContextInstanceEvaluationReason;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstanceEvaluation
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextInstanceEvaluationReason
 */
export interface ContextInstanceEvaluationReason {
    /**
     * Describes the general reason that LaunchDarkly selected this variation.
     * @type {string}
     * @memberof ContextInstanceEvaluationReason
     */
    'kind': string;
    /**
     * The positional index of the matching rule if the kind is \'RULE_MATCH\'. The index is 0-based.
     * @type {number}
     * @memberof ContextInstanceEvaluationReason
     */
    'ruleIndex'?: number;
    /**
     * The unique identifier of the matching rule if the kind is \'RULE_MATCH\'.
     * @type {string}
     * @memberof ContextInstanceEvaluationReason
     */
    'ruleID'?: string;
    /**
     * The key of the flag that failed if the kind is \'PREREQUISITE_FAILED\'.
     * @type {string}
     * @memberof ContextInstanceEvaluationReason
     */
    'prerequisiteKey'?: string;
    /**
     * Indicates whether the context was evaluated as part of an experiment.
     * @type {boolean}
     * @memberof ContextInstanceEvaluationReason
     */
    'inExperiment'?: boolean;
    /**
     * The specific error type if the kind is \'ERROR\'.
     * @type {string}
     * @memberof ContextInstanceEvaluationReason
     */
    'errorKind'?: string;
}
/**
 * 
 * @export
 * @interface ContextInstanceEvaluations
 */
export interface ContextInstanceEvaluations {
    /**
     * Details on the flag evaluations for this context instance
     * @type {Array<ContextInstanceEvaluation>}
     * @memberof ContextInstanceEvaluations
     */
    'items': Array<ContextInstanceEvaluation>;
    /**
     * The number of flags
     * @type {number}
     * @memberof ContextInstanceEvaluations
     */
    'totalCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstanceEvaluations
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextInstanceRecord
 */
export interface ContextInstanceRecord {
    /**
     * Timestamp of the last time an evaluation occurred for this context instance
     * @type {string}
     * @memberof ContextInstanceRecord
     */
    'lastSeen'?: string;
    /**
     * The context instance ID
     * @type {string}
     * @memberof ContextInstanceRecord
     */
    'id': string;
    /**
     * An identifier representing the application where the LaunchDarkly SDK is running
     * @type {string}
     * @memberof ContextInstanceRecord
     */
    'applicationId'?: string;
    /**
     * A list of the context kinds this context was associated with that the SDK removed because they were marked as anonymous at flag evaluation
     * @type {Array<string>}
     * @memberof ContextInstanceRecord
     */
    'anonymousKinds'?: Array<string>;
    /**
     * The context, including its kind and attributes
     * @type {any}
     * @memberof ContextInstanceRecord
     */
    'context': any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstanceRecord
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof ContextInstanceRecord
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface ContextInstanceSearch
 */
export interface ContextInstanceSearch {
    /**
     * A collection of context instance filters
     * @type {string}
     * @memberof ContextInstanceSearch
     */
    'filter'?: string;
    /**
     * Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying <code>ts</code> for this value, or descending order by specifying <code>-ts</code>.
     * @type {string}
     * @memberof ContextInstanceSearch
     */
    'sort'?: string;
    /**
     * Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @type {number}
     * @memberof ContextInstanceSearch
     */
    'limit'?: number;
    /**
     * Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the <code>next</code> link instead, because this value is an obfuscated string.
     * @type {string}
     * @memberof ContextInstanceSearch
     */
    'continuationToken'?: string;
}
/**
 * 
 * @export
 * @interface ContextInstanceSegmentMembership
 */
export interface ContextInstanceSegmentMembership {
    /**
     * A human-friendly name for the segment
     * @type {string}
     * @memberof ContextInstanceSegmentMembership
     */
    'name': string;
    /**
     * A unique key used to reference the segment
     * @type {string}
     * @memberof ContextInstanceSegmentMembership
     */
    'key': string;
    /**
     * A description of the segment\'s purpose
     * @type {string}
     * @memberof ContextInstanceSegmentMembership
     */
    'description': string;
    /**
     * Whether this is an unbounded segment. Unbounded segments, also called big segments, may be list-based segments with more than 15,000 entries, or synced segments.
     * @type {boolean}
     * @memberof ContextInstanceSegmentMembership
     */
    'unbounded': boolean;
    /**
     * If the segment is a synced segment, the name of the external source
     * @type {string}
     * @memberof ContextInstanceSegmentMembership
     */
    'external': string;
    /**
     * Whether the context is a member of this segment, either by explicit inclusion or by rule matching
     * @type {boolean}
     * @memberof ContextInstanceSegmentMembership
     */
    'isMember': boolean;
    /**
     * Whether the context is explicitly included in this segment
     * @type {boolean}
     * @memberof ContextInstanceSegmentMembership
     */
    'isIndividuallyTargeted': boolean;
    /**
     * Whether the context is captured by this segment\'s rules. The value of this field is undefined if the context is also explicitly included (<code>isIndividuallyTargeted</code> is <code>true</code>).
     * @type {boolean}
     * @memberof ContextInstanceSegmentMembership
     */
    'isRuleTargeted': boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstanceSegmentMembership
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextInstanceSegmentMemberships
 */
export interface ContextInstanceSegmentMemberships {
    /**
     * 
     * @type {Array<ContextInstanceSegmentMembership>}
     * @memberof ContextInstanceSegmentMemberships
     */
    'items': Array<ContextInstanceSegmentMembership>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstanceSegmentMemberships
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextInstances
 */
export interface ContextInstances {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextInstances
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of unique context instances
     * @type {number}
     * @memberof ContextInstances
     */
    'totalCount'?: number;
    /**
     * The environment ID
     * @type {string}
     * @memberof ContextInstances
     */
    '_environmentId': string;
    /**
     * An obfuscated string that references the last context instance on the previous page of results. You can use this for pagination, however, we recommend using the <code>next</code> link instead.
     * @type {string}
     * @memberof ContextInstances
     */
    'continuationToken'?: string;
    /**
     * A collection of context instances. Can include multiple versions of context instances that have the same <code>id</code>, but different <code>applicationId</code>s.
     * @type {Array<ContextInstanceRecord>}
     * @memberof ContextInstances
     */
    'items': Array<ContextInstanceRecord>;
}
/**
 * 
 * @export
 * @interface ContextKindRep
 */
export interface ContextKindRep {
    /**
     * The context kind key
     * @type {string}
     * @memberof ContextKindRep
     */
    'key': string;
    /**
     * The context kind name
     * @type {string}
     * @memberof ContextKindRep
     */
    'name': string;
    /**
     * The context kind description
     * @type {string}
     * @memberof ContextKindRep
     */
    'description': string;
    /**
     * The context kind version
     * @type {number}
     * @memberof ContextKindRep
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof ContextKindRep
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof ContextKindRep
     */
    'lastModified': number;
    /**
     * 
     * @type {number}
     * @memberof ContextKindRep
     */
    'lastSeen'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContextKindRep
     */
    'createdFrom': string;
    /**
     * Alias for archived.
     * @type {boolean}
     * @memberof ContextKindRep
     */
    'hideInTargeting'?: boolean;
    /**
     * Whether the context kind is archived. Archived context kinds are unavailable for targeting.
     * @type {boolean}
     * @memberof ContextKindRep
     */
    'archived'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextKindRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextKindsCollectionRep
 */
export interface ContextKindsCollectionRep {
    /**
     * An array of context kinds
     * @type {Array<ContextKindRep>}
     * @memberof ContextKindsCollectionRep
     */
    'items': Array<ContextKindRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextKindsCollectionRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ContextRecord
 */
export interface ContextRecord {
    /**
     * Timestamp of the last time an evaluation occurred for this context
     * @type {string}
     * @memberof ContextRecord
     */
    'lastSeen'?: string;
    /**
     * An identifier representing the application where the LaunchDarkly SDK is running
     * @type {string}
     * @memberof ContextRecord
     */
    'applicationId'?: string;
    /**
     * The context, including its kind and attributes
     * @type {any}
     * @memberof ContextRecord
     */
    'context': any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ContextRecord
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof ContextRecord
     */
    '_access'?: Access;
    /**
     * The total number of associated contexts. Associated contexts are contexts that have appeared in the same context instance, that is, they were part of the same flag evaluation.
     * @type {number}
     * @memberof ContextRecord
     */
    'associatedContexts'?: number;
}
/**
 * 
 * @export
 * @interface ContextSearch
 */
export interface ContextSearch {
    /**
     * A collection of context filters
     * @type {string}
     * @memberof ContextSearch
     */
    'filter'?: string;
    /**
     * Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying <code>ts</code> for this value, or descending order by specifying <code>-ts</code>.
     * @type {string}
     * @memberof ContextSearch
     */
    'sort'?: string;
    /**
     * Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @type {number}
     * @memberof ContextSearch
     */
    'limit'?: number;
    /**
     * Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the <code>next</code> link instead, because this value is an obfuscated string.
     * @type {string}
     * @memberof ContextSearch
     */
    'continuationToken'?: string;
}
/**
 * 
 * @export
 * @interface Contexts
 */
export interface Contexts {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Contexts
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of contexts
     * @type {number}
     * @memberof Contexts
     */
    'totalCount'?: number;
    /**
     * The environment ID where the context was evaluated
     * @type {string}
     * @memberof Contexts
     */
    '_environmentId': string;
    /**
     * An obfuscated string that references the last context instance on the previous page of results. You can use this for pagination, however, we recommend using the <code>next</code> link instead.
     * @type {string}
     * @memberof Contexts
     */
    'continuationToken'?: string;
    /**
     * A collection of contexts. Can include multiple versions of contexts that have the same <code>kind</code> and <code>key</code>, but different <code>applicationId</code>s.
     * @type {Array<ContextRecord>}
     * @memberof Contexts
     */
    'items': Array<ContextRecord>;
}
/**
 * 
 * @export
 * @interface CopiedFromEnv
 */
export interface CopiedFromEnv {
    /**
     * Key of feature flag copied
     * @type {string}
     * @memberof CopiedFromEnv
     */
    'key': string;
    /**
     * Version of feature flag copied
     * @type {number}
     * @memberof CopiedFromEnv
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface CreateApprovalRequestRequest
 */
export interface CreateApprovalRequestRequest {
    /**
     * String representation of a resource
     * @type {string}
     * @memberof CreateApprovalRequestRequest
     */
    'resourceId': string;
    /**
     * Optional comment describing the approval request
     * @type {string}
     * @memberof CreateApprovalRequestRequest
     */
    'comment'?: string;
    /**
     * A brief description of the changes you\'re requesting
     * @type {string}
     * @memberof CreateApprovalRequestRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof CreateApprovalRequestRequest
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateApprovalRequestRequest
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * An array of team keys. The members of these teams are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateApprovalRequestRequest
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateApprovalRequestRequest
     */
    'integrationConfig'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateCopyFlagConfigApprovalRequestRequest
 */
export interface CreateCopyFlagConfigApprovalRequestRequest {
    /**
     * Optional comment describing the approval request
     * @type {string}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'comment'?: string;
    /**
     * A brief description of your changes
     * @type {string}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'description': string;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * An array of team keys. The members of these teams are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {SourceFlag}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'source': SourceFlag;
    /**
     * Optional list of the flag changes to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If neither are included, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'includedActions'?: Array<CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum>;
    /**
     * Optional list of the flag changes NOT to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If neither are included, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof CreateCopyFlagConfigApprovalRequestRequest
     */
    'excludedActions'?: Array<CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum>;
}

export const CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdateRules: 'updateRules',
    UpdateTargets: 'updateTargets',
    UpdatePrerequisites: 'updatePrerequisites'
} as const;

export type CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum = typeof CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum[keyof typeof CreateCopyFlagConfigApprovalRequestRequestIncludedActionsEnum];
export const CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdateRules: 'updateRules',
    UpdateTargets: 'updateTargets',
    UpdatePrerequisites: 'updatePrerequisites'
} as const;

export type CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum = typeof CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum[keyof typeof CreateCopyFlagConfigApprovalRequestRequestExcludedActionsEnum];

/**
 * 
 * @export
 * @interface CreateFlagConfigApprovalRequestRequest
 */
export interface CreateFlagConfigApprovalRequestRequest {
    /**
     * Optional comment describing the approval request
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'comment'?: string;
    /**
     * A brief description of the changes you\'re requesting
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'notifyMemberIds'?: Array<string>;
    /**
     * An array of team keys. The members of these teams are notified to review the approval request.
     * @type {Array<string>}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'notifyTeamKeys'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'executionDate'?: number;
    /**
     * The ID of a scheduled change. Include this if your <code>instructions</code> include editing or deleting a scheduled change.
     * @type {string}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateFlagConfigApprovalRequestRequest
     */
    'integrationConfig'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreatePhaseInput
 */
export interface CreatePhaseInput {
    /**
     * An ordered list of the audiences for this release phase. Each audience corresponds to a LaunchDarkly environment.
     * @type {Array<AudiencePost>}
     * @memberof CreatePhaseInput
     */
    'audiences': Array<AudiencePost>;
    /**
     * The release phase name
     * @type {string}
     * @memberof CreatePhaseInput
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateReleasePipelineInput
 */
export interface CreateReleasePipelineInput {
    /**
     * The release pipeline description
     * @type {string}
     * @memberof CreateReleasePipelineInput
     */
    'description'?: string;
    /**
     * The unique identifier of this release pipeline
     * @type {string}
     * @memberof CreateReleasePipelineInput
     */
    'key': string;
    /**
     * The name of the release pipeline
     * @type {string}
     * @memberof CreateReleasePipelineInput
     */
    'name': string;
    /**
     * A logical grouping of one or more environments that share attributes for rolling out changes
     * @type {Array<CreatePhaseInput>}
     * @memberof CreateReleasePipelineInput
     */
    'phases': Array<CreatePhaseInput>;
    /**
     * A list of tags for this release pipeline
     * @type {Array<string>}
     * @memberof CreateReleasePipelineInput
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateWorkflowTemplateInput
 */
export interface CreateWorkflowTemplateInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'workflowId'?: string;
    /**
     * 
     * @type {Array<StageInput>}
     * @memberof CreateWorkflowTemplateInput
     */
    'stages'?: Array<StageInput>;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'projectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'environmentKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkflowTemplateInput
     */
    'flagKey'?: string;
}
/**
 * 
 * @export
 * @interface CredibleIntervalRep
 */
export interface CredibleIntervalRep {
    /**
     * The upper bound
     * @type {number}
     * @memberof CredibleIntervalRep
     */
    'upper'?: number;
    /**
     * The lower bound
     * @type {number}
     * @memberof CredibleIntervalRep
     */
    'lower'?: number;
}
/**
 * 
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * The name of the custom property of this type.
     * @type {string}
     * @memberof CustomProperty
     */
    'name': string;
    /**
     * An array of values for the custom property data to associate with this flag.
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    'value': Array<string>;
}
/**
 * 
 * @export
 * @interface CustomRole
 */
export interface CustomRole {
    /**
     * The ID of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    '_id': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomRole
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof CustomRole
     */
    '_access'?: Access;
    /**
     * The description of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'description'?: string;
    /**
     * The key of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'key': string;
    /**
     * The name of the custom role
     * @type {string}
     * @memberof CustomRole
     */
    'name': string;
    /**
     * An array of the policies that comprise this custom role
     * @type {Array<Statement>}
     * @memberof CustomRole
     */
    'policy': Array<Statement>;
    /**
     * 
     * @type {string}
     * @memberof CustomRole
     */
    'basePermissions'?: string;
}
/**
 * 
 * @export
 * @interface CustomRolePost
 */
export interface CustomRolePost {
    /**
     * A human-friendly name for the custom role
     * @type {string}
     * @memberof CustomRolePost
     */
    'name': string;
    /**
     * The custom role key
     * @type {string}
     * @memberof CustomRolePost
     */
    'key': string;
    /**
     * Description of custom role
     * @type {string}
     * @memberof CustomRolePost
     */
    'description'?: string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof CustomRolePost
     */
    'policy': Array<StatementPost>;
    /**
     * 
     * @type {string}
     * @memberof CustomRolePost
     */
    'basePermissions'?: string;
}
/**
 * 
 * @export
 * @interface CustomRoles
 */
export interface CustomRoles {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomRoles
     */
    '_links'?: { [key: string]: Link; };
    /**
     * An array of custom roles
     * @type {Array<CustomRole>}
     * @memberof CustomRoles
     */
    'items'?: Array<CustomRole>;
}
/**
 * 
 * @export
 * @interface CustomWorkflowInput
 */
export interface CustomWorkflowInput {
    /**
     * 
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'maintainerId'?: string;
    /**
     * The workflow name
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'name': string;
    /**
     * The workflow description
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'description'?: string;
    /**
     * A list of the workflow stages
     * @type {Array<StageInput>}
     * @memberof CustomWorkflowInput
     */
    'stages'?: Array<StageInput>;
    /**
     * The template key
     * @type {string}
     * @memberof CustomWorkflowInput
     */
    'templateKey'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowMeta
 */
export interface CustomWorkflowMeta {
    /**
     * The name of the workflow stage that required this approval request
     * @type {string}
     * @memberof CustomWorkflowMeta
     */
    'name'?: string;
    /**
     * 
     * @type {CustomWorkflowStageMeta}
     * @memberof CustomWorkflowMeta
     */
    'stage'?: CustomWorkflowStageMeta;
}
/**
 * 
 * @export
 * @interface CustomWorkflowOutput
 */
export interface CustomWorkflowOutput {
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    '_id': string;
    /**
     * The version of the workflow
     * @type {number}
     * @memberof CustomWorkflowOutput
     */
    '_version': number;
    /**
     * Any conflicts that are present in the workflow stages
     * @type {Array<ConflictOutput>}
     * @memberof CustomWorkflowOutput
     */
    '_conflicts': Array<ConflictOutput>;
    /**
     * 
     * @type {number}
     * @memberof CustomWorkflowOutput
     */
    '_creationDate': number;
    /**
     * The member ID of the maintainer of the workflow. Defaults to the workflow creator.
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    '_maintainerId': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof CustomWorkflowOutput
     */
    '_links': { [key: string]: Link; };
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'name': string;
    /**
     * A brief description of the workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'description'?: string;
    /**
     * The kind of workflow
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'kind'?: string;
    /**
     * The stages that make up the workflow. Each stage contains conditions and actions.
     * @type {Array<StageOutput>}
     * @memberof CustomWorkflowOutput
     */
    'stages'?: Array<StageOutput>;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof CustomWorkflowOutput
     */
    '_execution': ExecutionOutput;
    /**
     * 
     * @type {WorkflowTemplateMetadata}
     * @memberof CustomWorkflowOutput
     */
    'meta'?: WorkflowTemplateMetadata;
    /**
     * For workflows being created from a workflow template, this value is the template\'s key
     * @type {string}
     * @memberof CustomWorkflowOutput
     */
    'templateKey'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowStageMeta
 */
export interface CustomWorkflowStageMeta {
    /**
     * The zero-based index of the workflow stage
     * @type {number}
     * @memberof CustomWorkflowStageMeta
     */
    'index'?: number;
    /**
     * The name of the workflow stage
     * @type {string}
     * @memberof CustomWorkflowStageMeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CustomWorkflowsListingOutput
 */
export interface CustomWorkflowsListingOutput {
    /**
     * An array of workflows
     * @type {Array<CustomWorkflowOutput>}
     * @memberof CustomWorkflowsListingOutput
     */
    'items': Array<CustomWorkflowOutput>;
}
/**
 * 
 * @export
 * @interface DefaultClientSideAvailability
 */
export interface DefaultClientSideAvailability {
    /**
     * Whether to enable availability for mobile SDKs
     * @type {boolean}
     * @memberof DefaultClientSideAvailability
     */
    'usingMobileKey': boolean;
    /**
     * Whether to enable availability for client-side SDKs
     * @type {boolean}
     * @memberof DefaultClientSideAvailability
     */
    'usingEnvironmentId': boolean;
}
/**
 * 
 * @export
 * @interface DefaultClientSideAvailabilityPost
 */
export interface DefaultClientSideAvailabilityPost {
    /**
     * Whether to enable availability for client-side SDKs.
     * @type {boolean}
     * @memberof DefaultClientSideAvailabilityPost
     */
    'usingEnvironmentId': boolean;
    /**
     * Whether to enable availability for mobile SDKs.
     * @type {boolean}
     * @memberof DefaultClientSideAvailabilityPost
     */
    'usingMobileKey': boolean;
}
/**
 * 
 * @export
 * @interface Defaults
 */
export interface Defaults {
    /**
     * The index, from the array of variations for this flag, of the variation to serve by default when targeting is on.
     * @type {number}
     * @memberof Defaults
     */
    'onVariation': number;
    /**
     * The index, from the array of variations for this flag, of the variation to serve by default when targeting is off.
     * @type {number}
     * @memberof Defaults
     */
    'offVariation': number;
}
/**
 * 
 * @export
 * @interface DependentExperimentRep
 */
export interface DependentExperimentRep {
    /**
     * The experiment key
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'key': string;
    /**
     * The experiment name
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'name': string;
    /**
     * The environment ID
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'environmentId': string;
    /**
     * The environment key
     * @type {string}
     * @memberof DependentExperimentRep
     */
    'environmentKey': string;
    /**
     * 
     * @type {number}
     * @memberof DependentExperimentRep
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof DependentExperimentRep
     */
    'archivedDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentExperimentRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface DependentFlag
 */
export interface DependentFlag {
    /**
     * The flag name
     * @type {string}
     * @memberof DependentFlag
     */
    'name'?: string;
    /**
     * The flag key
     * @type {string}
     * @memberof DependentFlag
     */
    'key': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlag
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlag
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface DependentFlagEnvironment
 */
export interface DependentFlagEnvironment {
    /**
     * The environment name
     * @type {string}
     * @memberof DependentFlagEnvironment
     */
    'name'?: string;
    /**
     * The environment key
     * @type {string}
     * @memberof DependentFlagEnvironment
     */
    'key': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlagEnvironment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlagEnvironment
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface DependentFlagsByEnvironment
 */
export interface DependentFlagsByEnvironment {
    /**
     * A list of dependent flags, which are flags that use the requested flag as a prerequisite
     * @type {Array<DependentFlag>}
     * @memberof DependentFlagsByEnvironment
     */
    'items': Array<DependentFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentFlagsByEnvironment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof DependentFlagsByEnvironment
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface DependentMetricGroupRep
 */
export interface DependentMetricGroupRep {
    /**
     * A unique key to reference the metric group
     * @type {string}
     * @memberof DependentMetricGroupRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric group
     * @type {string}
     * @memberof DependentMetricGroupRep
     */
    'name': string;
    /**
     * The type of the metric group
     * @type {string}
     * @memberof DependentMetricGroupRep
     */
    'kind': DependentMetricGroupRepKindEnum;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentMetricGroupRep
     */
    '_links': { [key: string]: Link; };
}

export const DependentMetricGroupRepKindEnum = {
    Funnel: 'funnel'
} as const;

export type DependentMetricGroupRepKindEnum = typeof DependentMetricGroupRepKindEnum[keyof typeof DependentMetricGroupRepKindEnum];

/**
 * 
 * @export
 * @interface DependentMetricGroupRepWithMetrics
 */
export interface DependentMetricGroupRepWithMetrics {
    /**
     * A unique key to reference the metric group
     * @type {string}
     * @memberof DependentMetricGroupRepWithMetrics
     */
    'key': string;
    /**
     * A human-friendly name for the metric group
     * @type {string}
     * @memberof DependentMetricGroupRepWithMetrics
     */
    'name': string;
    /**
     * The type of the metric group
     * @type {string}
     * @memberof DependentMetricGroupRepWithMetrics
     */
    'kind': DependentMetricGroupRepWithMetricsKindEnum;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentMetricGroupRepWithMetrics
     */
    '_links': { [key: string]: Link; };
    /**
     * The metrics in the metric group
     * @type {Array<MetricInGroupRep>}
     * @memberof DependentMetricGroupRepWithMetrics
     */
    'metrics'?: Array<MetricInGroupRep>;
}

export const DependentMetricGroupRepWithMetricsKindEnum = {
    Funnel: 'funnel'
} as const;

export type DependentMetricGroupRepWithMetricsKindEnum = typeof DependentMetricGroupRepWithMetricsKindEnum[keyof typeof DependentMetricGroupRepWithMetricsKindEnum];

/**
 * 
 * @export
 * @interface DependentMetricOrMetricGroupRep
 */
export interface DependentMetricOrMetricGroupRep {
    /**
     * A unique key to reference the metric or metric group
     * @type {string}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'key': string;
    /**
     * The version ID of the metric or metric group
     * @type {string}
     * @memberof DependentMetricOrMetricGroupRep
     */
    '_versionId': string;
    /**
     * A human-friendly name for the metric or metric group
     * @type {string}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'name': string;
    /**
     * If this is a metric, then it represents the kind of event the metric tracks. If this is a metric group, then it represents the group type
     * @type {string}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'kind': DependentMetricOrMetricGroupRepKindEnum;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>).
     * @type {boolean}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'isNumeric'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DependentMetricOrMetricGroupRep
     */
    '_links': { [key: string]: Link; };
    /**
     * Whether this is a metric group or a metric
     * @type {boolean}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'isGroup': boolean;
    /**
     * An ordered list of the metrics in this metric group
     * @type {Array<MetricInGroupRep>}
     * @memberof DependentMetricOrMetricGroupRep
     */
    'metrics'?: Array<MetricInGroupRep>;
}

export const DependentMetricOrMetricGroupRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom',
    Funnel: 'funnel',
    Standard: 'standard'
} as const;

export type DependentMetricOrMetricGroupRepKindEnum = typeof DependentMetricOrMetricGroupRepKindEnum[keyof typeof DependentMetricOrMetricGroupRepKindEnum];

/**
 * 
 * @export
 * @interface DeploymentCollectionRep
 */
export interface DeploymentCollectionRep {
    /**
     * The total number of deployments
     * @type {number}
     * @memberof DeploymentCollectionRep
     */
    'totalCount': number;
    /**
     * A list of deployments
     * @type {Array<DeploymentRep>}
     * @memberof DeploymentCollectionRep
     */
    'items': Array<DeploymentRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof DeploymentCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface DeploymentRep
 */
export interface DeploymentRep {
    /**
     * The deployment ID
     * @type {string}
     * @memberof DeploymentRep
     */
    'id': string;
    /**
     * The application key
     * @type {string}
     * @memberof DeploymentRep
     */
    'applicationKey': string;
    /**
     * The application version
     * @type {string}
     * @memberof DeploymentRep
     */
    'applicationVersion': string;
    /**
     * 
     * @type {number}
     * @memberof DeploymentRep
     */
    'startedAt': number;
    /**
     * 
     * @type {number}
     * @memberof DeploymentRep
     */
    'endedAt'?: number;
    /**
     * The duration of the deployment in milliseconds
     * @type {number}
     * @memberof DeploymentRep
     */
    'durationMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRep
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentRep
     */
    'kind': string;
    /**
     * Whether the deployment is active
     * @type {boolean}
     * @memberof DeploymentRep
     */
    'active': boolean;
    /**
     * The metadata associated with the deployment
     * @type {{ [key: string]: any; }}
     * @memberof DeploymentRep
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Whether the deployment is archived
     * @type {boolean}
     * @memberof DeploymentRep
     */
    'archived': boolean;
    /**
     * The environment key
     * @type {string}
     * @memberof DeploymentRep
     */
    'environmentKey': string;
    /**
     * The number of contributors
     * @type {number}
     * @memberof DeploymentRep
     */
    'numberOfContributors': number;
    /**
     * The number of pull requests
     * @type {number}
     * @memberof DeploymentRep
     */
    'numberOfPullRequests': number;
    /**
     * The number of lines added
     * @type {number}
     * @memberof DeploymentRep
     */
    'linesAdded': number;
    /**
     * The number of lines deleted
     * @type {number}
     * @memberof DeploymentRep
     */
    'linesDeleted': number;
    /**
     * The total lead time from first commit to deployment end in milliseconds
     * @type {number}
     * @memberof DeploymentRep
     */
    'leadTime': number;
    /**
     * 
     * @type {PullRequestCollectionRep}
     * @memberof DeploymentRep
     */
    'pullRequests'?: PullRequestCollectionRep;
    /**
     * 
     * @type {FlagReferenceCollectionRep}
     * @memberof DeploymentRep
     */
    'flagReferences'?: FlagReferenceCollectionRep;
    /**
     * 
     * @type {LeadTimeStagesRep}
     * @memberof DeploymentRep
     */
    'leadTimeStages'?: LeadTimeStagesRep;
}
/**
 * 
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * The ID of this Data Export destination
     * @type {string}
     * @memberof Destination
     */
    '_id'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Destination
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A human-readable name for your Data Export destination
     * @type {string}
     * @memberof Destination
     */
    'name'?: string;
    /**
     * The type of Data Export destination
     * @type {string}
     * @memberof Destination
     */
    'kind'?: DestinationKindEnum;
    /**
     * 
     * @type {number}
     * @memberof Destination
     */
    'version'?: number;
    /**
     * An object with the configuration parameters required for the destination type
     * @type {any}
     * @memberof Destination
     */
    'config'?: any;
    /**
     * Whether the export is on, that is, the status of the integration
     * @type {boolean}
     * @memberof Destination
     */
    'on'?: boolean;
    /**
     * 
     * @type {Access}
     * @memberof Destination
     */
    '_access'?: Access;
}

export const DestinationKindEnum = {
    GooglePubsub: 'google-pubsub',
    Kinesis: 'kinesis',
    Mparticle: 'mparticle',
    Segment: 'segment',
    AzureEventHubs: 'azure-event-hubs'
} as const;

export type DestinationKindEnum = typeof DestinationKindEnum[keyof typeof DestinationKindEnum];

/**
 * 
 * @export
 * @interface DestinationPost
 */
export interface DestinationPost {
    /**
     * A human-readable name for your Data Export destination
     * @type {string}
     * @memberof DestinationPost
     */
    'name'?: string;
    /**
     * The type of Data Export destination
     * @type {string}
     * @memberof DestinationPost
     */
    'kind'?: DestinationPostKindEnum;
    /**
     * An object with the configuration parameters required for the destination type
     * @type {any}
     * @memberof DestinationPost
     */
    'config'?: any;
    /**
     * Whether the export is on. Displayed as the integration status in the LaunchDarkly UI.
     * @type {boolean}
     * @memberof DestinationPost
     */
    'on'?: boolean;
}

export const DestinationPostKindEnum = {
    GooglePubsub: 'google-pubsub',
    Kinesis: 'kinesis',
    Mparticle: 'mparticle',
    Segment: 'segment',
    AzureEventHubs: 'azure-event-hubs'
} as const;

export type DestinationPostKindEnum = typeof DestinationPostKindEnum[keyof typeof DestinationPostKindEnum];

/**
 * 
 * @export
 * @interface Destinations
 */
export interface Destinations {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Destinations
     */
    '_links'?: { [key: string]: Link; };
    /**
     * An array of Data Export destinations
     * @type {Array<Destination>}
     * @memberof Destinations
     */
    'items'?: Array<Destination>;
}
/**
 * 
 * @export
 * @interface Distribution
 */
export interface Distribution {
    /**
     * The type of distribution.
     * @type {string}
     * @memberof Distribution
     */
    'kind'?: DistributionKindEnum;
    /**
     * The parameters of the distribution. The parameters are different for each distribution type. When <code>kind</code> is <code>normal</code>, the parameters of the distribution are \'mu\' and \'sigma\'. When <code>kind</code> is <code>beta</code>, the parameters of the distribution are \'alpha\' and \'beta.\'
     * @type {{ [key: string]: any; }}
     * @memberof Distribution
     */
    'parameters'?: { [key: string]: any; };
}

export const DistributionKindEnum = {
    Normal: 'normal',
    Beta: 'beta'
} as const;

export type DistributionKindEnum = typeof DistributionKindEnum[keyof typeof DistributionKindEnum];

/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Environment
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID for the environment. Use this as the client-side ID for authorization in some client-side SDKs, and to associate LaunchDarkly environments with CDN integrations in edge SDKs.
     * @type {string}
     * @memberof Environment
     */
    '_id': string;
    /**
     * A project-unique key for the new environment
     * @type {string}
     * @memberof Environment
     */
    'key': string;
    /**
     * A human-friendly name for the new environment
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * The SDK key for the environment. Use this for authorization in server-side SDKs.
     * @type {string}
     * @memberof Environment
     */
    'apiKey': string;
    /**
     * The mobile key for the environment. Use this for authorization in mobile SDKs.
     * @type {string}
     * @memberof Environment
     */
    'mobileKey': string;
    /**
     * The color used to indicate this environment in the UI
     * @type {string}
     * @memberof Environment
     */
    'color': string;
    /**
     * The default time (in minutes) that the PHP SDK can cache feature flag rules locally
     * @type {number}
     * @memberof Environment
     */
    'defaultTtl': number;
    /**
     * Ensures that one end user of the client-side SDK cannot inspect the variations for another end user
     * @type {boolean}
     * @memberof Environment
     */
    'secureMode': boolean;
    /**
     * Enables tracking detailed information for new flags by default
     * @type {boolean}
     * @memberof Environment
     */
    'defaultTrackEvents': boolean;
    /**
     * Whether members who modify flags and segments through the LaunchDarkly user interface are required to add a comment
     * @type {boolean}
     * @memberof Environment
     */
    'requireComments': boolean;
    /**
     * Whether members who modify flags and segments through the LaunchDarkly user interface are required to confirm those changes
     * @type {boolean}
     * @memberof Environment
     */
    'confirmChanges': boolean;
    /**
     * A list of tags for this environment
     * @type {Array<string>}
     * @memberof Environment
     */
    'tags': Array<string>;
    /**
     * 
     * @type {ApprovalSettings}
     * @memberof Environment
     */
    'approvalSettings'?: ApprovalSettings;
    /**
     * Whether the environment is critical
     * @type {boolean}
     * @memberof Environment
     */
    'critical': boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentPost
 */
export interface EnvironmentPost {
    /**
     * A human-friendly name for the new environment
     * @type {string}
     * @memberof EnvironmentPost
     */
    'name': string;
    /**
     * A project-unique key for the new environment
     * @type {string}
     * @memberof EnvironmentPost
     */
    'key': string;
    /**
     * A color to indicate this environment in the UI
     * @type {string}
     * @memberof EnvironmentPost
     */
    'color': string;
    /**
     * The default time (in minutes) that the PHP SDK can cache feature flag rules locally
     * @type {number}
     * @memberof EnvironmentPost
     */
    'defaultTtl'?: number;
    /**
     * Ensures that one end user of the client-side SDK cannot inspect the variations for another end user
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'secureMode'?: boolean;
    /**
     * Enables tracking detailed information for new flags by default
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'defaultTrackEvents'?: boolean;
    /**
     * Requires confirmation for all flag and segment changes via the UI in this environment
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'confirmChanges'?: boolean;
    /**
     * Requires comments for all flag and segment changes via the UI in this environment
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'requireComments'?: boolean;
    /**
     * Tags to apply to the new environment
     * @type {Array<string>}
     * @memberof EnvironmentPost
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {SourceEnv}
     * @memberof EnvironmentPost
     */
    'source'?: SourceEnv;
    /**
     * Whether the environment is critical
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    'critical'?: boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentSummary
 */
export interface EnvironmentSummary {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof EnvironmentSummary
     */
    '_links': { [key: string]: Link; };
    /**
     * A project-unique key for the environment
     * @type {string}
     * @memberof EnvironmentSummary
     */
    'key': string;
    /**
     * A human-friendly name for the environment
     * @type {string}
     * @memberof EnvironmentSummary
     */
    'name': string;
    /**
     * The color used to indicate this environment in the UI
     * @type {string}
     * @memberof EnvironmentSummary
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface Environments
 */
export interface Environments {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Environments
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of environments returned
     * @type {number}
     * @memberof Environments
     */
    'totalCount'?: number;
    /**
     * An array of environments
     * @type {Array<Environment>}
     * @memberof Environments
     */
    'items': Array<Environment>;
}
/**
 * 
 * @export
 * @interface EvaluationReason
 */
export interface EvaluationReason {
    /**
     * Describes the general reason that LaunchDarkly selected this variation.
     * @type {string}
     * @memberof EvaluationReason
     */
    'kind': string;
    /**
     * The positional index of the matching rule if the kind is \'RULE_MATCH\'. The index is 0-based.
     * @type {number}
     * @memberof EvaluationReason
     */
    'ruleIndex'?: number;
    /**
     * The unique identifier of the matching rule if the kind is \'RULE_MATCH\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'ruleID'?: string;
    /**
     * The key of the flag that failed if the kind is \'PREREQUISITE_FAILED\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'prerequisiteKey'?: string;
    /**
     * Indicates whether the evaluation occurred as part of an experiment.
     * @type {boolean}
     * @memberof EvaluationReason
     */
    'inExperiment'?: boolean;
    /**
     * The specific error type if the kind is \'ERROR\'.
     * @type {string}
     * @memberof EvaluationReason
     */
    'errorKind'?: string;
}
/**
 * 
 * @export
 * @interface EvaluationsSummary
 */
export interface EvaluationsSummary {
    /**
     * A list of variation evaluations
     * @type {Array<VariationEvalSummary>}
     * @memberof EvaluationsSummary
     */
    'variations'?: Array<VariationEvalSummary>;
}
/**
 * 
 * @export
 * @interface ExecutionOutput
 */
export interface ExecutionOutput {
    /**
     * The status of the execution of this workflow stage
     * @type {string}
     * @memberof ExecutionOutput
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionOutput
     */
    'stopDate'?: number;
}
/**
 * 
 * @export
 * @interface ExpandableApprovalRequestResponse
 */
export interface ExpandableApprovalRequestResponse {
    /**
     * The ID of this approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    '_id': string;
    /**
     * Version of the approval request
     * @type {number}
     * @memberof ExpandableApprovalRequestResponse
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandableApprovalRequestResponse
     */
    'creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'serviceKind': string;
    /**
     * The ID of the member who requested the approval
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'requestorId'?: string;
    /**
     * A human-friendly name for the approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'description'?: string;
    /**
     * Current status of the review of this approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'reviewStatus': ExpandableApprovalRequestResponseReviewStatusEnum;
    /**
     * An array of individual reviews of this approval request
     * @type {Array<ReviewResponse>}
     * @memberof ExpandableApprovalRequestResponse
     */
    'allReviews': Array<ReviewResponse>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof ExpandableApprovalRequestResponse
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExpandableApprovalRequestResponse
     */
    'appliedDate'?: number;
    /**
     * The member ID of the member who applied the approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'appliedByMemberId'?: string;
    /**
     * The service token ID of the service token which applied the approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'appliedByServiceTokenId'?: string;
    /**
     * Current status of the approval request
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'status': ExpandableApprovalRequestResponseStatusEnum;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ExpandableApprovalRequestResponse
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting approval requests
     * @type {Array<Conflict>}
     * @memberof ExpandableApprovalRequestResponse
     */
    'conflicts': Array<Conflict>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof ExpandableApprovalRequestResponse
     */
    '_links': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ExpandableApprovalRequestResponse
     */
    'executionDate'?: number;
    /**
     * ID of scheduled change to edit or delete
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof ExpandableApprovalRequestResponse
     */
    'integrationMetadata'?: IntegrationMetadata;
    /**
     * 
     * @type {CopiedFromEnv}
     * @memberof ExpandableApprovalRequestResponse
     */
    'source'?: CopiedFromEnv;
    /**
     * 
     * @type {CustomWorkflowMeta}
     * @memberof ExpandableApprovalRequestResponse
     */
    'customWorkflowMetadata'?: CustomWorkflowMeta;
    /**
     * String representation of a resource
     * @type {string}
     * @memberof ExpandableApprovalRequestResponse
     */
    'resourceId'?: string;
    /**
     * 
     * @type {ApprovalSettings}
     * @memberof ExpandableApprovalRequestResponse
     */
    'approvalSettings'?: ApprovalSettings;
    /**
     * 
     * @type {Project}
     * @memberof ExpandableApprovalRequestResponse
     */
    'project'?: Project;
    /**
     * List of environments the approval impacts
     * @type {Array<Environment>}
     * @memberof ExpandableApprovalRequestResponse
     */
    'environments'?: Array<Environment>;
    /**
     * 
     * @type {ExpandedFlagRep}
     * @memberof ExpandableApprovalRequestResponse
     */
    'flag'?: ExpandedFlagRep;
}

export const ExpandableApprovalRequestResponseReviewStatusEnum = {
    Approved: 'approved',
    Declined: 'declined',
    Pending: 'pending'
} as const;

export type ExpandableApprovalRequestResponseReviewStatusEnum = typeof ExpandableApprovalRequestResponseReviewStatusEnum[keyof typeof ExpandableApprovalRequestResponseReviewStatusEnum];
export const ExpandableApprovalRequestResponseStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed',
    Scheduled: 'scheduled'
} as const;

export type ExpandableApprovalRequestResponseStatusEnum = typeof ExpandableApprovalRequestResponseStatusEnum[keyof typeof ExpandableApprovalRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface ExpandableApprovalRequestsResponse
 */
export interface ExpandableApprovalRequestsResponse {
    /**
     * An array of approval requests
     * @type {Array<ExpandableApprovalRequestResponse>}
     * @memberof ExpandableApprovalRequestsResponse
     */
    'items': Array<ExpandableApprovalRequestResponse>;
    /**
     * Total number of approval requests
     * @type {number}
     * @memberof ExpandableApprovalRequestsResponse
     */
    'totalCount': number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpandableApprovalRequestsResponse
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExpandedFlagRep
 */
export interface ExpandedFlagRep {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof ExpandedFlagRep
     */
    'name': string;
    /**
     * Kind of feature flag
     * @type {string}
     * @memberof ExpandedFlagRep
     */
    'kind': ExpandedFlagRepKindEnum;
    /**
     * Description of the feature flag
     * @type {string}
     * @memberof ExpandedFlagRep
     */
    'description'?: string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof ExpandedFlagRep
     */
    'key': string;
    /**
     * Version of the feature flag
     * @type {number}
     * @memberof ExpandedFlagRep
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ExpandedFlagRep
     */
    'creationDate': number;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK
     * @type {boolean}
     * @memberof ExpandedFlagRep
     * @deprecated
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof ExpandedFlagRep
     */
    'clientSideAvailability'?: ClientSideAvailability;
    /**
     * An array of possible variations for the flag
     * @type {Array<Variation>}
     * @memberof ExpandedFlagRep
     */
    'variations': Array<Variation>;
    /**
     * Whether the flag is a temporary flag
     * @type {boolean}
     * @memberof ExpandedFlagRep
     */
    'temporary': boolean;
    /**
     * Tags for the feature flag
     * @type {Array<string>}
     * @memberof ExpandedFlagRep
     */
    'tags': Array<string>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpandedFlagRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of the member who maintains the flag
     * @type {string}
     * @memberof ExpandedFlagRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof ExpandedFlagRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof ExpandedFlagRep
     */
    'customProperties': { [key: string]: CustomProperty; };
    /**
     * Boolean indicating if the feature flag is archived
     * @type {boolean}
     * @memberof ExpandedFlagRep
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof ExpandedFlagRep
     */
    'archivedDate'?: number;
    /**
     * 
     * @type {Defaults}
     * @memberof ExpandedFlagRep
     */
    'defaults'?: Defaults;
}

export const ExpandedFlagRepKindEnum = {
    Boolean: 'boolean',
    Multivariate: 'multivariate'
} as const;

export type ExpandedFlagRepKindEnum = typeof ExpandedFlagRepKindEnum[keyof typeof ExpandedFlagRepKindEnum];

/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * The experiment ID
     * @type {string}
     * @memberof Experiment
     */
    '_id'?: string;
    /**
     * The experiment key
     * @type {string}
     * @memberof Experiment
     */
    'key': string;
    /**
     * The experiment name
     * @type {string}
     * @memberof Experiment
     */
    'name': string;
    /**
     * The experiment description
     * @type {string}
     * @memberof Experiment
     */
    'description'?: string;
    /**
     * The ID of the member who maintains this experiment.
     * @type {string}
     * @memberof Experiment
     */
    '_maintainerId': string;
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    '_creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    'environmentKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    'archivedDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Experiment
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {IterationRep}
     * @memberof Experiment
     */
    'currentIteration'?: IterationRep;
    /**
     * 
     * @type {IterationRep}
     * @memberof Experiment
     */
    'draftIteration'?: IterationRep;
    /**
     * Details on the previous iterations for this experiment.
     * @type {Array<IterationRep>}
     * @memberof Experiment
     */
    'previousIterations'?: Array<IterationRep>;
}
/**
 * 
 * @export
 * @interface ExperimentAllocationRep
 */
export interface ExperimentAllocationRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentAllocationRep
     */
    'defaultVariation': number;
    /**
     * 
     * @type {boolean}
     * @memberof ExperimentAllocationRep
     */
    'canReshuffle': boolean;
}
/**
 * 
 * @export
 * @interface ExperimentBayesianResultsRep
 */
export interface ExperimentBayesianResultsRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentBayesianResultsRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * Deprecated, use <code>results</code> instead. Only populated when response does not contain results sliced by multiple attributes.
     * @type {Array<TreatmentResultRep>}
     * @memberof ExperimentBayesianResultsRep
     * @deprecated
     */
    'treatmentResults'?: Array<TreatmentResultRep>;
    /**
     * 
     * @type {MetricSeen}
     * @memberof ExperimentBayesianResultsRep
     */
    'metricSeen'?: MetricSeen;
    /**
     * The probability of a Sample Ratio Mismatch
     * @type {number}
     * @memberof ExperimentBayesianResultsRep
     */
    'probabilityOfMismatch'?: number;
    /**
     * A list of attribute values and their corresponding treatment results
     * @type {Array<SlicedResultsRep>}
     * @memberof ExperimentBayesianResultsRep
     */
    'results'?: Array<SlicedResultsRep>;
}
/**
 * 
 * @export
 * @interface ExperimentCollectionRep
 */
export interface ExperimentCollectionRep {
    /**
     * An array of experiments
     * @type {Array<Experiment>}
     * @memberof ExperimentCollectionRep
     */
    'items': Array<Experiment>;
    /**
     * The total number of experiments in this project and environment. Does not include legacy experiments.
     * @type {number}
     * @memberof ExperimentCollectionRep
     */
    'total_count'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExperimentEnabledPeriodRep
 */
export interface ExperimentEnabledPeriodRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnabledPeriodRep
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnabledPeriodRep
     */
    'stopDate'?: number;
}
/**
 * 
 * @export
 * @interface ExperimentEnvironmentSettingRep
 */
export interface ExperimentEnvironmentSettingRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'stopDate'?: number;
    /**
     * 
     * @type {Array<ExperimentEnabledPeriodRep>}
     * @memberof ExperimentEnvironmentSettingRep
     */
    'enabledPeriods'?: Array<ExperimentEnabledPeriodRep>;
}
/**
 * 
 * @export
 * @interface ExperimentInfoRep
 */
export interface ExperimentInfoRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentInfoRep
     */
    'baselineIdx': number;
    /**
     * 
     * @type {Array<LegacyExperimentRep>}
     * @memberof ExperimentInfoRep
     */
    'items': Array<LegacyExperimentRep>;
}
/**
 * 
 * @export
 * @interface ExperimentMetadataRep
 */
export interface ExperimentMetadataRep {
    /**
     * 
     * @type {any}
     * @memberof ExperimentMetadataRep
     */
    'key'?: any;
}
/**
 * 
 * @export
 * @interface ExperimentPatchInput
 */
export interface ExperimentPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof ExperimentPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ExperimentPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface ExperimentPost
 */
export interface ExperimentPost {
    /**
     * The experiment name
     * @type {string}
     * @memberof ExperimentPost
     */
    'name': string;
    /**
     * The experiment description
     * @type {string}
     * @memberof ExperimentPost
     */
    'description'?: string;
    /**
     * The ID of the member who maintains this experiment
     * @type {string}
     * @memberof ExperimentPost
     */
    'maintainerId'?: string;
    /**
     * The experiment key
     * @type {string}
     * @memberof ExperimentPost
     */
    'key': string;
    /**
     * 
     * @type {IterationInput}
     * @memberof ExperimentPost
     */
    'iteration': IterationInput;
}
/**
 * 
 * @export
 * @interface ExperimentResults
 */
export interface ExperimentResults {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof ExperimentResults
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<ExperimentMetadataRep>}
     * @memberof ExperimentResults
     */
    'metadata'?: Array<ExperimentMetadataRep>;
    /**
     * 
     * @type {Array<ExperimentTotalsRep>}
     * @memberof ExperimentResults
     */
    'totals'?: Array<ExperimentTotalsRep>;
    /**
     * 
     * @type {Array<ExperimentTimeSeriesSlice>}
     * @memberof ExperimentResults
     */
    'series'?: Array<ExperimentTimeSeriesSlice>;
    /**
     * 
     * @type {ExperimentStatsRep}
     * @memberof ExperimentResults
     */
    'stats'?: ExperimentStatsRep;
    /**
     * 
     * @type {string}
     * @memberof ExperimentResults
     */
    'granularity'?: string;
    /**
     * 
     * @type {MetricSeen}
     * @memberof ExperimentResults
     */
    'metricSeen'?: MetricSeen;
}
/**
 * 
 * @export
 * @interface ExperimentStatsRep
 */
export interface ExperimentStatsRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'pValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'chi2'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentStatsRep
     */
    'winningVariationIdx'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExperimentStatsRep
     */
    'minSampleSizeMet'?: boolean;
}
/**
 * 
 * @export
 * @interface ExperimentTimeSeriesSlice
 */
export interface ExperimentTimeSeriesSlice {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesSlice
     */
    'Time'?: number;
    /**
     * 
     * @type {Array<ExperimentTimeSeriesVariationSlice>}
     * @memberof ExperimentTimeSeriesSlice
     */
    'VariationData'?: Array<ExperimentTimeSeriesVariationSlice>;
}
/**
 * 
 * @export
 * @interface ExperimentTimeSeriesVariationSlice
 */
export interface ExperimentTimeSeriesVariationSlice {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'conversionRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeConversionRate'?: number;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'confidenceInterval'?: ConfidenceIntervalRep;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTimeSeriesVariationSlice
     */
    'cumulativeConfidenceInterval'?: ConfidenceIntervalRep;
}
/**
 * 
 * @export
 * @interface ExperimentTotalsRep
 */
export interface ExperimentTotalsRep {
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeImpressionCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeConversionRate'?: number;
    /**
     * 
     * @type {ConfidenceIntervalRep}
     * @memberof ExperimentTotalsRep
     */
    'cumulativeConfidenceInterval'?: ConfidenceIntervalRep;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'pValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'improvement'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExperimentTotalsRep
     */
    'minSampleSize'?: number;
}
/**
 * 
 * @export
 * @interface ExpiringTarget
 */
export interface ExpiringTarget {
    /**
     * The ID of this expiring target
     * @type {string}
     * @memberof ExpiringTarget
     */
    '_id': string;
    /**
     * The version of this expiring target
     * @type {number}
     * @memberof ExpiringTarget
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ExpiringTarget
     */
    'expirationDate': number;
    /**
     * The context kind of the context to be removed
     * @type {string}
     * @memberof ExpiringTarget
     */
    'contextKind': string;
    /**
     * A unique key used to represent the context to be removed
     * @type {string}
     * @memberof ExpiringTarget
     */
    'contextKey': string;
    /**
     * A segment\'s target type, <code>included</code> or <code>excluded</code>. Included when expiring targets are updated on a segment.
     * @type {string}
     * @memberof ExpiringTarget
     */
    'targetType'?: string;
    /**
     * A unique ID used to represent the flag variation. Included when expiring targets are updated on a feature flag.
     * @type {string}
     * @memberof ExpiringTarget
     */
    'variationId'?: string;
    /**
     * 
     * @type {ResourceId}
     * @memberof ExpiringTarget
     */
    '_resourceId': ResourceId;
}
/**
 * 
 * @export
 * @interface ExpiringTargetError
 */
export interface ExpiringTargetError {
    /**
     * The index of the PATCH instruction where the error occurred
     * @type {number}
     * @memberof ExpiringTargetError
     */
    'instructionIndex': number;
    /**
     * The error message related to a failed PATCH instruction
     * @type {string}
     * @memberof ExpiringTargetError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ExpiringTargetGetResponse
 */
export interface ExpiringTargetGetResponse {
    /**
     * A list of expiring targets
     * @type {Array<ExpiringTarget>}
     * @memberof ExpiringTargetGetResponse
     */
    'items': Array<ExpiringTarget>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringTargetGetResponse
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExpiringTargetPatchResponse
 */
export interface ExpiringTargetPatchResponse {
    /**
     * A list of the results from each instruction
     * @type {Array<ExpiringTarget>}
     * @memberof ExpiringTargetPatchResponse
     */
    'items': Array<ExpiringTarget>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringTargetPatchResponse
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {number}
     * @memberof ExpiringTargetPatchResponse
     */
    'totalInstructions'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpiringTargetPatchResponse
     */
    'successfulInstructions'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExpiringTargetPatchResponse
     */
    'failedInstructions'?: number;
    /**
     * 
     * @type {Array<ExpiringTargetError>}
     * @memberof ExpiringTargetPatchResponse
     */
    'errors'?: Array<ExpiringTargetError>;
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetGetResponse
 */
export interface ExpiringUserTargetGetResponse {
    /**
     * An array of expiring user targets
     * @type {Array<ExpiringUserTargetItem>}
     * @memberof ExpiringUserTargetGetResponse
     */
    'items': Array<ExpiringUserTargetItem>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringUserTargetGetResponse
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetItem
 */
export interface ExpiringUserTargetItem {
    /**
     * The ID of this expiring user target
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    '_id': string;
    /**
     * The version of this expiring user target
     * @type {number}
     * @memberof ExpiringUserTargetItem
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof ExpiringUserTargetItem
     */
    'expirationDate': number;
    /**
     * A unique key used to represent the user
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'userKey': string;
    /**
     * A segment\'s target type. Included when expiring user targets are updated on a segment.
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'targetType'?: string;
    /**
     * A unique key used to represent the flag variation. Included when expiring user targets are updated on a feature flag.
     * @type {string}
     * @memberof ExpiringUserTargetItem
     */
    'variationId'?: string;
    /**
     * 
     * @type {ResourceIDResponse}
     * @memberof ExpiringUserTargetItem
     */
    '_resourceId': ResourceIDResponse;
}
/**
 * 
 * @export
 * @interface ExpiringUserTargetPatchResponse
 */
export interface ExpiringUserTargetPatchResponse {
    /**
     * An array of expiring user targets
     * @type {Array<ExpiringUserTargetItem>}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'items': Array<ExpiringUserTargetItem>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExpiringUserTargetPatchResponse
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total count of instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'totalInstructions'?: number;
    /**
     * The total count of successful instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'successfulInstructions'?: number;
    /**
     * The total count of the failed instructions sent in the PATCH request
     * @type {number}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'failedInstructions'?: number;
    /**
     * An array of error messages for the failed instructions
     * @type {Array<ExpiringTargetError>}
     * @memberof ExpiringUserTargetPatchResponse
     */
    'errors'?: Array<ExpiringTargetError>;
}
/**
 * 
 * @export
 * @interface Export
 */
export interface Export {
    /**
     * The export ID
     * @type {string}
     * @memberof Export
     */
    'id': string;
    /**
     * The segment key
     * @type {string}
     * @memberof Export
     */
    'segmentKey': string;
    /**
     * 
     * @type {number}
     * @memberof Export
     */
    'creationTime': number;
    /**
     * The export status
     * @type {string}
     * @memberof Export
     */
    'status': string;
    /**
     * The export size, in bytes
     * @type {number}
     * @memberof Export
     */
    'sizeBytes': number;
    /**
     * The export size, with units
     * @type {string}
     * @memberof Export
     */
    'size': string;
    /**
     * 
     * @type {InitiatorRep}
     * @memberof Export
     */
    'initiator': InitiatorRep;
    /**
     * The location and content type of related resources, including the location of the exported file
     * @type {{ [key: string]: Link; }}
     * @memberof Export
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Extinction
 */
export interface Extinction {
    /**
     * The identifier for the revision where flag became extinct. For example, a commit SHA.
     * @type {string}
     * @memberof Extinction
     */
    'revision': string;
    /**
     * Description of the extinction. For example, the commit message for the revision.
     * @type {string}
     * @memberof Extinction
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof Extinction
     */
    'time': number;
    /**
     * The feature flag key
     * @type {string}
     * @memberof Extinction
     */
    'flagKey': string;
    /**
     * The project key
     * @type {string}
     * @memberof Extinction
     */
    'projKey': string;
}
/**
 * 
 * @export
 * @interface ExtinctionCollectionRep
 */
export interface ExtinctionCollectionRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ExtinctionCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of extinction events
     * @type {{ [key: string]: Array<Extinction>; }}
     * @memberof ExtinctionCollectionRep
     */
    'items': { [key: string]: Array<Extinction>; };
}
/**
 * 
 * @export
 * @interface FailureReasonRep
 */
export interface FailureReasonRep {
    /**
     * The attribute that failed validation
     * @type {string}
     * @memberof FailureReasonRep
     */
    'attribute': string;
    /**
     * The reason the attribute failed validation
     * @type {string}
     * @memberof FailureReasonRep
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface FeatureFlag
 */
export interface FeatureFlag {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'name': string;
    /**
     * Kind of feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'kind': FeatureFlagKindEnum;
    /**
     * Description of the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'description'?: string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof FeatureFlag
     */
    'key': string;
    /**
     * Version of the feature flag
     * @type {number}
     * @memberof FeatureFlag
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'creationDate': number;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK
     * @type {boolean}
     * @memberof FeatureFlag
     * @deprecated
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FeatureFlag
     */
    'clientSideAvailability'?: ClientSideAvailability;
    /**
     * An array of possible variations for the flag
     * @type {Array<Variation>}
     * @memberof FeatureFlag
     */
    'variations': Array<Variation>;
    /**
     * Whether the flag is a temporary flag
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'temporary': boolean;
    /**
     * Tags for the feature flag
     * @type {Array<string>}
     * @memberof FeatureFlag
     */
    'tags': Array<string>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlag
     */
    '_links': { [key: string]: Link; };
    /**
     * Associated maintainerId for the feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof FeatureFlag
     */
    '_maintainer'?: MemberSummary;
    /**
     * The key of the associated team that maintains this feature flag
     * @type {string}
     * @memberof FeatureFlag
     */
    'maintainerTeamKey'?: string;
    /**
     * 
     * @type {MaintainerTeam}
     * @memberof FeatureFlag
     */
    '_maintainerTeam'?: MaintainerTeam;
    /**
     * Deprecated, use <code>experiments</code> instead
     * @type {Array<string>}
     * @memberof FeatureFlag
     * @deprecated
     */
    'goalIds'?: Array<string>;
    /**
     * 
     * @type {ExperimentInfoRep}
     * @memberof FeatureFlag
     */
    'experiments': ExperimentInfoRep;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FeatureFlag
     */
    'customProperties': { [key: string]: CustomProperty; };
    /**
     * Boolean indicating if the feature flag is archived
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'archivedDate'?: number;
    /**
     * Boolean indicating if the feature flag is deprecated
     * @type {boolean}
     * @memberof FeatureFlag
     */
    'deprecated': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    'deprecatedDate'?: number;
    /**
     * 
     * @type {Defaults}
     * @memberof FeatureFlag
     */
    'defaults'?: Defaults;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlag
     */
    '_purpose'?: string;
    /**
     * 
     * @type {FlagMigrationSettingsRep}
     * @memberof FeatureFlag
     */
    'migrationSettings'?: FlagMigrationSettingsRep;
    /**
     * Details on the environments for this flag
     * @type {{ [key: string]: FeatureFlagConfig; }}
     * @memberof FeatureFlag
     */
    'environments': { [key: string]: FeatureFlagConfig; };
}

export const FeatureFlagKindEnum = {
    Boolean: 'boolean',
    Multivariate: 'multivariate'
} as const;

export type FeatureFlagKindEnum = typeof FeatureFlagKindEnum[keyof typeof FeatureFlagKindEnum];

/**
 * 
 * @export
 * @interface FeatureFlagBody
 */
export interface FeatureFlagBody {
    /**
     * A human-friendly name for the feature flag
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'name': string;
    /**
     * A unique key used to reference the flag in your code
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'key': string;
    /**
     * Description of the feature flag. Defaults to an empty string.
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'description'?: string;
    /**
     * Deprecated, use <code>clientSideAvailability</code>. Whether this flag should be made available to the client-side JavaScript SDK. Defaults to <code>false</code>.
     * @type {boolean}
     * @memberof FeatureFlagBody
     * @deprecated
     */
    'includeInSnippet'?: boolean;
    /**
     * 
     * @type {ClientSideAvailabilityPost}
     * @memberof FeatureFlagBody
     */
    'clientSideAvailability'?: ClientSideAvailabilityPost;
    /**
     * An array of possible variations for the flag. The variation values must be unique. If omitted, two boolean variations of <code>true</code> and <code>false</code> will be used.
     * @type {Array<Variation>}
     * @memberof FeatureFlagBody
     */
    'variations'?: Array<Variation>;
    /**
     * Whether the flag is a temporary flag. Defaults to <code>true</code>.
     * @type {boolean}
     * @memberof FeatureFlagBody
     */
    'temporary'?: boolean;
    /**
     * Tags for the feature flag. Defaults to an empty array.
     * @type {Array<string>}
     * @memberof FeatureFlagBody
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FeatureFlagBody
     */
    'customProperties'?: { [key: string]: CustomProperty; };
    /**
     * 
     * @type {Defaults}
     * @memberof FeatureFlagBody
     */
    'defaults'?: Defaults;
    /**
     * Purpose of the flag
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'purpose'?: FeatureFlagBodyPurposeEnum;
    /**
     * 
     * @type {MigrationSettingsPost}
     * @memberof FeatureFlagBody
     */
    'migrationSettings'?: MigrationSettingsPost;
    /**
     * The ID of the member who maintains this feature flag
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'maintainerId'?: string;
    /**
     * The key of the team that maintains this feature flag
     * @type {string}
     * @memberof FeatureFlagBody
     */
    'maintainerTeamKey'?: string;
}

export const FeatureFlagBodyPurposeEnum = {
    Migration: 'migration'
} as const;

export type FeatureFlagBodyPurposeEnum = typeof FeatureFlagBodyPurposeEnum[keyof typeof FeatureFlagBodyPurposeEnum];

/**
 * 
 * @export
 * @interface FeatureFlagConfig
 */
export interface FeatureFlagConfig {
    /**
     * Whether the flag is on
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'on': boolean;
    /**
     * Boolean indicating if the feature flag is archived
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'archived': boolean;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    'sel': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'lastModified': number;
    /**
     * Version of the feature flag
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'version': number;
    /**
     * An array of the individual targets that will receive a specific variation based on their key. Individual targets with a context kind of \'user\' are included here.
     * @type {Array<Target>}
     * @memberof FeatureFlagConfig
     */
    'targets'?: Array<Target>;
    /**
     * An array of the individual targets that will receive a specific variation based on their key. Individual targets with context kinds other than \'user\' are included here.
     * @type {Array<Target>}
     * @memberof FeatureFlagConfig
     */
    'contextTargets'?: Array<Target>;
    /**
     * An array of the rules for how to serve a variation to specific targets based on their attributes
     * @type {Array<Rule>}
     * @memberof FeatureFlagConfig
     */
    'rules'?: Array<Rule>;
    /**
     * 
     * @type {VariationOrRolloutRep}
     * @memberof FeatureFlagConfig
     */
    'fallthrough'?: VariationOrRolloutRep;
    /**
     * The ID of the variation to serve when the flag is off
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    'offVariation'?: number;
    /**
     * An array of the prerequisite flags and their variations that are required before this flag takes effect
     * @type {Array<Prerequisite>}
     * @memberof FeatureFlagConfig
     */
    'prerequisites'?: Array<Prerequisite>;
    /**
     * 
     * @type {Link}
     * @memberof FeatureFlagConfig
     */
    '_site': Link;
    /**
     * 
     * @type {Access}
     * @memberof FeatureFlagConfig
     */
    '_access'?: Access;
    /**
     * The environment name
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    '_environmentName': string;
    /**
     * Whether LaunchDarkly tracks events for the feature flag, for all rules
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'trackEvents': boolean;
    /**
     * Whether LaunchDarkly tracks events for the feature flag, for the default rule
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    'trackEventsFallthrough': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    '_debugEventsUntilDate'?: number;
    /**
     * 
     * @type {FlagSummary}
     * @memberof FeatureFlagConfig
     */
    '_summary'?: FlagSummary;
    /**
     * 
     * @type {FlagConfigEvaluation}
     * @memberof FeatureFlagConfig
     */
    'evaluation'?: FlagConfigEvaluation;
    /**
     * 
     * @type {FlagConfigMigrationSettingsRep}
     * @memberof FeatureFlagConfig
     */
    'migrationSettings'?: FlagConfigMigrationSettingsRep;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChange
 */
export interface FeatureFlagScheduledChange {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagScheduledChange
     */
    '_id': string;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    '_creationDate': number;
    /**
     * The ID of the scheduled change maintainer
     * @type {string}
     * @memberof FeatureFlagScheduledChange
     */
    '_maintainerId': string;
    /**
     * Version of the scheduled change
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    'executionDate': number;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FeatureFlagScheduledChange
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting scheduled changes
     * @type {any}
     * @memberof FeatureFlagScheduledChange
     */
    'conflicts'?: any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagScheduledChange
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChanges
 */
export interface FeatureFlagScheduledChanges {
    /**
     * Array of scheduled changes
     * @type {Array<FeatureFlagScheduledChange>}
     * @memberof FeatureFlagScheduledChanges
     */
    'items': Array<FeatureFlagScheduledChange>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagScheduledChanges
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagStatus
 */
export interface FeatureFlagStatus {
    /**
     * Status of the flag
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    'name': string;
    /**
     * Timestamp of last time flag was requested
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    'lastRequested'?: string;
    /**
     * Default value seen from code
     * @type {any}
     * @memberof FeatureFlagStatus
     */
    'default'?: any;
}
/**
 * 
 * @export
 * @interface FeatureFlagStatusAcrossEnvironments
 */
export interface FeatureFlagStatusAcrossEnvironments {
    /**
     * Flag status for environment.
     * @type {{ [key: string]: FeatureFlagStatus; }}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    'environments': { [key: string]: FeatureFlagStatus; };
    /**
     * feature flag key
     * @type {string}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FeatureFlagStatuses
 */
export interface FeatureFlagStatuses {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlagStatuses
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Array<FlagStatusRep>}
     * @memberof FeatureFlagStatuses
     */
    'items'?: Array<FlagStatusRep>;
}
/**
 * 
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * An array of feature flags
     * @type {Array<FeatureFlag>}
     * @memberof FeatureFlags
     */
    'items': Array<FeatureFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FeatureFlags
     */
    '_links': { [key: string]: Link; };
    /**
     * The total number of flags
     * @type {number}
     * @memberof FeatureFlags
     */
    'totalCount'?: number;
    /**
     * The number of flags that have differences between environments. Only shown when query parameter <code>compare</code> is <code>true</code>.
     * @type {number}
     * @memberof FeatureFlags
     */
    'totalCountWithDifferences'?: number;
}
/**
 * 
 * @export
 * @interface FileRep
 */
export interface FileRep {
    /**
     * The imported file name, including the extension
     * @type {string}
     * @memberof FileRep
     */
    'filename'?: string;
    /**
     * The imported file status
     * @type {string}
     * @memberof FileRep
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface FlagConfigApprovalRequestResponse
 */
export interface FlagConfigApprovalRequestResponse {
    /**
     * The ID of this approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_id': string;
    /**
     * Version of the approval request
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_version': number;
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'serviceKind': string;
    /**
     * The ID of the member who requested the approval
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'requestorId'?: string;
    /**
     * A human-friendly name for the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'description'?: string;
    /**
     * Current status of the review of this approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'reviewStatus': FlagConfigApprovalRequestResponseReviewStatusEnum;
    /**
     * An array of individual reviews of this approval request
     * @type {Array<ReviewResponse>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'allReviews': Array<ReviewResponse>;
    /**
     * An array of member IDs. These members are notified to review the approval request.
     * @type {Array<string>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'notifyMemberIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'appliedDate'?: number;
    /**
     * The member ID of the member who applied the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'appliedByMemberId'?: string;
    /**
     * The service token ID of the service token which applied the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'appliedByServiceTokenId'?: string;
    /**
     * Current status of the approval request
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'status': FlagConfigApprovalRequestResponseStatusEnum;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * Details on any conflicting approval requests
     * @type {Array<Conflict>}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'conflicts': Array<Conflict>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof FlagConfigApprovalRequestResponse
     */
    '_links': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'executionDate'?: number;
    /**
     * ID of scheduled change to edit or delete
     * @type {string}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'operatingOnId'?: string;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'integrationMetadata'?: IntegrationMetadata;
    /**
     * 
     * @type {CopiedFromEnv}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'source'?: CopiedFromEnv;
    /**
     * 
     * @type {CustomWorkflowMeta}
     * @memberof FlagConfigApprovalRequestResponse
     */
    'customWorkflowMetadata'?: CustomWorkflowMeta;
}

export const FlagConfigApprovalRequestResponseReviewStatusEnum = {
    Approved: 'approved',
    Declined: 'declined',
    Pending: 'pending'
} as const;

export type FlagConfigApprovalRequestResponseReviewStatusEnum = typeof FlagConfigApprovalRequestResponseReviewStatusEnum[keyof typeof FlagConfigApprovalRequestResponseReviewStatusEnum];
export const FlagConfigApprovalRequestResponseStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed',
    Scheduled: 'scheduled'
} as const;

export type FlagConfigApprovalRequestResponseStatusEnum = typeof FlagConfigApprovalRequestResponseStatusEnum[keyof typeof FlagConfigApprovalRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface FlagConfigApprovalRequestsResponse
 */
export interface FlagConfigApprovalRequestsResponse {
    /**
     * An array of approval requests
     * @type {Array<FlagConfigApprovalRequestResponse>}
     * @memberof FlagConfigApprovalRequestsResponse
     */
    'items': Array<FlagConfigApprovalRequestResponse>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagConfigApprovalRequestsResponse
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagConfigEvaluation
 */
export interface FlagConfigEvaluation {
    /**
     * 
     * @type {Array<string>}
     * @memberof FlagConfigEvaluation
     */
    'contextKinds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FlagConfigMigrationSettingsRep
 */
export interface FlagConfigMigrationSettingsRep {
    /**
     * 
     * @type {number}
     * @memberof FlagConfigMigrationSettingsRep
     */
    'checkRatio'?: number;
}
/**
 * 
 * @export
 * @interface FlagCopyConfigEnvironment
 */
export interface FlagCopyConfigEnvironment {
    /**
     * The environment key
     * @type {string}
     * @memberof FlagCopyConfigEnvironment
     */
    'key': string;
    /**
     * Optional flag version. If you include this, the operation only succeeds if the current flag version in the environment matches this version.
     * @type {number}
     * @memberof FlagCopyConfigEnvironment
     */
    'currentVersion'?: number;
}
/**
 * 
 * @export
 * @interface FlagCopyConfigPost
 */
export interface FlagCopyConfigPost {
    /**
     * 
     * @type {FlagCopyConfigEnvironment}
     * @memberof FlagCopyConfigPost
     */
    'source': FlagCopyConfigEnvironment;
    /**
     * 
     * @type {FlagCopyConfigEnvironment}
     * @memberof FlagCopyConfigPost
     */
    'target': FlagCopyConfigEnvironment;
    /**
     * Optional comment
     * @type {string}
     * @memberof FlagCopyConfigPost
     */
    'comment'?: string;
    /**
     * Optional list of the flag changes to copy from the source environment to the target environment. You may include either <code>includedActions</code> or <code>excludedActions</code>, but not both. If you include neither, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof FlagCopyConfigPost
     */
    'includedActions'?: Array<FlagCopyConfigPostIncludedActionsEnum>;
    /**
     * Optional list of the flag changes NOT to copy from the source environment to the target environment. You may include either  <code>includedActions</code> or <code>excludedActions</code>, but not both. If you include neither, then all flag changes will be copied.
     * @type {Array<string>}
     * @memberof FlagCopyConfigPost
     */
    'excludedActions'?: Array<FlagCopyConfigPostExcludedActionsEnum>;
}

export const FlagCopyConfigPostIncludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateRules: 'updateRules',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdatePrerequisites: 'updatePrerequisites',
    UpdateTargets: 'updateTargets',
    UpdateFlagConfigMigrationSettings: 'updateFlagConfigMigrationSettings'
} as const;

export type FlagCopyConfigPostIncludedActionsEnum = typeof FlagCopyConfigPostIncludedActionsEnum[keyof typeof FlagCopyConfigPostIncludedActionsEnum];
export const FlagCopyConfigPostExcludedActionsEnum = {
    UpdateOn: 'updateOn',
    UpdateRules: 'updateRules',
    UpdateFallthrough: 'updateFallthrough',
    UpdateOffVariation: 'updateOffVariation',
    UpdatePrerequisites: 'updatePrerequisites',
    UpdateTargets: 'updateTargets',
    UpdateFlagConfigMigrationSettings: 'updateFlagConfigMigrationSettings'
} as const;

export type FlagCopyConfigPostExcludedActionsEnum = typeof FlagCopyConfigPostExcludedActionsEnum[keyof typeof FlagCopyConfigPostExcludedActionsEnum];

/**
 * 
 * @export
 * @interface FlagDefaultsRep
 */
export interface FlagDefaultsRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagDefaultsRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A unique key for the flag default
     * @type {string}
     * @memberof FlagDefaultsRep
     */
    'key'?: string;
    /**
     * A list of default tags for each flag
     * @type {Array<string>}
     * @memberof FlagDefaultsRep
     */
    'tags'?: Array<string>;
    /**
     * Whether the flag should be temporary by default
     * @type {boolean}
     * @memberof FlagDefaultsRep
     */
    'temporary'?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FlagDefaultsRep
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * 
     * @type {BooleanDefaults}
     * @memberof FlagDefaultsRep
     */
    'booleanDefaults'?: BooleanDefaults;
}
/**
 * 
 * @export
 * @interface FlagEventCollectionRep
 */
export interface FlagEventCollectionRep {
    /**
     * The total number of flag events
     * @type {number}
     * @memberof FlagEventCollectionRep
     */
    'totalCount': number;
    /**
     * A list of flag events
     * @type {Array<FlagEventRep>}
     * @memberof FlagEventCollectionRep
     */
    'items': Array<FlagEventRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagEventCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagEventExperiment
 */
export interface FlagEventExperiment {
    /**
     * The experiment key
     * @type {string}
     * @memberof FlagEventExperiment
     */
    'key': string;
    /**
     * The experiment name
     * @type {string}
     * @memberof FlagEventExperiment
     */
    'name': string;
    /**
     * 
     * @type {FlagEventExperimentIteration}
     * @memberof FlagEventExperiment
     */
    'iteration': FlagEventExperimentIteration;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagEventExperiment
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagEventExperimentCollection
 */
export interface FlagEventExperimentCollection {
    /**
     * The total number of experiments
     * @type {number}
     * @memberof FlagEventExperimentCollection
     */
    'totalCount': number;
    /**
     * A list of experiments
     * @type {Array<FlagEventExperiment>}
     * @memberof FlagEventExperimentCollection
     */
    'items': Array<FlagEventExperiment>;
}
/**
 * 
 * @export
 * @interface FlagEventExperimentIteration
 */
export interface FlagEventExperimentIteration {
    /**
     * The experiment iteration ID
     * @type {string}
     * @memberof FlagEventExperimentIteration
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FlagEventExperimentIteration
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof FlagEventExperimentIteration
     */
    'startedAt': number;
    /**
     * 
     * @type {number}
     * @memberof FlagEventExperimentIteration
     */
    'endedAt'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagEventExperimentIteration
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagEventImpactRep
 */
export interface FlagEventImpactRep {
    /**
     * The size of the flag event impact. Sizes are defined as: none (0%), small (0-20%), medium (20-80%), large (>80%)
     * @type {string}
     * @memberof FlagEventImpactRep
     */
    'size'?: FlagEventImpactRepSizeEnum;
    /**
     * The percentage of the flag event impact
     * @type {number}
     * @memberof FlagEventImpactRep
     */
    'percentage'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlagEventImpactRep
     */
    'reason'?: string;
    /**
     * 
     * @type {EvaluationsSummary}
     * @memberof FlagEventImpactRep
     */
    'evaluationsSummary'?: EvaluationsSummary;
}

export const FlagEventImpactRepSizeEnum = {
    None: 'none',
    Small: 'small',
    Medium: 'medium',
    Large: 'large'
} as const;

export type FlagEventImpactRepSizeEnum = typeof FlagEventImpactRepSizeEnum[keyof typeof FlagEventImpactRepSizeEnum];

/**
 * 
 * @export
 * @interface FlagEventMemberRep
 */
export interface FlagEventMemberRep {
    /**
     * The member ID
     * @type {string}
     * @memberof FlagEventMemberRep
     */
    'id': string;
    /**
     * The member email
     * @type {string}
     * @memberof FlagEventMemberRep
     */
    'email': string;
    /**
     * The member first name
     * @type {string}
     * @memberof FlagEventMemberRep
     */
    'firstName': string;
    /**
     * The member last name
     * @type {string}
     * @memberof FlagEventMemberRep
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface FlagEventRep
 */
export interface FlagEventRep {
    /**
     * The flag event ID
     * @type {string}
     * @memberof FlagEventRep
     */
    'id': string;
    /**
     * The project ID
     * @type {string}
     * @memberof FlagEventRep
     */
    'projectId': string;
    /**
     * The project key
     * @type {string}
     * @memberof FlagEventRep
     */
    'projectKey': string;
    /**
     * The environment ID
     * @type {string}
     * @memberof FlagEventRep
     */
    'environmentId'?: string;
    /**
     * The environment key
     * @type {string}
     * @memberof FlagEventRep
     */
    'environmentKey'?: string;
    /**
     * The flag key
     * @type {string}
     * @memberof FlagEventRep
     */
    'flagKey': string;
    /**
     * 
     * @type {string}
     * @memberof FlagEventRep
     */
    'eventType': string;
    /**
     * 
     * @type {number}
     * @memberof FlagEventRep
     */
    'eventTime': number;
    /**
     * The event description
     * @type {string}
     * @memberof FlagEventRep
     */
    'description': string;
    /**
     * The audit log entry ID
     * @type {string}
     * @memberof FlagEventRep
     */
    'auditLogEntryId'?: string;
    /**
     * 
     * @type {FlagEventMemberRep}
     * @memberof FlagEventRep
     */
    'member'?: FlagEventMemberRep;
    /**
     * The resource actions
     * @type {Array<string>}
     * @memberof FlagEventRep
     */
    'actions'?: Array<string>;
    /**
     * 
     * @type {FlagEventImpactRep}
     * @memberof FlagEventRep
     */
    'impact': FlagEventImpactRep;
    /**
     * 
     * @type {FlagEventExperimentCollection}
     * @memberof FlagEventRep
     */
    'experiments'?: FlagEventExperimentCollection;
}
/**
 * 
 * @export
 * @interface FlagFollowersByProjEnvGetRep
 */
export interface FlagFollowersByProjEnvGetRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagFollowersByProjEnvGetRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of flags and their followers
     * @type {Array<FollowersPerFlag>}
     * @memberof FlagFollowersByProjEnvGetRep
     */
    'items'?: Array<FollowersPerFlag>;
}
/**
 * 
 * @export
 * @interface FlagFollowersGetRep
 */
export interface FlagFollowersGetRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagFollowersGetRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of members who are following this flag
     * @type {Array<FollowFlagMember>}
     * @memberof FlagFollowersGetRep
     */
    'items': Array<FollowFlagMember>;
}
/**
 * 
 * @export
 * @interface FlagInput
 */
export interface FlagInput {
    /**
     * The ID of the variation or rollout of the flag to use. Use \"fallthrough\" for the default targeting behavior when the flag is on.
     * @type {string}
     * @memberof FlagInput
     */
    'ruleId': string;
    /**
     * The flag version
     * @type {number}
     * @memberof FlagInput
     */
    'flagConfigVersion': number;
}
/**
 * 
 * @export
 * @interface FlagLinkCollectionRep
 */
export interface FlagLinkCollectionRep {
    /**
     * An array of flag links
     * @type {Array<FlagLinkRep>}
     * @memberof FlagLinkCollectionRep
     */
    'items': Array<FlagLinkRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkCollectionRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagLinkMember
 */
export interface FlagLinkMember {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkMember
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlagLinkMember
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface FlagLinkPost
 */
export interface FlagLinkPost {
    /**
     * The flag link key
     * @type {string}
     * @memberof FlagLinkPost
     */
    'key'?: string;
    /**
     * The integration key for an integration whose <code>manifest.json</code> includes the <code>flagLink</code> capability, if this is a flag link for an existing integration. Do not include for URL flag links.
     * @type {string}
     * @memberof FlagLinkPost
     */
    'integrationKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlagLinkPost
     */
    'timestamp'?: number;
    /**
     * The URL for the external resource you are linking the flag to
     * @type {string}
     * @memberof FlagLinkPost
     */
    'deepLink'?: string;
    /**
     * The title of the flag link
     * @type {string}
     * @memberof FlagLinkPost
     */
    'title'?: string;
    /**
     * The description of the flag link
     * @type {string}
     * @memberof FlagLinkPost
     */
    'description'?: string;
    /**
     * The metadata required by this integration in order to create a flag link, if this is a flag link for an existing integration. Defined in the integration\'s <code>manifest.json</code> file under <code>flagLink</code>.
     * @type {{ [key: string]: string; }}
     * @memberof FlagLinkPost
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface FlagLinkRep
 */
export interface FlagLinkRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagLinkRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The flag link key
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_key'?: string;
    /**
     * The integration key for an integration whose <code>manifest.json</code> includes the <code>flagLink</code> capability, if this is a flag link for an existing integration
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_integrationKey'?: string;
    /**
     * The ID of this flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_id': string;
    /**
     * The URL for the external resource the flag is linked to
     * @type {string}
     * @memberof FlagLinkRep
     */
    '_deepLink': string;
    /**
     * 
     * @type {TimestampRep}
     * @memberof FlagLinkRep
     */
    '_timestamp': TimestampRep;
    /**
     * The title of the flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    'title'?: string;
    /**
     * The description of the flag link
     * @type {string}
     * @memberof FlagLinkRep
     */
    'description'?: string;
    /**
     * The metadata required by this integration in order to create a flag link, if this is a flag link for an existing integration. Defined in the integration\'s <code>manifest.json</code> file under <code>flagLink</code>.
     * @type {{ [key: string]: string; }}
     * @memberof FlagLinkRep
     */
    '_metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof FlagLinkRep
     */
    '_createdAt': number;
    /**
     * 
     * @type {FlagLinkMember}
     * @memberof FlagLinkRep
     */
    '_member'?: FlagLinkMember;
}
/**
 * 
 * @export
 * @interface FlagListingRep
 */
export interface FlagListingRep {
    /**
     * The flag name
     * @type {string}
     * @memberof FlagListingRep
     */
    'name': string;
    /**
     * The flag key
     * @type {string}
     * @memberof FlagListingRep
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagListingRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof FlagListingRep
     */
    '_site'?: Link;
}
/**
 * 
 * @export
 * @interface FlagMigrationSettingsRep
 */
export interface FlagMigrationSettingsRep {
    /**
     * The context kind targeted by this migration flag. Only applicable for six-stage migrations.
     * @type {string}
     * @memberof FlagMigrationSettingsRep
     */
    'contextKind'?: string;
    /**
     * The number of stages for this migration flag
     * @type {number}
     * @memberof FlagMigrationSettingsRep
     */
    'stageCount'?: number;
}
/**
 * 
 * @export
 * @interface FlagReferenceCollectionRep
 */
export interface FlagReferenceCollectionRep {
    /**
     * The total number of flag references
     * @type {number}
     * @memberof FlagReferenceCollectionRep
     */
    'totalCount': number;
    /**
     * A list of flag references
     * @type {Array<FlagReferenceRep>}
     * @memberof FlagReferenceCollectionRep
     */
    'items': Array<FlagReferenceRep>;
}
/**
 * 
 * @export
 * @interface FlagReferenceRep
 */
export interface FlagReferenceRep {
    /**
     * The project key
     * @type {string}
     * @memberof FlagReferenceRep
     */
    'projectKey': string;
    /**
     * The flag key
     * @type {string}
     * @memberof FlagReferenceRep
     */
    'flagKey': string;
    /**
     * The number of references added
     * @type {number}
     * @memberof FlagReferenceRep
     */
    'referencesAdded': number;
    /**
     * The number of references removed
     * @type {number}
     * @memberof FlagReferenceRep
     */
    'referencesRemoved': number;
}
/**
 * 
 * @export
 * @interface FlagRep
 */
export interface FlagRep {
    /**
     * The targeting rule
     * @type {string}
     * @memberof FlagRep
     */
    'targetingRule'?: string;
    /**
     * The rule description
     * @type {string}
     * @memberof FlagRep
     */
    'targetingRuleDescription'?: string;
    /**
     * An array of clauses used for individual targeting based on attributes
     * @type {Array<any>}
     * @memberof FlagRep
     */
    'targetingRuleClauses'?: Array<any>;
    /**
     * The flag version
     * @type {number}
     * @memberof FlagRep
     */
    'flagConfigVersion'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FlagRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface FlagScheduledChangesInput
 */
export interface FlagScheduledChangesInput {
    /**
     * Optional comment describing the update to the scheduled changes
     * @type {string}
     * @memberof FlagScheduledChangesInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagScheduledChangesInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface FlagSempatch
 */
export interface FlagSempatch {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagSempatch
     */
    'instructions': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof FlagSempatch
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface FlagStatusRep
 */
export interface FlagStatusRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof FlagStatusRep
     */
    '_links': { [key: string]: Link; };
    /**
     * Status of the flag
     * @type {string}
     * @memberof FlagStatusRep
     */
    'name'?: string;
    /**
     * Timestamp of last time flag was requested
     * @type {string}
     * @memberof FlagStatusRep
     */
    'lastRequested'?: string;
    /**
     * Default value seen from code
     * @type {any}
     * @memberof FlagStatusRep
     */
    'default'?: any;
}
/**
 * 
 * @export
 * @interface FlagSummary
 */
export interface FlagSummary {
    /**
     * 
     * @type {{ [key: string]: VariationSummary; }}
     * @memberof FlagSummary
     */
    'variations': { [key: string]: VariationSummary; };
    /**
     * The number of prerequisites for this flag
     * @type {number}
     * @memberof FlagSummary
     */
    'prerequisites': number;
}
/**
 * 
 * @export
 * @interface FlagTriggerInput
 */
export interface FlagTriggerInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof FlagTriggerInput
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating. This should be an array with objects that look like <code>{\"kind\": \"trigger_action\"}</code>.
     * @type {Array<{ [key: string]: any; }>}
     * @memberof FlagTriggerInput
     */
    'instructions'?: Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface FollowFlagMember
 */
export interface FollowFlagMember {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof FollowFlagMember
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof FollowFlagMember
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof FollowFlagMember
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof FollowFlagMember
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof FollowFlagMember
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof FollowFlagMember
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface FollowersPerFlag
 */
export interface FollowersPerFlag {
    /**
     * The flag key
     * @type {string}
     * @memberof FollowersPerFlag
     */
    'flagKey'?: string;
    /**
     * A list of members who are following this flag
     * @type {Array<FollowFlagMember>}
     * @memberof FollowersPerFlag
     */
    'followers'?: Array<FollowFlagMember>;
}
/**
 * 
 * @export
 * @interface ForbiddenErrorRep
 */
export interface ForbiddenErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof ForbiddenErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof ForbiddenErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface HunkRep
 */
export interface HunkRep {
    /**
     * Line number of beginning of code reference hunk
     * @type {number}
     * @memberof HunkRep
     */
    'startingLineNumber': number;
    /**
     * Contextual lines of code that include the referenced feature flag
     * @type {string}
     * @memberof HunkRep
     */
    'lines'?: string;
    /**
     * The project key
     * @type {string}
     * @memberof HunkRep
     */
    'projKey'?: string;
    /**
     * The feature flag key
     * @type {string}
     * @memberof HunkRep
     */
    'flagKey'?: string;
    /**
     * An array of flag key aliases
     * @type {Array<string>}
     * @memberof HunkRep
     */
    'aliases'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Import
 */
export interface Import {
    /**
     * The import ID
     * @type {string}
     * @memberof Import
     */
    'id': string;
    /**
     * The segment key
     * @type {string}
     * @memberof Import
     */
    'segmentKey': string;
    /**
     * 
     * @type {number}
     * @memberof Import
     */
    'creationTime': number;
    /**
     * The import mode used, either <code>merge</code> or <code>replace</code>
     * @type {string}
     * @memberof Import
     */
    'mode': string;
    /**
     * The import status
     * @type {string}
     * @memberof Import
     */
    'status': string;
    /**
     * The imported files and their status
     * @type {Array<FileRep>}
     * @memberof Import
     */
    'files'?: Array<FileRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Import
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface InitiatorRep
 */
export interface InitiatorRep {
    /**
     * The name of the member who initiated the export
     * @type {string}
     * @memberof InitiatorRep
     */
    'name'?: string;
    /**
     * The email address of the member who initiated the export
     * @type {string}
     * @memberof InitiatorRep
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface InsightGroup
 */
export interface InsightGroup {
    /**
     * 
     * @type {Environment}
     * @memberof InsightGroup
     */
    'environment'?: Environment;
    /**
     * 
     * @type {InsightGroupScores}
     * @memberof InsightGroup
     */
    'scores'?: InsightGroupScores;
    /**
     * 
     * @type {InsightGroupCollectionScoreMetadata}
     * @memberof InsightGroup
     */
    'scoreMetadata'?: InsightGroupCollectionScoreMetadata;
    /**
     * The insight group key
     * @type {string}
     * @memberof InsightGroup
     */
    'key': string;
    /**
     * The insight group name
     * @type {string}
     * @memberof InsightGroup
     */
    'name': string;
    /**
     * The project key
     * @type {string}
     * @memberof InsightGroup
     */
    'projectKey': string;
    /**
     * The environment key
     * @type {string}
     * @memberof InsightGroup
     */
    'environmentKey': string;
    /**
     * The application keys
     * @type {Array<string>}
     * @memberof InsightGroup
     */
    'applicationKeys'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof InsightGroup
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface InsightGroupCollection
 */
export interface InsightGroupCollection {
    /**
     * The total number of insight groups
     * @type {number}
     * @memberof InsightGroupCollection
     */
    'totalCount': number;
    /**
     * A list of insight groups
     * @type {Array<InsightGroup>}
     * @memberof InsightGroupCollection
     */
    'items': Array<InsightGroup>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof InsightGroupCollection
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {InsightGroupCollectionMetadata}
     * @memberof InsightGroupCollection
     */
    'metadata'?: InsightGroupCollectionMetadata;
    /**
     * 
     * @type {InsightGroupCollectionScoreMetadata}
     * @memberof InsightGroupCollection
     */
    'scoreMetadata'?: InsightGroupCollectionScoreMetadata;
}
/**
 * 
 * @export
 * @interface InsightGroupCollectionMetadata
 */
export interface InsightGroupCollectionMetadata {
    /**
     * 
     * @type {InsightGroupsCountByIndicator}
     * @memberof InsightGroupCollectionMetadata
     */
    'countByIndicator': InsightGroupsCountByIndicator;
}
/**
 * 
 * @export
 * @interface InsightGroupCollectionScoreMetadata
 */
export interface InsightGroupCollectionScoreMetadata {
    /**
     * 
     * @type {InsightPeriod}
     * @memberof InsightGroupCollectionScoreMetadata
     */
    'period': InsightPeriod;
    /**
     * 
     * @type {InsightPeriod}
     * @memberof InsightGroupCollectionScoreMetadata
     */
    'lastPeriod': InsightPeriod;
}
/**
 * 
 * @export
 * @interface InsightGroupScores
 */
export interface InsightGroupScores {
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'overall': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'deploymentFrequency': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'deploymentFailureRate': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'leadTime': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'impactSize': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'experimentationCoverage': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'flagHealth': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'velocity': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'risk': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'efficiency': InsightsMetricScore;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightGroupScores
     */
    'creationRatio'?: InsightsMetricScore;
}
/**
 * 
 * @export
 * @interface InsightGroupsCountByIndicator
 */
export interface InsightGroupsCountByIndicator {
    /**
     * The number of insight groups with an excellent indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'excellent': number;
    /**
     * The number of insight groups with a good indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'good': number;
    /**
     * The number of insight groups with a fair indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'fair': number;
    /**
     * The number of insight groups with a needs attention indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'needsAttention': number;
    /**
     * The number of insight groups with a not calculated indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'notCalculated': number;
    /**
     * The number of insight groups with an unknown indicator
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'unknown': number;
    /**
     * The total number of insight groups
     * @type {number}
     * @memberof InsightGroupsCountByIndicator
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface InsightPeriod
 */
export interface InsightPeriod {
    /**
     * 
     * @type {number}
     * @memberof InsightPeriod
     */
    'startTime': number;
    /**
     * 
     * @type {number}
     * @memberof InsightPeriod
     */
    'endTime': number;
}
/**
 * 
 * @export
 * @interface InsightScores
 */
export interface InsightScores {
    /**
     * 
     * @type {InsightPeriod}
     * @memberof InsightScores
     */
    'period': InsightPeriod;
    /**
     * 
     * @type {InsightPeriod}
     * @memberof InsightScores
     */
    'lastPeriod': InsightPeriod;
    /**
     * 
     * @type {InsightGroupScores}
     * @memberof InsightScores
     */
    'scores': InsightGroupScores;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof InsightScores
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface InsightsChart
 */
export interface InsightsChart {
    /**
     * 
     * @type {InsightsChartMetadata}
     * @memberof InsightsChart
     */
    'metadata': InsightsChartMetadata;
    /**
     * Series data for the chart
     * @type {Array<InsightsChartSeries>}
     * @memberof InsightsChart
     */
    'series': Array<InsightsChartSeries>;
}
/**
 * 
 * @export
 * @interface InsightsChartBounds
 */
export interface InsightsChartBounds {
    /**
     * Name of the bound
     * @type {string}
     * @memberof InsightsChartBounds
     */
    'name': string;
    /**
     * Value of the bound
     * @type {number}
     * @memberof InsightsChartBounds
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface InsightsChartMetadata
 */
export interface InsightsChartMetadata {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InsightsChartMetadata
     */
    'summary': { [key: string]: any; };
    /**
     * Name of the chart
     * @type {string}
     * @memberof InsightsChartMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: InsightsChartMetric; }}
     * @memberof InsightsChartMetadata
     */
    'metrics'?: { [key: string]: InsightsChartMetric; };
    /**
     * 
     * @type {InsightsChartSeriesMetadataAxis}
     * @memberof InsightsChartMetadata
     */
    'xAxis': InsightsChartSeriesMetadataAxis;
    /**
     * 
     * @type {InsightsChartSeriesMetadataAxis}
     * @memberof InsightsChartMetadata
     */
    'yAxis': InsightsChartSeriesMetadataAxis;
}
/**
 * 
 * @export
 * @interface InsightsChartMetric
 */
export interface InsightsChartMetric {
    /**
     * Metric indicator tier
     * @type {string}
     * @memberof InsightsChartMetric
     */
    'indicator': string;
    /**
     * Metric value
     * @type {number}
     * @memberof InsightsChartMetric
     */
    'value': number;
    /**
     * Metric unit
     * @type {string}
     * @memberof InsightsChartMetric
     */
    'unit': string;
    /**
     * Metric modifier
     * @type {string}
     * @memberof InsightsChartMetric
     */
    'modifier': string;
    /**
     * Metric indicator tiers
     * @type {Array<InsightsMetricTierDefinition>}
     * @memberof InsightsChartMetric
     */
    'tiers': Array<InsightsMetricTierDefinition>;
}
/**
 * 
 * @export
 * @interface InsightsChartSeries
 */
export interface InsightsChartSeries {
    /**
     * 
     * @type {InsightsChartSeriesMetadata}
     * @memberof InsightsChartSeries
     */
    'metadata': InsightsChartSeriesMetadata;
    /**
     * Data points for the series
     * @type {Array<InsightsChartSeriesDataPoint>}
     * @memberof InsightsChartSeries
     */
    'data': Array<InsightsChartSeriesDataPoint>;
}
/**
 * 
 * @export
 * @interface InsightsChartSeriesDataPoint
 */
export interface InsightsChartSeriesDataPoint {
    /**
     * X-axis value
     * @type {number}
     * @memberof InsightsChartSeriesDataPoint
     */
    'x': number;
    /**
     * Y-axis value
     * @type {number}
     * @memberof InsightsChartSeriesDataPoint
     */
    'y': number;
    /**
     * Additional values for the data point
     * @type {{ [key: string]: any; }}
     * @memberof InsightsChartSeriesDataPoint
     */
    'values'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface InsightsChartSeriesMetadata
 */
export interface InsightsChartSeriesMetadata {
    /**
     * Name of the series
     * @type {string}
     * @memberof InsightsChartSeriesMetadata
     */
    'name': string;
    /**
     * Aggregate count of the series values
     * @type {number}
     * @memberof InsightsChartSeriesMetadata
     */
    'count'?: number;
    /**
     * Bounds for the series data
     * @type {Array<InsightsChartBounds>}
     * @memberof InsightsChartSeriesMetadata
     */
    'bounds'?: Array<InsightsChartBounds>;
}
/**
 * 
 * @export
 * @interface InsightsChartSeriesMetadataAxis
 */
export interface InsightsChartSeriesMetadataAxis {
    /**
     * Unit of the axis
     * @type {string}
     * @memberof InsightsChartSeriesMetadataAxis
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface InsightsMetricIndicatorRange
 */
export interface InsightsMetricIndicatorRange {
    /**
     * The minimum value for the indicator range
     * @type {number}
     * @memberof InsightsMetricIndicatorRange
     */
    'min': number;
    /**
     * The maximum value for the indicator range
     * @type {number}
     * @memberof InsightsMetricIndicatorRange
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface InsightsMetricScore
 */
export interface InsightsMetricScore {
    /**
     * The score for the metric
     * @type {number}
     * @memberof InsightsMetricScore
     */
    'score': number;
    /**
     * The keys of the metrics that were aggregated to calculate this score
     * @type {Array<string>}
     * @memberof InsightsMetricScore
     */
    'aggregateOf'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof InsightsMetricScore
     */
    'diffVsLastPeriod'?: number;
    /**
     * 
     * @type {string}
     * @memberof InsightsMetricScore
     */
    'indicator': string;
    /**
     * 
     * @type {InsightsMetricIndicatorRange}
     * @memberof InsightsMetricScore
     */
    'indicatorRange': InsightsMetricIndicatorRange;
    /**
     * 
     * @type {InsightsMetricScore}
     * @memberof InsightsMetricScore
     */
    'lastPeriod'?: InsightsMetricScore;
}
/**
 * 
 * @export
 * @interface InsightsMetricTierDefinition
 */
export interface InsightsMetricTierDefinition {
    /**
     * Metric indicator tier
     * @type {string}
     * @memberof InsightsMetricTierDefinition
     */
    'indicator': string;
    /**
     * Metric indicator description
     * @type {string}
     * @memberof InsightsMetricTierDefinition
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface InsightsRepository
 */
export interface InsightsRepository {
    /**
     * The repository ID
     * @type {string}
     * @memberof InsightsRepository
     */
    '_id': string;
    /**
     * The repository version
     * @type {number}
     * @memberof InsightsRepository
     */
    'version': number;
    /**
     * The repository key
     * @type {string}
     * @memberof InsightsRepository
     */
    'key': string;
    /**
     * The repository type
     * @type {string}
     * @memberof InsightsRepository
     */
    'type': string;
    /**
     * The repository URL
     * @type {string}
     * @memberof InsightsRepository
     */
    'url': string;
    /**
     * The repository main branch
     * @type {string}
     * @memberof InsightsRepository
     */
    'mainBranch': string;
    /**
     * 
     * @type {ProjectSummaryCollection}
     * @memberof InsightsRepository
     */
    'projects'?: ProjectSummaryCollection;
}
/**
 * 
 * @export
 * @interface InsightsRepositoryCollection
 */
export interface InsightsRepositoryCollection {
    /**
     * Total number of repositories
     * @type {number}
     * @memberof InsightsRepositoryCollection
     */
    'totalCount': number;
    /**
     * List of repositories
     * @type {Array<InsightsRepository>}
     * @memberof InsightsRepositoryCollection
     */
    'items': Array<InsightsRepository>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof InsightsRepositoryCollection
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface InsightsRepositoryProject
 */
export interface InsightsRepositoryProject {
    /**
     * The repository key
     * @type {string}
     * @memberof InsightsRepositoryProject
     */
    'repositoryKey': string;
    /**
     * The project key
     * @type {string}
     * @memberof InsightsRepositoryProject
     */
    'projectKey': string;
}
/**
 * 
 * @export
 * @interface InsightsRepositoryProjectCollection
 */
export interface InsightsRepositoryProjectCollection {
    /**
     * Total number of repository project associations
     * @type {number}
     * @memberof InsightsRepositoryProjectCollection
     */
    'totalCount': number;
    /**
     * List of repository project associations
     * @type {Array<InsightsRepositoryProject>}
     * @memberof InsightsRepositoryProjectCollection
     */
    'items': Array<InsightsRepositoryProject>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof InsightsRepositoryProjectCollection
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface InsightsRepositoryProjectMappings
 */
export interface InsightsRepositoryProjectMappings {
    /**
     * 
     * @type {Array<InsightsRepositoryProject>}
     * @memberof InsightsRepositoryProjectMappings
     */
    'mappings': Array<InsightsRepositoryProject>;
}
/**
 * 
 * @export
 * @interface InstructionUserRequest
 */
export interface InstructionUserRequest {
    /**
     * The type of change to make to the removal date for this user from individual targeting for this flag.
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'kind': InstructionUserRequestKindEnum;
    /**
     * The flag key
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'flagKey': string;
    /**
     * ID of a variation on the flag
     * @type {string}
     * @memberof InstructionUserRequest
     */
    'variationId': string;
    /**
     * The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. Required if <code>kind</code> is <code>addExpireUserTargetDate</code> or <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof InstructionUserRequest
     */
    'value'?: number;
    /**
     * The version of the expiring user target to update. Optional and only used if <code>kind</code> is <code>updateExpireUserTargetDate</code>. If included, update will fail if version doesn\'t match current version of the expiring user target.
     * @type {number}
     * @memberof InstructionUserRequest
     */
    'version'?: number;
}

export const InstructionUserRequestKindEnum = {
    AddExpireUserTargetDate: 'addExpireUserTargetDate',
    UpdateExpireUserTargetDate: 'updateExpireUserTargetDate',
    RemoveExpireUserTargetDate: 'removeExpireUserTargetDate'
} as const;

export type InstructionUserRequestKindEnum = typeof InstructionUserRequestKindEnum[keyof typeof InstructionUserRequestKindEnum];

/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Integration
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The ID for this integration audit log subscription
     * @type {string}
     * @memberof Integration
     */
    '_id'?: string;
    /**
     * The type of integration
     * @type {string}
     * @memberof Integration
     */
    'kind'?: string;
    /**
     * A human-friendly name for the integration
     * @type {string}
     * @memberof Integration
     */
    'name'?: string;
    /**
     * Details on configuration for an integration of this type. Refer to the <code>formVariables</code> field in the corresponding <code>manifest.json</code> for a full list of fields for each integration.
     * @type {{ [key: string]: any; }}
     * @memberof Integration
     */
    'config'?: { [key: string]: any; };
    /**
     * Represents a Custom role policy, defining a resource kinds filter the integration audit log subscription responds to.
     * @type {Array<Statement>}
     * @memberof Integration
     */
    'statements'?: Array<Statement>;
    /**
     * Whether the integration is currently active
     * @type {boolean}
     * @memberof Integration
     */
    'on'?: boolean;
    /**
     * An array of tags for this integration
     * @type {Array<string>}
     * @memberof Integration
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Access}
     * @memberof Integration
     */
    '_access'?: Access;
    /**
     * 
     * @type {IntegrationSubscriptionStatusRep}
     * @memberof Integration
     */
    '_status'?: IntegrationSubscriptionStatusRep;
    /**
     * Slack webhook receiver URL. Only used for legacy Slack webhook integrations.
     * @type {string}
     * @memberof Integration
     */
    'url'?: string;
    /**
     * Datadog API key. Only used for legacy Datadog webhook integrations.
     * @type {string}
     * @memberof Integration
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfiguration
 */
export interface IntegrationDeliveryConfiguration {
    /**
     * 
     * @type {IntegrationDeliveryConfigurationLinks}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_links': IntegrationDeliveryConfigurationLinks;
    /**
     * The integration ID
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_id': string;
    /**
     * The integration key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'integrationKey': string;
    /**
     * The project key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'projectKey': string;
    /**
     * The environment key
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'environmentKey': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof IntegrationDeliveryConfiguration
     */
    'config': { [key: string]: any; };
    /**
     * Whether the configuration is turned on
     * @type {boolean}
     * @memberof IntegrationDeliveryConfiguration
     */
    'on': boolean;
    /**
     * List of tags for this configuration
     * @type {Array<string>}
     * @memberof IntegrationDeliveryConfiguration
     */
    'tags': Array<string>;
    /**
     * Name of the configuration
     * @type {string}
     * @memberof IntegrationDeliveryConfiguration
     */
    'name': string;
    /**
     * Version of the current configuration
     * @type {number}
     * @memberof IntegrationDeliveryConfiguration
     */
    'version': number;
    /**
     * 
     * @type {Access}
     * @memberof IntegrationDeliveryConfiguration
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationCollection
 */
export interface IntegrationDeliveryConfigurationCollection {
    /**
     * 
     * @type {IntegrationDeliveryConfigurationCollectionLinks}
     * @memberof IntegrationDeliveryConfigurationCollection
     */
    '_links': IntegrationDeliveryConfigurationCollectionLinks;
    /**
     * An array of integration delivery configurations
     * @type {Array<IntegrationDeliveryConfiguration>}
     * @memberof IntegrationDeliveryConfigurationCollection
     */
    'items': Array<IntegrationDeliveryConfiguration>;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationCollectionLinks
 */
export interface IntegrationDeliveryConfigurationCollectionLinks {
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationCollectionLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationCollectionLinks
     */
    'parent'?: Link;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationLinks
 */
export interface IntegrationDeliveryConfigurationLinks {
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'self': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'parent': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'project': Link;
    /**
     * 
     * @type {Link}
     * @memberof IntegrationDeliveryConfigurationLinks
     */
    'environment': Link;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationPost
 */
export interface IntegrationDeliveryConfigurationPost {
    /**
     * Whether the integration configuration is active. Default value is false.
     * @type {boolean}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'on'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'config': { [key: string]: any; };
    /**
     * Tags to associate with the integration
     * @type {Array<string>}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'tags'?: Array<string>;
    /**
     * Name to identify the integration
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationPost
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationDeliveryConfigurationResponse
 */
export interface IntegrationDeliveryConfigurationResponse {
    /**
     * The status code returned by the validation
     * @type {number}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'timestamp'?: number;
    /**
     * JSON response to the validation request
     * @type {string}
     * @memberof IntegrationDeliveryConfigurationResponse
     */
    'responseBody'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationMetadata
 */
export interface IntegrationMetadata {
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'externalId': string;
    /**
     * 
     * @type {IntegrationStatus}
     * @memberof IntegrationMetadata
     */
    'externalStatus': IntegrationStatus;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'externalUrl': string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'lastChecked': number;
}
/**
 * 
 * @export
 * @interface IntegrationStatus
 */
export interface IntegrationStatus {
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatus
     */
    'display': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatus
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface IntegrationStatusRep
 */
export interface IntegrationStatusRep {
    /**
     * 
     * @type {number}
     * @memberof IntegrationStatusRep
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationStatusRep
     */
    'responseBody'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationStatusRep
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface IntegrationSubscriptionStatusRep
 */
export interface IntegrationSubscriptionStatusRep {
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'successCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'lastSuccess'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'lastError'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'errorCount'?: number;
    /**
     * 
     * @type {Array<IntegrationStatusRep>}
     * @memberof IntegrationSubscriptionStatusRep
     */
    'errors'?: Array<IntegrationStatusRep>;
}
/**
 * 
 * @export
 * @interface Integrations
 */
export interface Integrations {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof Integrations
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Array<Integration>}
     * @memberof Integrations
     */
    'items'?: Array<Integration>;
    /**
     * 
     * @type {string}
     * @memberof Integrations
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface InvalidRequestErrorRep
 */
export interface InvalidRequestErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof InvalidRequestErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof InvalidRequestErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface IpList
 */
export interface IpList {
    /**
     * A list of the IP addresses LaunchDarkly\'s service uses
     * @type {Array<string>}
     * @memberof IpList
     */
    'addresses': Array<string>;
    /**
     * A list of the IP addresses outgoing webhook notifications use
     * @type {Array<string>}
     * @memberof IpList
     */
    'outboundAddresses': Array<string>;
}
/**
 * 
 * @export
 * @interface IterationInput
 */
export interface IterationInput {
    /**
     * The expected outcome of this experiment
     * @type {string}
     * @memberof IterationInput
     */
    'hypothesis': string;
    /**
     * Whether to allow the experiment to reassign traffic to different variations when you increase or decrease the traffic in your experiment audience (true) or keep all traffic assigned to its initial variation (false). Defaults to true.
     * @type {boolean}
     * @memberof IterationInput
     */
    'canReshuffleTraffic'?: boolean;
    /**
     * 
     * @type {Array<MetricInput>}
     * @memberof IterationInput
     */
    'metrics': Array<MetricInput>;
    /**
     * The key of the primary metric for this experiment. Either <code>primarySingleMetricKey</code> or <code>primaryFunnelKey</code> must be present.
     * @type {string}
     * @memberof IterationInput
     */
    'primarySingleMetricKey'?: string;
    /**
     * The key of the primary funnel group for this experiment. Either <code>primarySingleMetricKey</code> or <code>primaryFunnelKey</code> must be present.
     * @type {string}
     * @memberof IterationInput
     */
    'primaryFunnelKey'?: string;
    /**
     * 
     * @type {Array<TreatmentInput>}
     * @memberof IterationInput
     */
    'treatments': Array<TreatmentInput>;
    /**
     * 
     * @type {{ [key: string]: FlagInput; }}
     * @memberof IterationInput
     */
    'flags': { [key: string]: FlagInput; };
    /**
     * The unit of randomization for this iteration. Defaults to user.
     * @type {string}
     * @memberof IterationInput
     */
    'randomizationUnit'?: string;
}
/**
 * 
 * @export
 * @interface IterationRep
 */
export interface IterationRep {
    /**
     * The iteration ID
     * @type {string}
     * @memberof IterationRep
     */
    '_id'?: string;
    /**
     * The expected outcome of this experiment
     * @type {string}
     * @memberof IterationRep
     */
    'hypothesis': string;
    /**
     * The status of the iteration: <code>not_started</code>, <code>running</code>, <code>stopped</code>
     * @type {string}
     * @memberof IterationRep
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'startedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof IterationRep
     */
    'endedAt'?: number;
    /**
     * The ID of the treatment chosen when the experiment stopped
     * @type {string}
     * @memberof IterationRep
     */
    'winningTreatmentId'?: string;
    /**
     * The reason you stopped the experiment
     * @type {string}
     * @memberof IterationRep
     */
    'winningReason'?: string;
    /**
     * Whether the experiment may reassign traffic to different variations when the experiment audience changes (true) or must keep all traffic assigned to its initial variation (false).
     * @type {boolean}
     * @memberof IterationRep
     */
    'canReshuffleTraffic'?: boolean;
    /**
     * Details on the flag used in this experiment
     * @type {{ [key: string]: FlagRep; }}
     * @memberof IterationRep
     */
    'flags'?: { [key: string]: FlagRep; };
    /**
     * 
     * @type {DependentMetricOrMetricGroupRep}
     * @memberof IterationRep
     */
    'primaryMetric'?: DependentMetricOrMetricGroupRep;
    /**
     * 
     * @type {MetricV2Rep}
     * @memberof IterationRep
     */
    'primarySingleMetric'?: MetricV2Rep;
    /**
     * 
     * @type {DependentMetricGroupRepWithMetrics}
     * @memberof IterationRep
     */
    'primaryFunnel'?: DependentMetricGroupRepWithMetrics;
    /**
     * The unit of randomization for this iteration
     * @type {string}
     * @memberof IterationRep
     */
    'randomizationUnit'?: string;
    /**
     * Details on the variations you are testing in the experiment
     * @type {Array<TreatmentRep>}
     * @memberof IterationRep
     */
    'treatments'?: Array<TreatmentRep>;
    /**
     * Deprecated, use <code>metrics</code> instead. Details on the secondary metrics for this experiment.
     * @type {Array<MetricV2Rep>}
     * @memberof IterationRep
     * @deprecated
     */
    'secondaryMetrics'?: Array<MetricV2Rep>;
    /**
     * Details on the metrics for this experiment
     * @type {Array<DependentMetricOrMetricGroupRep>}
     * @memberof IterationRep
     */
    'metrics'?: Array<DependentMetricOrMetricGroupRep>;
}
/**
 * 
 * @export
 * @interface LastSeenMetadata
 */
export interface LastSeenMetadata {
    /**
     * The ID of the token used in the member\'s last session
     * @type {string}
     * @memberof LastSeenMetadata
     */
    'tokenId'?: string;
}
/**
 * 
 * @export
 * @interface LeadTimeStagesRep
 */
export interface LeadTimeStagesRep {
    /**
     * The coding duration in milliseconds
     * @type {number}
     * @memberof LeadTimeStagesRep
     */
    'codingDurationMs': number;
    /**
     * The review duration in milliseconds
     * @type {number}
     * @memberof LeadTimeStagesRep
     */
    'reviewDurationMs'?: number;
    /**
     * The wait duration between merge time and deploy start time in milliseconds
     * @type {number}
     * @memberof LeadTimeStagesRep
     */
    'waitDurationMs'?: number;
    /**
     * The deploy duration in milliseconds
     * @type {number}
     * @memberof LeadTimeStagesRep
     */
    'deployDurationMs'?: number;
    /**
     * The total lead time in milliseconds
     * @type {number}
     * @memberof LeadTimeStagesRep
     */
    'totalLeadTimeMs'?: number;
}
/**
 * 
 * @export
 * @interface LegacyExperimentRep
 */
export interface LegacyExperimentRep {
    /**
     * 
     * @type {string}
     * @memberof LegacyExperimentRep
     */
    'metricKey'?: string;
    /**
     * 
     * @type {MetricListingRep}
     * @memberof LegacyExperimentRep
     */
    '_metric'?: MetricListingRep;
    /**
     * 
     * @type {Array<string>}
     * @memberof LegacyExperimentRep
     */
    'environments'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: ExperimentEnvironmentSettingRep; }}
     * @memberof LegacyExperimentRep
     */
    '_environmentSettings'?: { [key: string]: ExperimentEnvironmentSettingRep; };
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface MaintainerRep
 */
export interface MaintainerRep {
    /**
     * 
     * @type {MemberSummary}
     * @memberof MaintainerRep
     */
    'member'?: MemberSummary;
    /**
     * 
     * @type {MemberTeamSummaryRep}
     * @memberof MaintainerRep
     */
    'team'?: MemberTeamSummaryRep;
}
/**
 * 
 * @export
 * @interface MaintainerTeam
 */
export interface MaintainerTeam {
    /**
     * The key of the maintainer team
     * @type {string}
     * @memberof MaintainerTeam
     */
    'key': string;
    /**
     * A human-friendly name for the maintainer team
     * @type {string}
     * @memberof MaintainerTeam
     */
    'name': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MaintainerTeam
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Member
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof Member
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof Member
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof Member
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof Member
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * Whether the member has a pending invitation
     * @type {boolean}
     * @memberof Member
     */
    '_pendingInvite': boolean;
    /**
     * Whether the member\'s email address has been verified
     * @type {boolean}
     * @memberof Member
     */
    '_verified': boolean;
    /**
     * The member\'s email address before it has been verified, for accounts where email verification is required
     * @type {string}
     * @memberof Member
     */
    '_pendingEmail'?: string;
    /**
     * The set of custom roles (as keys) assigned to the member
     * @type {Array<string>}
     * @memberof Member
     */
    'customRoles': Array<string>;
    /**
     * Whether multi-factor authentication is enabled for this member
     * @type {string}
     * @memberof Member
     */
    'mfa': string;
    /**
     * Default dashboards that the member has chosen to ignore
     * @type {Array<string>}
     * @memberof Member
     */
    'excludedDashboards'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    '_lastSeen': number;
    /**
     * 
     * @type {LastSeenMetadata}
     * @memberof Member
     */
    '_lastSeenMetadata'?: LastSeenMetadata;
    /**
     * 
     * @type {IntegrationMetadata}
     * @memberof Member
     */
    '_integrationMetadata'?: IntegrationMetadata;
    /**
     * Details on the teams this member is assigned to
     * @type {Array<MemberTeamSummaryRep>}
     * @memberof Member
     */
    'teams'?: Array<MemberTeamSummaryRep>;
    /**
     * A list of permission grants. Permission grants allow a member to have access to a specific action, without having to create or update a custom role.
     * @type {Array<MemberPermissionGrantSummaryRep>}
     * @memberof Member
     */
    'permissionGrants'?: Array<MemberPermissionGrantSummaryRep>;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    'creationDate': number;
    /**
     * A list of OAuth providers
     * @type {Array<string>}
     * @memberof Member
     */
    'oauthProviders'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MemberDataRep
 */
export interface MemberDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof MemberDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The member ID
     * @type {string}
     * @memberof MemberDataRep
     */
    '_id'?: string;
    /**
     * The member email
     * @type {string}
     * @memberof MemberDataRep
     */
    'email'?: string;
    /**
     * The member first name
     * @type {string}
     * @memberof MemberDataRep
     */
    'firstName'?: string;
    /**
     * The member last name
     * @type {string}
     * @memberof MemberDataRep
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface MemberImportItem
 */
export interface MemberImportItem {
    /**
     * An error message, including CSV line number, if the <code>status</code> is <code>error</code>
     * @type {string}
     * @memberof MemberImportItem
     */
    'message'?: string;
    /**
     * Whether this member can be successfully imported (<code>success</code>) or not (<code>error</code>). Even if the status is <code>success</code>, members are only added to a team on a <code>201</code> response.
     * @type {string}
     * @memberof MemberImportItem
     */
    'status': string;
    /**
     * The email address for the member requested to be added to this team. May be blank or an error, such as \'invalid email format\', if the email address cannot be found or parsed.
     * @type {string}
     * @memberof MemberImportItem
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MemberPermissionGrantSummaryRep
 */
export interface MemberPermissionGrantSummaryRep {
    /**
     * The name of the group of related actions to allow. A permission grant may have either an <code>actionSet</code> or a list of <code>actions</code> but not both at the same time.
     * @type {string}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'actionSet'?: string;
    /**
     * A list of actions to allow. A permission grant may have either an <code>actionSet</code> or a list of <code>actions</code> but not both at the same time.
     * @type {Array<string>}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'actions'?: Array<string>;
    /**
     * The resource for which the actions are allowed
     * @type {string}
     * @memberof MemberPermissionGrantSummaryRep
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface MemberSummary
 */
export interface MemberSummary {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MemberSummary
     */
    '_links': { [key: string]: Link; };
    /**
     * The member\'s ID
     * @type {string}
     * @memberof MemberSummary
     */
    '_id': string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof MemberSummary
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof MemberSummary
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role. If the member has no custom roles, this role will be in effect.
     * @type {string}
     * @memberof MemberSummary
     */
    'role': string;
    /**
     * The member\'s email address
     * @type {string}
     * @memberof MemberSummary
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MemberTeamSummaryRep
 */
export interface MemberTeamSummaryRep {
    /**
     * A list of keys of the custom roles this team has access to
     * @type {Array<string>}
     * @memberof MemberTeamSummaryRep
     */
    'customRoleKeys': Array<string>;
    /**
     * The team key
     * @type {string}
     * @memberof MemberTeamSummaryRep
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof MemberTeamSummaryRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The team name
     * @type {string}
     * @memberof MemberTeamSummaryRep
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MemberTeamsPostInput
 */
export interface MemberTeamsPostInput {
    /**
     * List of team keys
     * @type {Array<string>}
     * @memberof MemberTeamsPostInput
     */
    'teamKeys': Array<string>;
}
/**
 * 
 * @export
 * @interface Members
 */
export interface Members {
    /**
     * An array of members
     * @type {Array<Member>}
     * @memberof Members
     */
    'items': Array<Member>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Members
     */
    '_links': { [key: string]: Link; };
    /**
     * The number of members returned
     * @type {number}
     * @memberof Members
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface MembersPatchInput
 */
export interface MembersPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof MembersPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof MembersPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface MethodNotAllowedErrorRep
 */
export interface MethodNotAllowedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof MethodNotAllowedErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof MethodNotAllowedErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MetricCollectionRep
 */
export interface MetricCollectionRep {
    /**
     * An array of metrics
     * @type {Array<MetricListingRep>}
     * @memberof MetricCollectionRep
     */
    'items'?: Array<MetricListingRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface MetricEventDefaultRep
 */
export interface MetricEventDefaultRep {
    /**
     * Whether to disable defaulting missing unit events when calculating results. Defaults to false
     * @type {boolean}
     * @memberof MetricEventDefaultRep
     */
    'disabled'?: boolean;
    /**
     * The default value applied to missing unit events. Only available when <code>disabled</code> is false. Defaults to 0
     * @type {number}
     * @memberof MetricEventDefaultRep
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface MetricGroupCollectionRep
 */
export interface MetricGroupCollectionRep {
    /**
     * An array of metric groups
     * @type {Array<MetricGroupRep>}
     * @memberof MetricGroupCollectionRep
     */
    'items': Array<MetricGroupRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricGroupCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface MetricGroupPost
 */
export interface MetricGroupPost {
    /**
     * A unique key to reference the metric group
     * @type {string}
     * @memberof MetricGroupPost
     */
    'key': string;
    /**
     * A human-friendly name for the metric group
     * @type {string}
     * @memberof MetricGroupPost
     */
    'name': string;
    /**
     * The type of the metric group
     * @type {string}
     * @memberof MetricGroupPost
     */
    'kind': MetricGroupPostKindEnum;
    /**
     * Description of the metric group
     * @type {string}
     * @memberof MetricGroupPost
     */
    'description'?: string;
    /**
     * The ID of the member who maintains this metric group
     * @type {string}
     * @memberof MetricGroupPost
     */
    'maintainerId': string;
    /**
     * Tags for the metric group
     * @type {Array<string>}
     * @memberof MetricGroupPost
     */
    'tags': Array<string>;
    /**
     * An ordered list of the metrics in this metric group
     * @type {Array<MetricInMetricGroupInput>}
     * @memberof MetricGroupPost
     */
    'metrics': Array<MetricInMetricGroupInput>;
}

export const MetricGroupPostKindEnum = {
    Funnel: 'funnel'
} as const;

export type MetricGroupPostKindEnum = typeof MetricGroupPostKindEnum[keyof typeof MetricGroupPostKindEnum];

/**
 * 
 * @export
 * @interface MetricGroupRep
 */
export interface MetricGroupRep {
    /**
     * The ID of this metric group
     * @type {string}
     * @memberof MetricGroupRep
     */
    '_id': string;
    /**
     * A unique key to reference the metric group
     * @type {string}
     * @memberof MetricGroupRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric group
     * @type {string}
     * @memberof MetricGroupRep
     */
    'name': string;
    /**
     * The type of the metric group
     * @type {string}
     * @memberof MetricGroupRep
     */
    'kind': MetricGroupRepKindEnum;
    /**
     * Description of the metric group
     * @type {string}
     * @memberof MetricGroupRep
     */
    'description'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricGroupRep
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof MetricGroupRep
     */
    '_access'?: Access;
    /**
     * Tags for the metric group
     * @type {Array<string>}
     * @memberof MetricGroupRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MetricGroupRep
     */
    '_creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof MetricGroupRep
     */
    '_lastModified': number;
    /**
     * 
     * @type {MaintainerRep}
     * @memberof MetricGroupRep
     */
    'maintainer': MaintainerRep;
    /**
     * An ordered list of the metrics in this metric group
     * @type {Array<MetricInGroupRep>}
     * @memberof MetricGroupRep
     */
    'metrics': Array<MetricInGroupRep>;
    /**
     * The version of this metric group
     * @type {number}
     * @memberof MetricGroupRep
     */
    '_version': number;
    /**
     * 
     * @type {Array<DependentExperimentRep>}
     * @memberof MetricGroupRep
     */
    'experiments'?: Array<DependentExperimentRep>;
    /**
     * The number of experiments using this metric group
     * @type {number}
     * @memberof MetricGroupRep
     */
    'experimentCount'?: number;
}

export const MetricGroupRepKindEnum = {
    Funnel: 'funnel',
    Standard: 'standard'
} as const;

export type MetricGroupRepKindEnum = typeof MetricGroupRepKindEnum[keyof typeof MetricGroupRepKindEnum];

/**
 * 
 * @export
 * @interface MetricGroupResultsRep
 */
export interface MetricGroupResultsRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricGroupResultsRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An ordered list of the metrics in this metric group, and each of their results
     * @type {Array<MetricInGroupResultsRep>}
     * @memberof MetricGroupResultsRep
     */
    'metrics': Array<MetricInGroupResultsRep>;
}
/**
 * 
 * @export
 * @interface MetricInGroupRep
 */
export interface MetricInGroupRep {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricInGroupRep
     */
    'key': string;
    /**
     * The version ID of the metric
     * @type {string}
     * @memberof MetricInGroupRep
     */
    '_versionId'?: string;
    /**
     * The metric name
     * @type {string}
     * @memberof MetricInGroupRep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricInGroupRep
     */
    'kind': MetricInGroupRepKindEnum;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricInGroupRep
     */
    'isNumeric'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricInGroupRep
     */
    '_links': { [key: string]: Link; };
    /**
     * Name of the metric when used within the associated metric group. Can be different from the original name of the metric. Required if and only if the metric group is a <code>funnel</code>.
     * @type {string}
     * @memberof MetricInGroupRep
     */
    'nameInGroup'?: string;
    /**
     * The randomization units for the metric
     * @type {Array<string>}
     * @memberof MetricInGroupRep
     */
    'randomizationUnits'?: Array<string>;
}

export const MetricInGroupRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricInGroupRepKindEnum = typeof MetricInGroupRepKindEnum[keyof typeof MetricInGroupRepKindEnum];

/**
 * 
 * @export
 * @interface MetricInGroupResultsRep
 */
export interface MetricInGroupResultsRep {
    /**
     * 
     * @type {MetricInGroupRep}
     * @memberof MetricInGroupResultsRep
     */
    'metric': MetricInGroupRep;
    /**
     * 
     * @type {ExperimentBayesianResultsRep}
     * @memberof MetricInGroupResultsRep
     */
    'results': ExperimentBayesianResultsRep;
}
/**
 * 
 * @export
 * @interface MetricInMetricGroupInput
 */
export interface MetricInMetricGroupInput {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricInMetricGroupInput
     */
    'key': string;
    /**
     * Name of the metric when used within the associated metric group. Can be different from the original name of the metric
     * @type {string}
     * @memberof MetricInMetricGroupInput
     */
    'nameInGroup': string;
}
/**
 * 
 * @export
 * @interface MetricInput
 */
export interface MetricInput {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricInput
     */
    'key': string;
    /**
     * Whether this is a metric group (true) or a metric (false). Defaults to false
     * @type {boolean}
     * @memberof MetricInput
     */
    'isGroup'?: boolean;
    /**
     * Deprecated, use <code>primarySingleMetricKey</code> and <code>primaryFunnelKey</code>. Whether this is a primary metric (true) or a secondary metric (false)
     * @type {boolean}
     * @memberof MetricInput
     * @deprecated
     */
    'primary'?: boolean;
}
/**
 * 
 * @export
 * @interface MetricListingRep
 */
export interface MetricListingRep {
    /**
     * The number of experiments using this metric
     * @type {number}
     * @memberof MetricListingRep
     */
    'experimentCount'?: number;
    /**
     * The number of metric groups using this metric
     * @type {number}
     * @memberof MetricListingRep
     */
    'metricGroupCount'?: number;
    /**
     * The ID of this metric
     * @type {string}
     * @memberof MetricListingRep
     */
    '_id': string;
    /**
     * The version ID of the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    '_versionId': string;
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricListingRep
     */
    'kind': MetricListingRepKindEnum;
    /**
     * The number of feature flags currently attached to this metric
     * @type {number}
     * @memberof MetricListingRep
     */
    '_attachedFlagCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricListingRep
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MetricListingRep
     */
    '_site'?: Link;
    /**
     * 
     * @type {Access}
     * @memberof MetricListingRep
     */
    '_access'?: Access;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricListingRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MetricListingRep
     */
    '_creationDate': number;
    /**
     * 
     * @type {Modification}
     * @memberof MetricListingRep
     */
    'lastModified'?: Modification;
    /**
     * The ID of the member who maintains this metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof MetricListingRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricListingRep
     */
    'description'?: string;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricListingRep
     */
    'isNumeric'?: boolean;
    /**
     * For custom metrics, the success criteria
     * @type {string}
     * @memberof MetricListingRep
     */
    'successCriteria'?: MetricListingRepSuccessCriteriaEnum;
    /**
     * For numeric custom metrics, the unit of measure
     * @type {string}
     * @memberof MetricListingRep
     */
    'unit'?: string;
    /**
     * For custom metrics, the event key to use in your code
     * @type {string}
     * @memberof MetricListingRep
     */
    'eventKey'?: string;
    /**
     * An array of randomization units allowed for this metric
     * @type {Array<string>}
     * @memberof MetricListingRep
     */
    'randomizationUnits'?: Array<string>;
    /**
     * The method by which multiple unit event values are aggregated
     * @type {string}
     * @memberof MetricListingRep
     */
    'unitAggregationType'?: MetricListingRepUnitAggregationTypeEnum;
    /**
     * The method for analyzing metric events
     * @type {string}
     * @memberof MetricListingRep
     */
    'analysisType'?: MetricListingRepAnalysisTypeEnum;
    /**
     * The percentile for the analysis method. An integer denoting the target percentile between 0 and 100. Required when <code>analysisType</code> is <code>percentile</code>.
     * @type {number}
     * @memberof MetricListingRep
     */
    'percentileValue'?: number;
    /**
     * 
     * @type {MetricEventDefaultRep}
     * @memberof MetricListingRep
     */
    'eventDefault'?: MetricEventDefaultRep;
}

export const MetricListingRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricListingRepKindEnum = typeof MetricListingRepKindEnum[keyof typeof MetricListingRepKindEnum];
export const MetricListingRepSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricListingRepSuccessCriteriaEnum = typeof MetricListingRepSuccessCriteriaEnum[keyof typeof MetricListingRepSuccessCriteriaEnum];
export const MetricListingRepUnitAggregationTypeEnum = {
    Average: 'average',
    Sum: 'sum'
} as const;

export type MetricListingRepUnitAggregationTypeEnum = typeof MetricListingRepUnitAggregationTypeEnum[keyof typeof MetricListingRepUnitAggregationTypeEnum];
export const MetricListingRepAnalysisTypeEnum = {
    Mean: 'mean',
    Percentile: 'percentile'
} as const;

export type MetricListingRepAnalysisTypeEnum = typeof MetricListingRepAnalysisTypeEnum[keyof typeof MetricListingRepAnalysisTypeEnum];

/**
 * 
 * @export
 * @interface MetricPost
 */
export interface MetricPost {
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricPost
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricPost
     */
    'name'?: string;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricPost
     */
    'description'?: string;
    /**
     * The kind of event your metric will track
     * @type {string}
     * @memberof MetricPost
     */
    'kind': MetricPostKindEnum;
    /**
     * One or more CSS selectors. Required for click metrics only.
     * @type {string}
     * @memberof MetricPost
     */
    'selector'?: string;
    /**
     * One or more target URLs. Required for click and pageview metrics only.
     * @type {Array<UrlPost>}
     * @memberof MetricPost
     */
    'urls'?: Array<UrlPost>;
    /**
     * Whether the metric is active. Set to <code>true</code> to record click or pageview metrics. Not applicable for custom metrics.
     * @type {boolean}
     * @memberof MetricPost
     */
    'isActive'?: boolean;
    /**
     * Whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>). Required for custom metrics only.
     * @type {boolean}
     * @memberof MetricPost
     */
    'isNumeric'?: boolean;
    /**
     * The unit of measure. Applicable for numeric custom metrics only.
     * @type {string}
     * @memberof MetricPost
     */
    'unit'?: string;
    /**
     * The event key to use in your code. Required for custom conversion/binary and custom numeric metrics only.
     * @type {string}
     * @memberof MetricPost
     */
    'eventKey'?: string;
    /**
     * Success criteria. Required for custom numeric metrics, optional for custom conversion metrics.
     * @type {string}
     * @memberof MetricPost
     */
    'successCriteria'?: MetricPostSuccessCriteriaEnum;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricPost
     */
    'tags'?: Array<string>;
    /**
     * An array of randomization units allowed for this metric
     * @type {Array<string>}
     * @memberof MetricPost
     */
    'randomizationUnits'?: Array<string>;
    /**
     * The method by which multiple unit event values are aggregated
     * @type {string}
     * @memberof MetricPost
     */
    'unitAggregationType'?: MetricPostUnitAggregationTypeEnum;
    /**
     * The method for analyzing metric events
     * @type {string}
     * @memberof MetricPost
     */
    'analysisType'?: string;
    /**
     * The percentile for the analysis method. An integer denoting the target percentile between 0 and 100. Required when <code>analysisType</code> is <code>percentile</code>.
     * @type {number}
     * @memberof MetricPost
     */
    'percentileValue'?: number;
    /**
     * 
     * @type {MetricEventDefaultRep}
     * @memberof MetricPost
     */
    'eventDefault'?: MetricEventDefaultRep;
}

export const MetricPostKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricPostKindEnum = typeof MetricPostKindEnum[keyof typeof MetricPostKindEnum];
export const MetricPostSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricPostSuccessCriteriaEnum = typeof MetricPostSuccessCriteriaEnum[keyof typeof MetricPostSuccessCriteriaEnum];
export const MetricPostUnitAggregationTypeEnum = {
    Average: 'average',
    Sum: 'sum'
} as const;

export type MetricPostUnitAggregationTypeEnum = typeof MetricPostUnitAggregationTypeEnum[keyof typeof MetricPostUnitAggregationTypeEnum];

/**
 * 
 * @export
 * @interface MetricRep
 */
export interface MetricRep {
    /**
     * The number of experiments using this metric
     * @type {number}
     * @memberof MetricRep
     */
    'experimentCount'?: number;
    /**
     * The number of metric groups using this metric
     * @type {number}
     * @memberof MetricRep
     */
    'metricGroupCount'?: number;
    /**
     * The ID of this metric
     * @type {string}
     * @memberof MetricRep
     */
    '_id': string;
    /**
     * The version ID of the metric
     * @type {string}
     * @memberof MetricRep
     */
    '_versionId': string;
    /**
     * A unique key to reference the metric
     * @type {string}
     * @memberof MetricRep
     */
    'key': string;
    /**
     * A human-friendly name for the metric
     * @type {string}
     * @memberof MetricRep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricRep
     */
    'kind': MetricRepKindEnum;
    /**
     * The number of feature flags currently attached to this metric
     * @type {number}
     * @memberof MetricRep
     */
    '_attachedFlagCount'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricRep
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MetricRep
     */
    '_site'?: Link;
    /**
     * 
     * @type {Access}
     * @memberof MetricRep
     */
    '_access'?: Access;
    /**
     * Tags for the metric
     * @type {Array<string>}
     * @memberof MetricRep
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MetricRep
     */
    '_creationDate': number;
    /**
     * 
     * @type {Modification}
     * @memberof MetricRep
     */
    'lastModified'?: Modification;
    /**
     * The ID of the member who maintains this metric
     * @type {string}
     * @memberof MetricRep
     */
    'maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof MetricRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Description of the metric
     * @type {string}
     * @memberof MetricRep
     */
    'description'?: string;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricRep
     */
    'isNumeric'?: boolean;
    /**
     * For custom metrics, the success criteria
     * @type {string}
     * @memberof MetricRep
     */
    'successCriteria'?: MetricRepSuccessCriteriaEnum;
    /**
     * For numeric custom metrics, the unit of measure
     * @type {string}
     * @memberof MetricRep
     */
    'unit'?: string;
    /**
     * For custom metrics, the event key to use in your code
     * @type {string}
     * @memberof MetricRep
     */
    'eventKey'?: string;
    /**
     * An array of randomization units allowed for this metric
     * @type {Array<string>}
     * @memberof MetricRep
     */
    'randomizationUnits'?: Array<string>;
    /**
     * The method by which multiple unit event values are aggregated
     * @type {string}
     * @memberof MetricRep
     */
    'unitAggregationType'?: MetricRepUnitAggregationTypeEnum;
    /**
     * The method for analyzing metric events
     * @type {string}
     * @memberof MetricRep
     */
    'analysisType'?: MetricRepAnalysisTypeEnum;
    /**
     * The percentile for the analysis method. An integer denoting the target percentile between 0 and 100. Required when <code>analysisType</code> is <code>percentile</code>.
     * @type {number}
     * @memberof MetricRep
     */
    'percentileValue'?: number;
    /**
     * 
     * @type {MetricEventDefaultRep}
     * @memberof MetricRep
     */
    'eventDefault'?: MetricEventDefaultRep;
    /**
     * 
     * @type {Array<DependentExperimentRep>}
     * @memberof MetricRep
     */
    'experiments'?: Array<DependentExperimentRep>;
    /**
     * Metric groups that use this metric
     * @type {Array<DependentMetricGroupRep>}
     * @memberof MetricRep
     */
    'metricGroups'?: Array<DependentMetricGroupRep>;
    /**
     * Whether the metric is active
     * @type {boolean}
     * @memberof MetricRep
     */
    'isActive'?: boolean;
    /**
     * Details on the flags attached to this metric
     * @type {Array<FlagListingRep>}
     * @memberof MetricRep
     */
    '_attachedFeatures'?: Array<FlagListingRep>;
    /**
     * Version of the metric
     * @type {number}
     * @memberof MetricRep
     */
    '_version'?: number;
    /**
     * For click metrics, the CSS selectors
     * @type {string}
     * @memberof MetricRep
     */
    'selector'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof MetricRep
     */
    'urls'?: Array<{ [key: string]: any; }>;
}

export const MetricRepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricRepKindEnum = typeof MetricRepKindEnum[keyof typeof MetricRepKindEnum];
export const MetricRepSuccessCriteriaEnum = {
    HigherThanBaseline: 'HigherThanBaseline',
    LowerThanBaseline: 'LowerThanBaseline'
} as const;

export type MetricRepSuccessCriteriaEnum = typeof MetricRepSuccessCriteriaEnum[keyof typeof MetricRepSuccessCriteriaEnum];
export const MetricRepUnitAggregationTypeEnum = {
    Average: 'average',
    Sum: 'sum'
} as const;

export type MetricRepUnitAggregationTypeEnum = typeof MetricRepUnitAggregationTypeEnum[keyof typeof MetricRepUnitAggregationTypeEnum];
export const MetricRepAnalysisTypeEnum = {
    Mean: 'mean',
    Percentile: 'percentile'
} as const;

export type MetricRepAnalysisTypeEnum = typeof MetricRepAnalysisTypeEnum[keyof typeof MetricRepAnalysisTypeEnum];

/**
 * 
 * @export
 * @interface MetricSeen
 */
export interface MetricSeen {
    /**
     * Whether the metric has received an event for this iteration
     * @type {boolean}
     * @memberof MetricSeen
     */
    'ever'?: boolean;
    /**
     * Timestamp of when the metric most recently received an event for this iteration
     * @type {number}
     * @memberof MetricSeen
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface MetricV2Rep
 */
export interface MetricV2Rep {
    /**
     * The metric key
     * @type {string}
     * @memberof MetricV2Rep
     */
    'key': string;
    /**
     * The version ID of the metric
     * @type {string}
     * @memberof MetricV2Rep
     */
    '_versionId'?: string;
    /**
     * The metric name
     * @type {string}
     * @memberof MetricV2Rep
     */
    'name': string;
    /**
     * The kind of event the metric tracks
     * @type {string}
     * @memberof MetricV2Rep
     */
    'kind': MetricV2RepKindEnum;
    /**
     * For custom metrics, whether to track numeric changes in value against a baseline (<code>true</code>) or to track a conversion when an end user takes an action (<code>false</code>).
     * @type {boolean}
     * @memberof MetricV2Rep
     */
    'isNumeric'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MetricV2Rep
     */
    '_links': { [key: string]: Link; };
}

export const MetricV2RepKindEnum = {
    Pageview: 'pageview',
    Click: 'click',
    Custom: 'custom'
} as const;

export type MetricV2RepKindEnum = typeof MetricV2RepKindEnum[keyof typeof MetricV2RepKindEnum];

/**
 * 
 * @export
 * @interface MigrationSafetyIssueRep
 */
export interface MigrationSafetyIssueRep {
    /**
     * The ID of the rule which caused this issue
     * @type {string}
     * @memberof MigrationSafetyIssueRep
     */
    'causingRuleId'?: string;
    /**
     * A list of the IDs of the rules which are affected by this issue. <code>fallthrough</code> is a sentinel value for the default rule.
     * @type {Array<string>}
     * @memberof MigrationSafetyIssueRep
     */
    'affectedRuleIds'?: Array<string>;
    /**
     * A description of the issue that <code>causingRuleId</code> has caused for <code>affectedRuleIds</code>.
     * @type {string}
     * @memberof MigrationSafetyIssueRep
     */
    'issue'?: string;
    /**
     * Whether the changes caused by <code>causingRuleId</code> bring inconsistency to the old system
     * @type {boolean}
     * @memberof MigrationSafetyIssueRep
     */
    'oldSystemAffected'?: boolean;
}
/**
 * 
 * @export
 * @interface MigrationSettingsPost
 */
export interface MigrationSettingsPost {
    /**
     * Context kind for a migration with 6 stages, where data is being moved
     * @type {string}
     * @memberof MigrationSettingsPost
     */
    'contextKind'?: string;
    /**
     * 
     * @type {number}
     * @memberof MigrationSettingsPost
     */
    'stageCount': number;
}
/**
 * 
 * @export
 * @interface Modification
 */
export interface Modification {
    /**
     * 
     * @type {string}
     * @memberof Modification
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface MultiEnvironmentDependentFlag
 */
export interface MultiEnvironmentDependentFlag {
    /**
     * The flag name
     * @type {string}
     * @memberof MultiEnvironmentDependentFlag
     */
    'name'?: string;
    /**
     * The flag key
     * @type {string}
     * @memberof MultiEnvironmentDependentFlag
     */
    'key': string;
    /**
     * A list of environments in which the dependent flag appears
     * @type {Array<DependentFlagEnvironment>}
     * @memberof MultiEnvironmentDependentFlag
     */
    'environments': Array<DependentFlagEnvironment>;
}
/**
 * 
 * @export
 * @interface MultiEnvironmentDependentFlags
 */
export interface MultiEnvironmentDependentFlags {
    /**
     * An array of dependent flags with their environment information
     * @type {Array<MultiEnvironmentDependentFlag>}
     * @memberof MultiEnvironmentDependentFlags
     */
    'items': Array<MultiEnvironmentDependentFlag>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof MultiEnvironmentDependentFlags
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {Link}
     * @memberof MultiEnvironmentDependentFlags
     */
    '_site': Link;
}
/**
 * 
 * @export
 * @interface NewMemberForm
 */
export interface NewMemberForm {
    /**
     * The member\'s email
     * @type {string}
     * @memberof NewMemberForm
     */
    'email': string;
    /**
     * The member\'s password
     * @type {string}
     * @memberof NewMemberForm
     */
    'password'?: string;
    /**
     * The member\'s first name
     * @type {string}
     * @memberof NewMemberForm
     */
    'firstName'?: string;
    /**
     * The member\'s last name
     * @type {string}
     * @memberof NewMemberForm
     */
    'lastName'?: string;
    /**
     * The member\'s built-in role
     * @type {string}
     * @memberof NewMemberForm
     */
    'role'?: NewMemberFormRoleEnum;
    /**
     * An array of the member\'s custom roles
     * @type {Array<string>}
     * @memberof NewMemberForm
     */
    'customRoles'?: Array<string>;
    /**
     * An array of the member\'s teams
     * @type {Array<string>}
     * @memberof NewMemberForm
     */
    'teamKeys'?: Array<string>;
}

export const NewMemberFormRoleEnum = {
    Reader: 'reader',
    Writer: 'writer',
    Admin: 'admin',
    NoAccess: 'no_access'
} as const;

export type NewMemberFormRoleEnum = typeof NewMemberFormRoleEnum[keyof typeof NewMemberFormRoleEnum];

/**
 * 
 * @export
 * @interface NotFoundErrorRep
 */
export interface NotFoundErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof NotFoundErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof NotFoundErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OauthClientPost
 */
export interface OauthClientPost {
    /**
     * The name of your new LaunchDarkly OAuth 2.0 client.
     * @type {string}
     * @memberof OauthClientPost
     */
    'name'?: string;
    /**
     * The redirect URI for your new OAuth 2.0 application. This should be an absolute URL conforming with the standard HTTPS protocol.
     * @type {string}
     * @memberof OauthClientPost
     */
    'redirectUri'?: string;
    /**
     * Description of your OAuth 2.0 client.
     * @type {string}
     * @memberof OauthClientPost
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ParameterDefault
 */
export interface ParameterDefault {
    /**
     * The default value for the given parameter
     * @type {any}
     * @memberof ParameterDefault
     */
    'value'?: any;
    /**
     * Variation value for boolean flags. Not applicable for non-boolean flags.
     * @type {boolean}
     * @memberof ParameterDefault
     */
    'booleanVariationValue'?: boolean;
    /**
     * 
     * @type {RuleClause}
     * @memberof ParameterDefault
     */
    'ruleClause'?: RuleClause;
}
/**
 * 
 * @export
 * @interface ParameterRep
 */
export interface ParameterRep {
    /**
     * 
     * @type {string}
     * @memberof ParameterRep
     */
    'variationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterRep
     */
    'flagKey'?: string;
}
/**
 * 
 * @export
 * @interface ParentResourceRep
 */
export interface ParentResourceRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof ParentResourceRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The name of the parent resource
     * @type {string}
     * @memberof ParentResourceRep
     */
    'name'?: string;
    /**
     * The parent\'s resource specifier
     * @type {string}
     * @memberof ParentResourceRep
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface PatchFailedErrorRep
 */
export interface PatchFailedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof PatchFailedErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof PatchFailedErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PatchFlagsRequest
 */
export interface PatchFlagsRequest {
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof PatchFlagsRequest
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PatchFlagsRequest
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * The type of operation to perform
     * @type {string}
     * @memberof PatchOperation
     */
    'op': string;
    /**
     * A JSON Pointer string specifying the part of the document to operate on
     * @type {string}
     * @memberof PatchOperation
     */
    'path': string;
    /**
     * A JSON value used in \"add\", \"replace\", and \"test\" operations
     * @type {any}
     * @memberof PatchOperation
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface PatchSegmentExpiringTargetInputRep
 */
export interface PatchSegmentExpiringTargetInputRep {
    /**
     * Optional description of changes
     * @type {string}
     * @memberof PatchSegmentExpiringTargetInputRep
     */
    'comment'?: string;
    /**
     * Semantic patch instructions for the desired changes to the resource
     * @type {Array<PatchSegmentExpiringTargetInstruction>}
     * @memberof PatchSegmentExpiringTargetInputRep
     */
    'instructions': Array<PatchSegmentExpiringTargetInstruction>;
}
/**
 * 
 * @export
 * @interface PatchSegmentExpiringTargetInstruction
 */
export interface PatchSegmentExpiringTargetInstruction {
    /**
     * The type of change to make to the context\'s removal date from this segment
     * @type {string}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'kind': PatchSegmentExpiringTargetInstructionKindEnum;
    /**
     * A unique key used to represent the context
     * @type {string}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'contextKey': string;
    /**
     * The kind of context
     * @type {string}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'contextKind': string;
    /**
     * The segment\'s target type
     * @type {string}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'targetType': PatchSegmentExpiringTargetInstructionTargetTypeEnum;
    /**
     * The time, in Unix milliseconds, when the context should be removed from this segment. Required if <code>kind</code> is <code>addExpiringTarget</code> or <code>updateExpiringTarget</code>.
     * @type {number}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'value'?: number;
    /**
     * The version of the expiring target to update. Optional and only used if <code>kind</code> is <code>updateExpiringTarget</code>. If included, update will fail if version doesn\'t match current version of the expiring target.
     * @type {number}
     * @memberof PatchSegmentExpiringTargetInstruction
     */
    'version'?: number;
}

export const PatchSegmentExpiringTargetInstructionKindEnum = {
    AddExpiringTarget: 'addExpiringTarget',
    UpdateExpiringTarget: 'updateExpiringTarget',
    RemoveExpiringTarget: 'removeExpiringTarget'
} as const;

export type PatchSegmentExpiringTargetInstructionKindEnum = typeof PatchSegmentExpiringTargetInstructionKindEnum[keyof typeof PatchSegmentExpiringTargetInstructionKindEnum];
export const PatchSegmentExpiringTargetInstructionTargetTypeEnum = {
    Included: 'included',
    Excluded: 'excluded'
} as const;

export type PatchSegmentExpiringTargetInstructionTargetTypeEnum = typeof PatchSegmentExpiringTargetInstructionTargetTypeEnum[keyof typeof PatchSegmentExpiringTargetInstructionTargetTypeEnum];

/**
 * 
 * @export
 * @interface PatchSegmentInstruction
 */
export interface PatchSegmentInstruction {
    /**
     * The type of change to make to the user\'s removal date from this segment
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'kind': PatchSegmentInstructionKindEnum;
    /**
     * A unique key used to represent the user
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'userKey': string;
    /**
     * The segment\'s target type
     * @type {string}
     * @memberof PatchSegmentInstruction
     */
    'targetType': PatchSegmentInstructionTargetTypeEnum;
    /**
     * The time, in Unix milliseconds, when the user should be removed from this segment. Required if <code>kind</code> is <code>addExpireUserTargetDate</code> or <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof PatchSegmentInstruction
     */
    'value'?: number;
    /**
     * The version of the segment to update. Required if <code>kind</code> is <code>updateExpireUserTargetDate</code>.
     * @type {number}
     * @memberof PatchSegmentInstruction
     */
    'version'?: number;
}

export const PatchSegmentInstructionKindEnum = {
    AddExpireUserTargetDate: 'addExpireUserTargetDate',
    UpdateExpireUserTargetDate: 'updateExpireUserTargetDate',
    RemoveExpireUserTargetDate: 'removeExpireUserTargetDate'
} as const;

export type PatchSegmentInstructionKindEnum = typeof PatchSegmentInstructionKindEnum[keyof typeof PatchSegmentInstructionKindEnum];
export const PatchSegmentInstructionTargetTypeEnum = {
    Included: 'included',
    Excluded: 'excluded'
} as const;

export type PatchSegmentInstructionTargetTypeEnum = typeof PatchSegmentInstructionTargetTypeEnum[keyof typeof PatchSegmentInstructionTargetTypeEnum];

/**
 * 
 * @export
 * @interface PatchSegmentRequest
 */
export interface PatchSegmentRequest {
    /**
     * Optional description of changes
     * @type {string}
     * @memberof PatchSegmentRequest
     */
    'comment'?: string;
    /**
     * Semantic patch instructions for the desired changes to the resource
     * @type {Array<PatchSegmentInstruction>}
     * @memberof PatchSegmentRequest
     */
    'instructions': Array<PatchSegmentInstruction>;
}
/**
 * 
 * @export
 * @interface PatchUsersRequest
 */
export interface PatchUsersRequest {
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof PatchUsersRequest
     */
    'comment'?: string;
    /**
     * The instructions to perform when updating
     * @type {Array<InstructionUserRequest>}
     * @memberof PatchUsersRequest
     */
    'instructions': Array<InstructionUserRequest>;
}
/**
 * 
 * @export
 * @interface PatchWithComment
 */
export interface PatchWithComment {
    /**
     * 
     * @type {Array<PatchOperation>}
     * @memberof PatchWithComment
     */
    'patch': Array<PatchOperation>;
    /**
     * Optional comment
     * @type {string}
     * @memberof PatchWithComment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface PermissionGrantInput
 */
export interface PermissionGrantInput {
    /**
     * A group of related actions to allow. Specify either <code>actionSet</code> or <code>actions</code>. Use <code>maintainTeam</code> to add team maintainers.
     * @type {string}
     * @memberof PermissionGrantInput
     */
    'actionSet'?: PermissionGrantInputActionSetEnum;
    /**
     * A list of actions to allow. Specify either <code>actionSet</code> or <code>actions</code>. To learn more, read [Role actions](https://docs.launchdarkly.com/home/members/role-actions).
     * @type {Array<string>}
     * @memberof PermissionGrantInput
     */
    'actions'?: Array<string>;
    /**
     * A list of member IDs who receive the permission grant.
     * @type {Array<string>}
     * @memberof PermissionGrantInput
     */
    'memberIDs'?: Array<string>;
}

export const PermissionGrantInputActionSetEnum = {
    MaintainTeam: 'maintainTeam'
} as const;

export type PermissionGrantInputActionSetEnum = typeof PermissionGrantInputActionSetEnum[keyof typeof PermissionGrantInputActionSetEnum];

/**
 * 
 * @export
 * @interface Phase
 */
export interface Phase {
    /**
     * The phase ID
     * @type {string}
     * @memberof Phase
     */
    'id': string;
    /**
     * 
     * @type {Array<Audience>}
     * @memberof Phase
     */
    'audiences': Array<Audience>;
    /**
     * The release phase name
     * @type {string}
     * @memberof Phase
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PostApprovalRequestApplyRequest
 */
export interface PostApprovalRequestApplyRequest {
    /**
     * Optional comment about the approval request
     * @type {string}
     * @memberof PostApprovalRequestApplyRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface PostApprovalRequestReviewRequest
 */
export interface PostApprovalRequestReviewRequest {
    /**
     * The type of review for this approval request
     * @type {string}
     * @memberof PostApprovalRequestReviewRequest
     */
    'kind'?: PostApprovalRequestReviewRequestKindEnum;
    /**
     * Optional comment about the approval request
     * @type {string}
     * @memberof PostApprovalRequestReviewRequest
     */
    'comment'?: string;
}

export const PostApprovalRequestReviewRequestKindEnum = {
    Approve: 'approve',
    Comment: 'comment',
    Decline: 'decline'
} as const;

export type PostApprovalRequestReviewRequestKindEnum = typeof PostApprovalRequestReviewRequestKindEnum[keyof typeof PostApprovalRequestReviewRequestKindEnum];

/**
 * 
 * @export
 * @interface PostDeploymentEventInput
 */
export interface PostDeploymentEventInput {
    /**
     * The project key
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'projectKey': string;
    /**
     * The environment key
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'environmentKey': string;
    /**
     * The application key. This defines the granularity at which you want to view your insights metrics. Typically it is the name of one of the GitHub repositories that you use in this project.<br/><br/>LaunchDarkly automatically creates a new application each time you send a unique application key.
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'applicationKey': string;
    /**
     * The application name. This defines how the application is displayed
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'applicationName'?: string;
    /**
     * The kind of application. Default: <code>server</code>
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'applicationKind'?: PostDeploymentEventInputApplicationKindEnum;
    /**
     * The application version. You can set the application version to any string that includes only letters, numbers, periods (<code>.</code>), hyphens (<code>-</code>), or underscores (<code>_</code>).<br/><br/>We recommend setting the application version to at least the first seven characters of the SHA or to the tag of the GitHub commit for this deployment.
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'version': string;
    /**
     * The version name. This defines how the version is displayed
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'versionName'?: string;
    /**
     * The event type
     * @type {string}
     * @memberof PostDeploymentEventInput
     */
    'eventType': PostDeploymentEventInputEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PostDeploymentEventInput
     */
    'eventTime'?: number;
    /**
     * A JSON object containing metadata about the event
     * @type {{ [key: string]: any; }}
     * @memberof PostDeploymentEventInput
     */
    'eventMetadata'?: { [key: string]: any; };
    /**
     * A JSON object containing metadata about the deployment
     * @type {{ [key: string]: any; }}
     * @memberof PostDeploymentEventInput
     */
    'deploymentMetadata'?: { [key: string]: any; };
}

export const PostDeploymentEventInputApplicationKindEnum = {
    Server: 'server',
    Browser: 'browser',
    Mobile: 'mobile'
} as const;

export type PostDeploymentEventInputApplicationKindEnum = typeof PostDeploymentEventInputApplicationKindEnum[keyof typeof PostDeploymentEventInputApplicationKindEnum];
export const PostDeploymentEventInputEventTypeEnum = {
    Started: 'started',
    Failed: 'failed',
    Finished: 'finished',
    Custom: 'custom'
} as const;

export type PostDeploymentEventInputEventTypeEnum = typeof PostDeploymentEventInputEventTypeEnum[keyof typeof PostDeploymentEventInputEventTypeEnum];

/**
 * 
 * @export
 * @interface PostFlagScheduledChangesInput
 */
export interface PostFlagScheduledChangesInput {
    /**
     * Optional comment describing the scheduled changes
     * @type {string}
     * @memberof PostFlagScheduledChangesInput
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostFlagScheduledChangesInput
     */
    'executionDate': number;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PostFlagScheduledChangesInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface PostInsightGroupParams
 */
export interface PostInsightGroupParams {
    /**
     * The name of the insight group
     * @type {string}
     * @memberof PostInsightGroupParams
     */
    'name': string;
    /**
     * The key of the insight group
     * @type {string}
     * @memberof PostInsightGroupParams
     */
    'key': string;
    /**
     * The projectKey to be associated with the insight group
     * @type {string}
     * @memberof PostInsightGroupParams
     */
    'projectKey': string;
    /**
     * The environmentKey to be associated with the insight group
     * @type {string}
     * @memberof PostInsightGroupParams
     */
    'environmentKey': string;
    /**
     * The application keys to associate with the insight group. If not provided, the insight group will include data from all applications.
     * @type {Array<string>}
     * @memberof PostInsightGroupParams
     */
    'applicationKeys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Prerequisite
 */
export interface Prerequisite {
    /**
     * 
     * @type {string}
     * @memberof Prerequisite
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof Prerequisite
     */
    'variation': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Project
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this project
     * @type {string}
     * @memberof Project
     */
    '_id': string;
    /**
     * The key of this project
     * @type {string}
     * @memberof Project
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default
     * @type {boolean}
     * @memberof Project
     */
    'includeInSnippetByDefault': boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof Project
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * A human-friendly name for the project
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {Access}
     * @memberof Project
     */
    '_access'?: Access;
    /**
     * A list of tags for the project
     * @type {Array<string>}
     * @memberof Project
     */
    'tags': Array<string>;
    /**
     * The key of the default release pipeline for this project
     * @type {string}
     * @memberof Project
     */
    'defaultReleasePipelineKey'?: string;
    /**
     * 
     * @type {Environments}
     * @memberof Project
     */
    'environments'?: Environments;
}
/**
 * 
 * @export
 * @interface ProjectPost
 */
export interface ProjectPost {
    /**
     * A human-friendly name for the project.
     * @type {string}
     * @memberof ProjectPost
     */
    'name': string;
    /**
     * A unique key used to reference the project in your code.
     * @type {string}
     * @memberof ProjectPost
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default.
     * @type {boolean}
     * @memberof ProjectPost
     */
    'includeInSnippetByDefault'?: boolean;
    /**
     * 
     * @type {DefaultClientSideAvailabilityPost}
     * @memberof ProjectPost
     */
    'defaultClientSideAvailability'?: DefaultClientSideAvailabilityPost;
    /**
     * Tags for the project
     * @type {Array<string>}
     * @memberof ProjectPost
     */
    'tags'?: Array<string>;
    /**
     * Creates the provided environments for this project. If omitted default environments will be created instead.
     * @type {Array<EnvironmentPost>}
     * @memberof ProjectPost
     */
    'environments'?: Array<EnvironmentPost>;
}
/**
 * 
 * @export
 * @interface ProjectRep
 */
export interface ProjectRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectRep
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this project
     * @type {string}
     * @memberof ProjectRep
     */
    '_id': string;
    /**
     * The key of this project
     * @type {string}
     * @memberof ProjectRep
     */
    'key': string;
    /**
     * Whether or not flags created in this project are made available to the client-side JavaScript SDK by default
     * @type {boolean}
     * @memberof ProjectRep
     */
    'includeInSnippetByDefault': boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof ProjectRep
     */
    'defaultClientSideAvailability'?: ClientSideAvailability;
    /**
     * A human-friendly name for the project
     * @type {string}
     * @memberof ProjectRep
     */
    'name': string;
    /**
     * 
     * @type {Access}
     * @memberof ProjectRep
     */
    '_access'?: Access;
    /**
     * A list of tags for the project
     * @type {Array<string>}
     * @memberof ProjectRep
     */
    'tags': Array<string>;
    /**
     * The key of the default release pipeline for this project
     * @type {string}
     * @memberof ProjectRep
     */
    'defaultReleasePipelineKey'?: string;
    /**
     * A list of environments for the project
     * @type {Array<Environment>}
     * @memberof ProjectRep
     */
    'environments': Array<Environment>;
}
/**
 * 
 * @export
 * @interface ProjectSummary
 */
export interface ProjectSummary {
    /**
     * The ID of this project
     * @type {string}
     * @memberof ProjectSummary
     */
    '_id': string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectSummary
     */
    '_links': { [key: string]: Link; };
    /**
     * The project key
     * @type {string}
     * @memberof ProjectSummary
     */
    'key': string;
    /**
     * The project name
     * @type {string}
     * @memberof ProjectSummary
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectSummaryCollection
 */
export interface ProjectSummaryCollection {
    /**
     * 
     * @type {number}
     * @memberof ProjectSummaryCollection
     */
    'totalCount': number;
    /**
     * 
     * @type {Array<ProjectSummary>}
     * @memberof ProjectSummaryCollection
     */
    'items': Array<ProjectSummary>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof ProjectSummaryCollection
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Projects
 */
export interface Projects {
    /**
     * A link to this resource.
     * @type {{ [key: string]: Link; }}
     * @memberof Projects
     */
    '_links': { [key: string]: Link; };
    /**
     * List of projects.
     * @type {Array<Project>}
     * @memberof Projects
     */
    'items': Array<Project>;
    /**
     * 
     * @type {number}
     * @memberof Projects
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface PullRequestCollectionRep
 */
export interface PullRequestCollectionRep {
    /**
     * The total number of pull requests
     * @type {number}
     * @memberof PullRequestCollectionRep
     */
    'totalCount': number;
    /**
     * A list of pull requests
     * @type {Array<PullRequestRep>}
     * @memberof PullRequestCollectionRep
     */
    'items': Array<PullRequestRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof PullRequestCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface PullRequestLeadTimeRep
 */
export interface PullRequestLeadTimeRep {
    /**
     * The coding duration in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'codingDurationMs': number;
    /**
     * The review duration in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'reviewDurationMs'?: number;
    /**
     * The max wait duration between merge time and deploy start time in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'maxWaitDurationMs'?: number;
    /**
     * The average wait duration between merge time and deploy start time in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'avgWaitDurationMs'?: number;
    /**
     * The max deploy duration in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'maxDeployDurationMs'?: number;
    /**
     * The average deploy duration in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'avgDeployDurationMs'?: number;
    /**
     * The max total lead time in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'maxTotalLeadTimeMs'?: number;
    /**
     * The average total lead time in milliseconds
     * @type {number}
     * @memberof PullRequestLeadTimeRep
     */
    'avgTotalLeadTimeMs'?: number;
}
/**
 * 
 * @export
 * @interface PullRequestRep
 */
export interface PullRequestRep {
    /**
     * The pull request internal ID
     * @type {string}
     * @memberof PullRequestRep
     */
    'id': string;
    /**
     * The pull request number
     * @type {string}
     * @memberof PullRequestRep
     */
    'externalId': string;
    /**
     * The pull request title
     * @type {string}
     * @memberof PullRequestRep
     */
    'title': string;
    /**
     * The pull request status
     * @type {string}
     * @memberof PullRequestRep
     */
    'status': string;
    /**
     * The pull request author
     * @type {string}
     * @memberof PullRequestRep
     */
    'author': string;
    /**
     * 
     * @type {number}
     * @memberof PullRequestRep
     */
    'createTime': number;
    /**
     * 
     * @type {number}
     * @memberof PullRequestRep
     */
    'mergeTime'?: number;
    /**
     * The pull request merge commit key
     * @type {string}
     * @memberof PullRequestRep
     */
    'mergeCommitKey'?: string;
    /**
     * The pull request base commit key
     * @type {string}
     * @memberof PullRequestRep
     */
    'baseCommitKey': string;
    /**
     * The pull request head commit key
     * @type {string}
     * @memberof PullRequestRep
     */
    'headCommitKey': string;
    /**
     * The number of files changed
     * @type {number}
     * @memberof PullRequestRep
     */
    'filesChanged': number;
    /**
     * The number of lines added
     * @type {number}
     * @memberof PullRequestRep
     */
    'linesAdded': number;
    /**
     * The number of lines deleted
     * @type {number}
     * @memberof PullRequestRep
     */
    'linesDeleted': number;
    /**
     * The pull request URL
     * @type {string}
     * @memberof PullRequestRep
     */
    'url': string;
    /**
     * 
     * @type {DeploymentCollectionRep}
     * @memberof PullRequestRep
     */
    'deployments'?: DeploymentCollectionRep;
    /**
     * 
     * @type {FlagReferenceCollectionRep}
     * @memberof PullRequestRep
     */
    'flagReferences'?: FlagReferenceCollectionRep;
    /**
     * 
     * @type {PullRequestLeadTimeRep}
     * @memberof PullRequestRep
     */
    'leadTime'?: PullRequestLeadTimeRep;
}
/**
 * 
 * @export
 * @interface PutBranch
 */
export interface PutBranch {
    /**
     * The branch name
     * @type {string}
     * @memberof PutBranch
     */
    'name': string;
    /**
     * An ID representing the branch HEAD. For example, a commit SHA.
     * @type {string}
     * @memberof PutBranch
     */
    'head': string;
    /**
     * An optional ID used to prevent older data from overwriting newer data. If no sequence ID is included, the newly submitted data will always be saved.
     * @type {number}
     * @memberof PutBranch
     */
    'updateSequenceId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PutBranch
     */
    'syncTime': number;
    /**
     * An array of flag references found on the branch
     * @type {Array<ReferenceRep>}
     * @memberof PutBranch
     */
    'references'?: Array<ReferenceRep>;
    /**
     * 
     * @type {number}
     * @memberof PutBranch
     */
    'commitTime'?: number;
}
/**
 * 
 * @export
 * @interface RandomizationSettingsPut
 */
export interface RandomizationSettingsPut {
    /**
     * An array of randomization units allowed for this project.
     * @type {Array<RandomizationUnitInput>}
     * @memberof RandomizationSettingsPut
     */
    'randomizationUnits': Array<RandomizationUnitInput>;
}
/**
 * 
 * @export
 * @interface RandomizationSettingsRep
 */
export interface RandomizationSettingsRep {
    /**
     * The project ID
     * @type {string}
     * @memberof RandomizationSettingsRep
     */
    '_projectId'?: string;
    /**
     * The project key
     * @type {string}
     * @memberof RandomizationSettingsRep
     */
    '_projectKey'?: string;
    /**
     * An array of the randomization units in this project
     * @type {Array<RandomizationUnitRep>}
     * @memberof RandomizationSettingsRep
     */
    'randomizationUnits'?: Array<RandomizationUnitRep>;
    /**
     * 
     * @type {number}
     * @memberof RandomizationSettingsRep
     */
    '_creationDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof RandomizationSettingsRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface RandomizationUnitInput
 */
export interface RandomizationUnitInput {
    /**
     * The unit of randomization. Must match the key of an existing context kind in this project.
     * @type {string}
     * @memberof RandomizationUnitInput
     */
    'randomizationUnit': string;
    /**
     * If true, any experiment iterations created within this project will default to using this randomization unit. A project can only have one default randomization unit.
     * @type {boolean}
     * @memberof RandomizationUnitInput
     */
    'default': boolean;
    /**
     * One of LaunchDarkly\'s fixed set of standard randomization units.
     * @type {string}
     * @memberof RandomizationUnitInput
     */
    'standardRandomizationUnit': RandomizationUnitInputStandardRandomizationUnitEnum;
}

export const RandomizationUnitInputStandardRandomizationUnitEnum = {
    Guest: 'guest',
    GuestTime: 'guestTime',
    Organization: 'organization',
    Request: 'request',
    User: 'user',
    UserTime: 'userTime'
} as const;

export type RandomizationUnitInputStandardRandomizationUnitEnum = typeof RandomizationUnitInputStandardRandomizationUnitEnum[keyof typeof RandomizationUnitInputStandardRandomizationUnitEnum];

/**
 * 
 * @export
 * @interface RandomizationUnitRep
 */
export interface RandomizationUnitRep {
    /**
     * The unit of randomization. Defaults to user.
     * @type {string}
     * @memberof RandomizationUnitRep
     */
    'randomizationUnit'?: string;
    /**
     * One of LaunchDarkly\'s fixed set of standard randomization units.
     * @type {string}
     * @memberof RandomizationUnitRep
     */
    'standardRandomizationUnit'?: string;
    /**
     * Whether this randomization unit is the default for experiments
     * @type {boolean}
     * @memberof RandomizationUnitRep
     */
    'default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RandomizationUnitRep
     */
    '_hidden'?: boolean;
    /**
     * The display name for the randomization unit, displayed in the LaunchDarkly user interface.
     * @type {string}
     * @memberof RandomizationUnitRep
     */
    '_displayName'?: string;
}
/**
 * 
 * @export
 * @interface RateLimitedErrorRep
 */
export interface RateLimitedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof RateLimitedErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof RateLimitedErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RecentTriggerBody
 */
export interface RecentTriggerBody {
    /**
     * 
     * @type {number}
     * @memberof RecentTriggerBody
     */
    'timestamp'?: number;
    /**
     * The marshalled JSON request body for the incoming trigger webhook. If this is empty or contains invalid JSON, the timestamp is recorded but this field will be empty.
     * @type {{ [key: string]: any; }}
     * @memberof RecentTriggerBody
     */
    'jsonBody'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReferenceRep
 */
export interface ReferenceRep {
    /**
     * File path of the reference
     * @type {string}
     * @memberof ReferenceRep
     */
    'path': string;
    /**
     * Programming language used in the file
     * @type {string}
     * @memberof ReferenceRep
     */
    'hint'?: string;
    /**
     * 
     * @type {Array<HunkRep>}
     * @memberof ReferenceRep
     */
    'hunks': Array<HunkRep>;
}
/**
 * 
 * @export
 * @interface RelativeDifferenceRep
 */
export interface RelativeDifferenceRep {
    /**
     * An upper bound of the relative difference between the treatment and the <code>fromTreatmentId</code>
     * @type {number}
     * @memberof RelativeDifferenceRep
     */
    'upper'?: number;
    /**
     * A lower bound of the relative difference between the treatment and the <code>fromTreatmentId</code>
     * @type {number}
     * @memberof RelativeDifferenceRep
     */
    'lower'?: number;
    /**
     * The treatment ID of the treatment against which the relative difference is calculated
     * @type {string}
     * @memberof RelativeDifferenceRep
     */
    'fromTreatmentId'?: string;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigCollectionRep
 */
export interface RelayAutoConfigCollectionRep {
    /**
     * An array of Relay Proxy configurations
     * @type {Array<RelayAutoConfigRep>}
     * @memberof RelayAutoConfigCollectionRep
     */
    'items': Array<RelayAutoConfigRep>;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigPost
 */
export interface RelayAutoConfigPost {
    /**
     * A human-friendly name for the Relay Proxy configuration
     * @type {string}
     * @memberof RelayAutoConfigPost
     */
    'name': string;
    /**
     * A description of what environments and projects the Relay Proxy should include or exclude. To learn more, read [Writing an inline policy](https://docs.launchdarkly.com/home/relay-proxy/automatic-configuration#writing-an-inline-policy).
     * @type {Array<Statement>}
     * @memberof RelayAutoConfigPost
     */
    'policy': Array<Statement>;
}
/**
 * 
 * @export
 * @interface RelayAutoConfigRep
 */
export interface RelayAutoConfigRep {
    /**
     * 
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    '_id': string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof RelayAutoConfigRep
     */
    '_creator'?: MemberSummary;
    /**
     * 
     * @type {Access}
     * @memberof RelayAutoConfigRep
     */
    '_access'?: Access;
    /**
     * A human-friendly name for the Relay Proxy configuration
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'name': string;
    /**
     * A description of what environments and projects the Relay Proxy should include or exclude
     * @type {Array<Statement>}
     * @memberof RelayAutoConfigRep
     */
    'policy': Array<Statement>;
    /**
     * The Relay Proxy configuration key
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'fullKey': string;
    /**
     * The last few characters of the Relay Proxy configuration key, displayed in the LaunchDarkly UI
     * @type {string}
     * @memberof RelayAutoConfigRep
     */
    'displayKey': string;
    /**
     * 
     * @type {number}
     * @memberof RelayAutoConfigRep
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof RelayAutoConfigRep
     */
    'lastModified': number;
}
/**
 * 
 * @export
 * @interface Release
 */
export interface Release {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Release
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The release pipeline name
     * @type {string}
     * @memberof Release
     */
    'name': string;
    /**
     * The release pipeline key
     * @type {string}
     * @memberof Release
     */
    'releasePipelineKey': string;
    /**
     * The release pipeline description
     * @type {string}
     * @memberof Release
     */
    'releasePipelineDescription': string;
    /**
     * An ordered list of the release pipeline phases
     * @type {Array<ReleasePhase>}
     * @memberof Release
     */
    'phases': Array<ReleasePhase>;
    /**
     * The release version
     * @type {number}
     * @memberof Release
     */
    '_version': number;
}
/**
 * 
 * @export
 * @interface ReleaseAudience
 */
export interface ReleaseAudience {
    /**
     * 
     * @type {EnvironmentSummary}
     * @memberof ReleaseAudience
     */
    'environment': EnvironmentSummary;
    /**
     * The release phase name
     * @type {string}
     * @memberof ReleaseAudience
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ReleasePhase
 */
export interface ReleasePhase {
    /**
     * The phase ID
     * @type {string}
     * @memberof ReleasePhase
     */
    '_id': string;
    /**
     * The release phase name
     * @type {string}
     * @memberof ReleasePhase
     */
    '_name': string;
    /**
     * Whether this phase is complete
     * @type {boolean}
     * @memberof ReleasePhase
     */
    'complete': boolean;
    /**
     * 
     * @type {number}
     * @memberof ReleasePhase
     */
    '_creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof ReleasePhase
     */
    '_completionDate'?: number;
    /**
     * 
     * @type {CompletedBy}
     * @memberof ReleasePhase
     */
    '_completedBy'?: CompletedBy;
    /**
     * A logical grouping of one or more environments that share attributes for rolling out changes
     * @type {Array<ReleaseAudience>}
     * @memberof ReleasePhase
     */
    '_audiences': Array<ReleaseAudience>;
}
/**
 * 
 * @export
 * @interface ReleasePipeline
 */
export interface ReleasePipeline {
    /**
     * Timestamp of when the release pipeline was created
     * @type {string}
     * @memberof ReleasePipeline
     */
    'createdAt': string;
    /**
     * The release pipeline description
     * @type {string}
     * @memberof ReleasePipeline
     */
    'description'?: string;
    /**
     * The release pipeline key
     * @type {string}
     * @memberof ReleasePipeline
     */
    'key': string;
    /**
     * The release pipeline name
     * @type {string}
     * @memberof ReleasePipeline
     */
    'name': string;
    /**
     * An ordered list of the release pipeline phases. Each phase is a logical grouping of one or more environments that share attributes for rolling out changes.
     * @type {Array<Phase>}
     * @memberof ReleasePipeline
     */
    'phases': Array<Phase>;
    /**
     * A list of the release pipeline\'s tags
     * @type {Array<string>}
     * @memberof ReleasePipeline
     */
    'tags'?: Array<string>;
    /**
     * The release pipeline version
     * @type {number}
     * @memberof ReleasePipeline
     */
    '_version'?: number;
    /**
     * 
     * @type {Access}
     * @memberof ReleasePipeline
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface ReleasePipelineCollection
 */
export interface ReleasePipelineCollection {
    /**
     * An array of release pipelines
     * @type {Array<ReleasePipeline>}
     * @memberof ReleasePipelineCollection
     */
    'items': Array<ReleasePipeline>;
    /**
     * Total number of release pipelines
     * @type {number}
     * @memberof ReleasePipelineCollection
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface RepositoryCollectionRep
 */
export interface RepositoryCollectionRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepositoryCollectionRep
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of repositories
     * @type {Array<RepositoryRep>}
     * @memberof RepositoryCollectionRep
     */
    'items': Array<RepositoryRep>;
}
/**
 * 
 * @export
 * @interface RepositoryPost
 */
export interface RepositoryPost {
    /**
     * The repository name
     * @type {string}
     * @memberof RepositoryPost
     */
    'name': string;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof RepositoryPost
     */
    'sourceLink'?: string;
    /**
     * A template for constructing a valid URL to view the commit
     * @type {string}
     * @memberof RepositoryPost
     */
    'commitUrlTemplate'?: string;
    /**
     * A template for constructing a valid URL to view the hunk
     * @type {string}
     * @memberof RepositoryPost
     */
    'hunkUrlTemplate'?: string;
    /**
     * The type of repository. If not specified, the default value is <code>custom</code>.
     * @type {string}
     * @memberof RepositoryPost
     */
    'type'?: RepositoryPostTypeEnum;
    /**
     * The repository\'s default branch. If not specified, the default value is <code>main</code>.
     * @type {string}
     * @memberof RepositoryPost
     */
    'defaultBranch'?: string;
}

export const RepositoryPostTypeEnum = {
    Bitbucket: 'bitbucket',
    Custom: 'custom',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepositoryPostTypeEnum = typeof RepositoryPostTypeEnum[keyof typeof RepositoryPostTypeEnum];

/**
 * 
 * @export
 * @interface RepositoryRep
 */
export interface RepositoryRep {
    /**
     * The repository name
     * @type {string}
     * @memberof RepositoryRep
     */
    'name': string;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof RepositoryRep
     */
    'sourceLink'?: string;
    /**
     * A template for constructing a valid URL to view the commit
     * @type {string}
     * @memberof RepositoryRep
     */
    'commitUrlTemplate'?: string;
    /**
     * A template for constructing a valid URL to view the hunk
     * @type {string}
     * @memberof RepositoryRep
     */
    'hunkUrlTemplate'?: string;
    /**
     * The type of repository
     * @type {string}
     * @memberof RepositoryRep
     */
    'type': RepositoryRepTypeEnum;
    /**
     * The repository\'s default branch
     * @type {string}
     * @memberof RepositoryRep
     */
    'defaultBranch': string;
    /**
     * Whether or not a repository is enabled for code reference scanning
     * @type {boolean}
     * @memberof RepositoryRep
     */
    'enabled': boolean;
    /**
     * The version of the repository\'s saved information
     * @type {number}
     * @memberof RepositoryRep
     */
    'version': number;
    /**
     * An array of the repository\'s branches that have been scanned for code references
     * @type {Array<BranchRep>}
     * @memberof RepositoryRep
     */
    'branches'?: Array<BranchRep>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RepositoryRep
     */
    '_links': { [key: string]: any; };
    /**
     * 
     * @type {Access}
     * @memberof RepositoryRep
     */
    '_access'?: Access;
}

export const RepositoryRepTypeEnum = {
    Bitbucket: 'bitbucket',
    Custom: 'custom',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepositoryRepTypeEnum = typeof RepositoryRepTypeEnum[keyof typeof RepositoryRepTypeEnum];

/**
 * 
 * @export
 * @interface ResourceAccess
 */
export interface ResourceAccess {
    /**
     * 
     * @type {string}
     * @memberof ResourceAccess
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceAccess
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface ResourceIDResponse
 */
export interface ResourceIDResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'projectKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'environmentKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'flagKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceIDResponse
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface ResourceId
 */
export interface ResourceId {
    /**
     * The environment key
     * @type {string}
     * @memberof ResourceId
     */
    'environmentKey'?: string;
    /**
     * Deprecated, use <code>key</code> instead
     * @type {string}
     * @memberof ResourceId
     * @deprecated
     */
    'flagKey'?: string;
    /**
     * The key of the flag or segment
     * @type {string}
     * @memberof ResourceId
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceId
     */
    'kind'?: string;
    /**
     * The project key
     * @type {string}
     * @memberof ResourceId
     */
    'projectKey'?: string;
}
/**
 * 
 * @export
 * @interface ReviewOutput
 */
export interface ReviewOutput {
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'kind': string;
    /**
     * 
     * @type {number}
     * @memberof ReviewOutput
     */
    'creationDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'memberId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewOutput
     */
    'serviceTokenId'?: string;
}
/**
 * 
 * @export
 * @interface ReviewResponse
 */
export interface ReviewResponse {
    /**
     * The approval request ID
     * @type {string}
     * @memberof ReviewResponse
     */
    '_id': string;
    /**
     * The type of review action to take
     * @type {string}
     * @memberof ReviewResponse
     */
    'kind': ReviewResponseKindEnum;
    /**
     * 
     * @type {number}
     * @memberof ReviewResponse
     */
    'creationDate'?: number;
    /**
     * A comment describing the approval response
     * @type {string}
     * @memberof ReviewResponse
     */
    'comment'?: string;
    /**
     * ID of account member that reviewed request
     * @type {string}
     * @memberof ReviewResponse
     */
    'memberId'?: string;
    /**
     * ID of account service token that reviewed request
     * @type {string}
     * @memberof ReviewResponse
     */
    'serviceTokenId'?: string;
}

export const ReviewResponseKindEnum = {
    Approve: 'approve',
    Decline: 'decline',
    Comment: 'comment'
} as const;

export type ReviewResponseKindEnum = typeof ReviewResponseKindEnum[keyof typeof ReviewResponseKindEnum];

/**
 * 
 * @export
 * @interface Rollout
 */
export interface Rollout {
    /**
     * 
     * @type {Array<WeightedVariation>}
     * @memberof Rollout
     */
    'variations': Array<WeightedVariation>;
    /**
     * 
     * @type {ExperimentAllocationRep}
     * @memberof Rollout
     */
    'experimentAllocation'?: ExperimentAllocationRep;
    /**
     * 
     * @type {number}
     * @memberof Rollout
     */
    'seed'?: number;
    /**
     * 
     * @type {string}
     * @memberof Rollout
     */
    'bucketBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rollout
     */
    'contextKind'?: string;
}
/**
 * 
 * @export
 * @interface RootResponse
 */
export interface RootResponse {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RootResponse
     */
    'links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * The flag rule ID
     * @type {string}
     * @memberof Rule
     */
    '_id'?: string;
    /**
     * The index of the variation, from the array of variations for this flag
     * @type {number}
     * @memberof Rule
     */
    'variation'?: number;
    /**
     * 
     * @type {Rollout}
     * @memberof Rule
     */
    'rollout'?: Rollout;
    /**
     * An array of clauses used for individual targeting based on attributes
     * @type {Array<Clause>}
     * @memberof Rule
     */
    'clauses': Array<Clause>;
    /**
     * Whether LaunchDarkly tracks events for this rule
     * @type {boolean}
     * @memberof Rule
     */
    'trackEvents': boolean;
    /**
     * The rule description
     * @type {string}
     * @memberof Rule
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'ref'?: string;
}
/**
 * 
 * @export
 * @interface RuleClause
 */
export interface RuleClause {
    /**
     * The attribute the rule applies to, for example, last name or email address
     * @type {string}
     * @memberof RuleClause
     */
    'attribute'?: string;
    /**
     * The operator to apply to the given attribute
     * @type {string}
     * @memberof RuleClause
     */
    'op'?: RuleClauseOpEnum;
    /**
     * Whether the operator should be negated
     * @type {boolean}
     * @memberof RuleClause
     */
    'negate'?: boolean;
}

export const RuleClauseOpEnum = {
    In: 'in',
    EndsWith: 'endsWith',
    StartsWith: 'startsWith',
    Matches: 'matches',
    Contains: 'contains',
    LessThan: 'lessThan',
    LessThanOrEqual: 'lessThanOrEqual',
    GreaterThan: 'greaterThan',
    GreaterThanOrEqual: 'greaterThanOrEqual',
    Before: 'before',
    After: 'after',
    SegmentMatch: 'segmentMatch',
    SemVerEqual: 'semVerEqual',
    SemVerLessThan: 'semVerLessThan',
    SemVerGreaterThan: 'semVerGreaterThan'
} as const;

export type RuleClauseOpEnum = typeof RuleClauseOpEnum[keyof typeof RuleClauseOpEnum];

/**
 * 
 * @export
 * @interface SdkListRep
 */
export interface SdkListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SdkListRep
     */
    '_links': { [key: string]: any; };
    /**
     * The list of SDK names
     * @type {Array<string>}
     * @memberof SdkListRep
     */
    'sdks': Array<string>;
}
/**
 * 
 * @export
 * @interface SdkVersionListRep
 */
export interface SdkVersionListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SdkVersionListRep
     */
    '_links': { [key: string]: any; };
    /**
     * The list of SDK names and versions
     * @type {Array<SdkVersionRep>}
     * @memberof SdkVersionListRep
     */
    'sdkVersions': Array<SdkVersionRep>;
}
/**
 * 
 * @export
 * @interface SdkVersionRep
 */
export interface SdkVersionRep {
    /**
     * The SDK name, or \"Unknown\"
     * @type {string}
     * @memberof SdkVersionRep
     */
    'sdk': string;
    /**
     * The version number, or \"Unknown\"
     * @type {string}
     * @memberof SdkVersionRep
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface SegmentBody
 */
export interface SegmentBody {
    /**
     * A human-friendly name for the segment
     * @type {string}
     * @memberof SegmentBody
     */
    'name': string;
    /**
     * A unique key used to reference the segment
     * @type {string}
     * @memberof SegmentBody
     */
    'key': string;
    /**
     * A description of the segment\'s purpose
     * @type {string}
     * @memberof SegmentBody
     */
    'description'?: string;
    /**
     * Tags for the segment
     * @type {Array<string>}
     * @memberof SegmentBody
     */
    'tags'?: Array<string>;
    /**
     * Whether to create a standard segment (<code>false</code>) or a big segment (<code>true</code>). Standard segments include rule-based and smaller list-based segments. Big segments include larger list-based segments and synced segments. Only use a big segment if you need to add more than 15,000 individual targets.
     * @type {boolean}
     * @memberof SegmentBody
     */
    'unbounded'?: boolean;
    /**
     * For big segments, the targeted context kind.
     * @type {string}
     * @memberof SegmentBody
     */
    'unboundedContextKind'?: string;
}
/**
 * 
 * @export
 * @interface SegmentMetadata
 */
export interface SegmentMetadata {
    /**
     * 
     * @type {string}
     * @memberof SegmentMetadata
     */
    'envId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentMetadata
     */
    'segmentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'version'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'includedCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'excludedCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SegmentMetadata
     */
    'lastModified'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SegmentMetadata
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface SegmentTarget
 */
export interface SegmentTarget {
    /**
     * 
     * @type {Array<string>}
     * @memberof SegmentTarget
     */
    'values'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SegmentTarget
     */
    'contextKind'?: string;
}
/**
 * 
 * @export
 * @interface SegmentUserList
 */
export interface SegmentUserList {
    /**
     * 
     * @type {Array<string>}
     * @memberof SegmentUserList
     */
    'add'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SegmentUserList
     */
    'remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SegmentUserState
 */
export interface SegmentUserState {
    /**
     * 
     * @type {SegmentUserList}
     * @memberof SegmentUserState
     */
    'included'?: SegmentUserList;
    /**
     * 
     * @type {SegmentUserList}
     * @memberof SegmentUserState
     */
    'excluded'?: SegmentUserList;
}
/**
 * 
 * @export
 * @interface Series
 */
export interface Series {
    /**
     * The timestamp
     * @type {number}
     * @memberof Series
     */
    'time': number;
    /**
     * The value for the given timestamp
     * @type {number}
     * @memberof Series
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface SeriesIntervalsRep
 */
export interface SeriesIntervalsRep {
    /**
     * An array of timestamps and values for a given meter
     * @type {Array<Series>}
     * @memberof SeriesIntervalsRep
     */
    'series': Array<Series>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SeriesIntervalsRep
     */
    '_links': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SeriesListRep
 */
export interface SeriesListRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: any; }}
     * @memberof SeriesListRep
     */
    '_links': { [key: string]: any; };
    /**
     * Metadata about each series
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SeriesListRep
     */
    'metadata': Array<{ [key: string]: any; }>;
    /**
     * An array of data points with timestamps. Each element of the array is an object with a \'time\' field, whose value is the timestamp, and one or more key fields. If there are multiple key fields, they are labeled \'0\', \'1\', and so on, and are explained in the <code>metadata</code>.
     * @type {Array<{ [key: string]: number; }>}
     * @memberof SeriesListRep
     */
    'series': Array<{ [key: string]: number; }>;
}
/**
 * 
 * @export
 * @interface SlicedResultsRep
 */
export interface SlicedResultsRep {
    /**
     * An attribute that results are sliced by
     * @type {string}
     * @memberof SlicedResultsRep
     */
    'attribute'?: string;
    /**
     * Attribute Value for \'attribute\'
     * @type {string}
     * @memberof SlicedResultsRep
     */
    'attributeValue'?: string;
    /**
     * A list of the results for each treatment
     * @type {Array<TreatmentResultRep>}
     * @memberof SlicedResultsRep
     */
    'treatmentResults'?: Array<TreatmentResultRep>;
}
/**
 * 
 * @export
 * @interface SourceEnv
 */
export interface SourceEnv {
    /**
     * The key of the source environment to clone from
     * @type {string}
     * @memberof SourceEnv
     */
    'key'?: string;
    /**
     * (Optional) The version number of the source environment to clone from. Used for optimistic locking
     * @type {number}
     * @memberof SourceEnv
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface SourceFlag
 */
export interface SourceFlag {
    /**
     * The environment key for the source environment
     * @type {string}
     * @memberof SourceFlag
     */
    'key': string;
    /**
     * The version of the source flag from which to copy
     * @type {number}
     * @memberof SourceFlag
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface StageInput
 */
export interface StageInput {
    /**
     * The stage name
     * @type {string}
     * @memberof StageInput
     */
    'name'?: string;
    /**
     * Whether to execute the conditions in sequence for the given stage
     * @type {boolean}
     * @memberof StageInput
     */
    'executeConditionsInSequence'?: boolean;
    /**
     * An array of conditions for the stage
     * @type {Array<ConditionInput>}
     * @memberof StageInput
     */
    'conditions'?: Array<ConditionInput>;
    /**
     * 
     * @type {ActionInput}
     * @memberof StageInput
     */
    'action'?: ActionInput;
}
/**
 * 
 * @export
 * @interface StageOutput
 */
export interface StageOutput {
    /**
     * The ID of this stage
     * @type {string}
     * @memberof StageOutput
     */
    '_id': string;
    /**
     * The stage name
     * @type {string}
     * @memberof StageOutput
     */
    'name'?: string;
    /**
     * An array of conditions for the stage
     * @type {Array<ConditionOutput>}
     * @memberof StageOutput
     */
    'conditions': Array<ConditionOutput>;
    /**
     * 
     * @type {ActionOutput}
     * @memberof StageOutput
     */
    'action': ActionOutput;
    /**
     * 
     * @type {ExecutionOutput}
     * @memberof StageOutput
     */
    '_execution': ExecutionOutput;
}
/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof Statement
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> and <code>notActions</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof Statement
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> and <code>notResources</code> fields must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    'notActions'?: Array<string>;
    /**
     * Whether this statement should allow or deny actions on the resources.
     * @type {string}
     * @memberof Statement
     */
    'effect': StatementEffectEnum;
}

export const StatementEffectEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type StatementEffectEnum = typeof StatementEffectEnum[keyof typeof StatementEffectEnum];

/**
 * 
 * @export
 * @interface StatementPost
 */
export interface StatementPost {
    /**
     * Resource specifier strings
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'resources'?: Array<string>;
    /**
     * Targeted resources are the resources NOT in this list. The <code>resources</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'notResources'?: Array<string>;
    /**
     * Actions to perform on a resource
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'actions'?: Array<string>;
    /**
     * Targeted actions are the actions NOT in this list. The <code>actions</code> field must be empty to use this field.
     * @type {Array<string>}
     * @memberof StatementPost
     */
    'notActions'?: Array<string>;
    /**
     * Whether this statement should allow or deny actions on the resources.
     * @type {string}
     * @memberof StatementPost
     */
    'effect': StatementPostEffectEnum;
}

export const StatementPostEffectEnum = {
    Allow: 'allow',
    Deny: 'deny'
} as const;

export type StatementPostEffectEnum = typeof StatementPostEffectEnum[keyof typeof StatementPostEffectEnum];

/**
 * 
 * @export
 * @interface StatisticCollectionRep
 */
export interface StatisticCollectionRep {
    /**
     * A map of flag keys to a list of code reference statistics for each code repository in which the flag key appears
     * @type {{ [key: string]: Array<StatisticRep>; }}
     * @memberof StatisticCollectionRep
     */
    'flags': { [key: string]: Array<StatisticRep>; };
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof StatisticCollectionRep
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface StatisticRep
 */
export interface StatisticRep {
    /**
     * The repository name
     * @type {string}
     * @memberof StatisticRep
     */
    'name': string;
    /**
     * The type of repository
     * @type {string}
     * @memberof StatisticRep
     */
    'type': StatisticRepTypeEnum;
    /**
     * A URL to access the repository
     * @type {string}
     * @memberof StatisticRep
     */
    'sourceLink': string;
    /**
     * The repository\'s default branch
     * @type {string}
     * @memberof StatisticRep
     */
    'defaultBranch': string;
    /**
     * Whether or not a repository is enabled for code reference scanning
     * @type {boolean}
     * @memberof StatisticRep
     */
    'enabled': boolean;
    /**
     * The version of the repository\'s saved information
     * @type {number}
     * @memberof StatisticRep
     */
    'version': number;
    /**
     * The number of code reference hunks in which the flag appears in this repository
     * @type {number}
     * @memberof StatisticRep
     */
    'hunkCount': number;
    /**
     * The number of files in which the flag appears in this repository
     * @type {number}
     * @memberof StatisticRep
     */
    'fileCount': number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof StatisticRep
     */
    '_links': { [key: string]: Link; };
}

export const StatisticRepTypeEnum = {
    Bitbucket: 'bitbucket',
    Custom: 'custom',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type StatisticRepTypeEnum = typeof StatisticRepTypeEnum[keyof typeof StatisticRepTypeEnum];

/**
 * 
 * @export
 * @interface StatisticsRoot
 */
export interface StatisticsRoot {
    /**
     * The location and content type of all projects that have code references
     * @type {Array<Link>}
     * @memberof StatisticsRoot
     */
    'projects'?: Array<Link>;
    /**
     * 
     * @type {Link}
     * @memberof StatisticsRoot
     */
    'self'?: Link;
}
/**
 * 
 * @export
 * @interface StatusConflictErrorRep
 */
export interface StatusConflictErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof StatusConflictErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof StatusConflictErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface StatusServiceUnavailable
 */
export interface StatusServiceUnavailable {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof StatusServiceUnavailable
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof StatusServiceUnavailable
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface StoreIntegrationError
 */
export interface StoreIntegrationError {
    /**
     * 
     * @type {number}
     * @memberof StoreIntegrationError
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof StoreIntegrationError
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof StoreIntegrationError
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface SubjectDataRep
 */
export interface SubjectDataRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof SubjectDataRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The subject\'s name
     * @type {string}
     * @memberof SubjectDataRep
     */
    'name'?: string;
    /**
     * The subject\'s avatar
     * @type {string}
     * @memberof SubjectDataRep
     */
    'avatarUrl'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionPost
 */
export interface SubscriptionPost {
    /**
     * A human-friendly name for your audit log subscription.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'name': string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof SubscriptionPost
     */
    'statements'?: Array<StatementPost>;
    /**
     * Whether or not you want your subscription to actively send events.
     * @type {boolean}
     * @memberof SubscriptionPost
     */
    'on'?: boolean;
    /**
     * An array of tags for this subscription.
     * @type {Array<string>}
     * @memberof SubscriptionPost
     */
    'tags'?: Array<string>;
    /**
     * The unique set of fields required to configure an audit log subscription integration of this type. Refer to the <code>formVariables</code> field in the corresponding <code>manifest.json</code> at https://github.com/launchdarkly/integration-framework/tree/main/integrations for a full list of fields for the integration you wish to configure.
     * @type {{ [key: string]: any; }}
     * @memberof SubscriptionPost
     */
    'config': { [key: string]: any; };
    /**
     * Slack webhook receiver URL. Only necessary for legacy Slack webhook integrations.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'url'?: string;
    /**
     * Datadog API key. Only necessary for legacy Datadog webhook integrations.
     * @type {string}
     * @memberof SubscriptionPost
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface TagCollection
 */
export interface TagCollection {
    /**
     * List of tags
     * @type {Array<string>}
     * @memberof TagCollection
     */
    'items': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TagCollection
     */
    '_links': { [key: string]: Link; };
    /**
     * The total number of tags
     * @type {number}
     * @memberof TagCollection
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface Target
 */
export interface Target {
    /**
     * A list of the keys for targets that will receive this variation because of individual targeting
     * @type {Array<string>}
     * @memberof Target
     */
    'values': Array<string>;
    /**
     * The index, from the array of variations for this flag, of the variation to serve this list of targets
     * @type {number}
     * @memberof Target
     */
    'variation': number;
    /**
     * The context kind of the individual target
     * @type {string}
     * @memberof Target
     */
    'contextKind'?: string;
}
/**
 * 
 * @export
 * @interface TargetResourceRep
 */
export interface TargetResourceRep {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TargetResourceRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The name of the resource
     * @type {string}
     * @memberof TargetResourceRep
     */
    'name'?: string;
    /**
     * The resource specifier
     * @type {Array<string>}
     * @memberof TargetResourceRep
     */
    'resources'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * A description of the team
     * @type {string}
     * @memberof Team
     */
    'description'?: string;
    /**
     * The team key
     * @type {string}
     * @memberof Team
     */
    'key'?: string;
    /**
     * A human-friendly name for the team
     * @type {string}
     * @memberof Team
     */
    'name'?: string;
    /**
     * 
     * @type {Access}
     * @memberof Team
     */
    '_access'?: Access;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    '_creationDate'?: number;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Team
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    '_lastModified'?: number;
    /**
     * The team version
     * @type {number}
     * @memberof Team
     */
    '_version'?: number;
    /**
     * Whether the team has been synced with an external identity provider (IdP). Team sync is available to customers on an Enterprise plan.
     * @type {boolean}
     * @memberof Team
     */
    '_idpSynced'?: boolean;
    /**
     * 
     * @type {TeamCustomRoles}
     * @memberof Team
     */
    'roles'?: TeamCustomRoles;
    /**
     * 
     * @type {TeamMembers}
     * @memberof Team
     */
    'members'?: TeamMembers;
    /**
     * 
     * @type {TeamProjects}
     * @memberof Team
     */
    'projects'?: TeamProjects;
    /**
     * 
     * @type {TeamMaintainers}
     * @memberof Team
     */
    'maintainers'?: TeamMaintainers;
}
/**
 * 
 * @export
 * @interface TeamCustomRole
 */
export interface TeamCustomRole {
    /**
     * The key of the custom role
     * @type {string}
     * @memberof TeamCustomRole
     */
    'key'?: string;
    /**
     * The name of the custom role
     * @type {string}
     * @memberof TeamCustomRole
     */
    'name'?: string;
    /**
     * 
     * @type {TeamProjects}
     * @memberof TeamCustomRole
     */
    'projects'?: TeamProjects;
    /**
     * 
     * @type {number}
     * @memberof TeamCustomRole
     */
    'appliedOn'?: number;
}
/**
 * 
 * @export
 * @interface TeamCustomRoles
 */
export interface TeamCustomRoles {
    /**
     * The number of custom roles assigned to this team
     * @type {number}
     * @memberof TeamCustomRoles
     */
    'totalCount'?: number;
    /**
     * An array of the custom roles that have been assigned to this team
     * @type {Array<TeamCustomRole>}
     * @memberof TeamCustomRoles
     */
    'items'?: Array<TeamCustomRole>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TeamCustomRoles
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TeamImportsRep
 */
export interface TeamImportsRep {
    /**
     * An array of details about the members requested to be added to this team
     * @type {Array<MemberImportItem>}
     * @memberof TeamImportsRep
     */
    'items'?: Array<MemberImportItem>;
}
/**
 * 
 * @export
 * @interface TeamMaintainers
 */
export interface TeamMaintainers {
    /**
     * The number of maintainers of the team
     * @type {number}
     * @memberof TeamMaintainers
     */
    'totalCount'?: number;
    /**
     * Details on the members that have been assigned as maintainers of the team
     * @type {Array<MemberSummary>}
     * @memberof TeamMaintainers
     */
    'items'?: Array<MemberSummary>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TeamMaintainers
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TeamMembers
 */
export interface TeamMembers {
    /**
     * The total count of members that belong to the team
     * @type {number}
     * @memberof TeamMembers
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TeamPatchInput
 */
export interface TeamPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof TeamPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TeamPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface TeamPostInput
 */
export interface TeamPostInput {
    /**
     * List of custom role keys the team will access
     * @type {Array<string>}
     * @memberof TeamPostInput
     */
    'customRoleKeys'?: Array<string>;
    /**
     * A description of the team
     * @type {string}
     * @memberof TeamPostInput
     */
    'description'?: string;
    /**
     * The team key
     * @type {string}
     * @memberof TeamPostInput
     */
    'key': string;
    /**
     * A list of member IDs who belong to the team
     * @type {Array<string>}
     * @memberof TeamPostInput
     */
    'memberIDs'?: Array<string>;
    /**
     * A human-friendly name for the team
     * @type {string}
     * @memberof TeamPostInput
     */
    'name': string;
    /**
     * A list of permission grants. Permission grants allow access to a specific action, without having to create or update a custom role.
     * @type {Array<PermissionGrantInput>}
     * @memberof TeamPostInput
     */
    'permissionGrants'?: Array<PermissionGrantInput>;
}
/**
 * 
 * @export
 * @interface TeamProjects
 */
export interface TeamProjects {
    /**
     * 
     * @type {number}
     * @memberof TeamProjects
     */
    'totalCount'?: number;
    /**
     * Details on each project where team members have write privileges on at least one resource type (e.g. flags)
     * @type {Array<ProjectSummary>}
     * @memberof TeamProjects
     */
    'items'?: Array<ProjectSummary>;
}
/**
 * 
 * @export
 * @interface Teams
 */
export interface Teams {
    /**
     * An array of teams
     * @type {Array<Team>}
     * @memberof Teams
     */
    'items'?: Array<Team>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Teams
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of teams
     * @type {number}
     * @memberof Teams
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TeamsPatchInput
 */
export interface TeamsPatchInput {
    /**
     * Optional comment describing the update
     * @type {string}
     * @memberof TeamsPatchInput
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TeamsPatchInput
     */
    'instructions': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface TimestampRep
 */
export interface TimestampRep {
    /**
     * 
     * @type {number}
     * @memberof TimestampRep
     */
    'milliseconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimestampRep
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimestampRep
     */
    'rfc3339'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampRep
     */
    'simple'?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'memberId': string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof Token
     */
    '_member'?: MemberSummary;
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     * A description for the access token
     * @type {string}
     * @memberof Token
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lastModified': number;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof Token
     */
    'customRoleIds'?: Array<string>;
    /**
     * An array of policy statements, with three attributes: effect, resources, actions. May be used in place of a built-in or custom role.
     * @type {Array<Statement>}
     * @memberof Token
     */
    'inlineRole'?: Array<Statement>;
    /**
     * Built-in role for the token
     * @type {string}
     * @memberof Token
     */
    'role'?: string;
    /**
     * The token value. When creating or resetting, contains the entire token value. Otherwise, contains the last four characters.
     * @type {string}
     * @memberof Token
     */
    'token'?: string;
    /**
     * Whether this is a service token or a personal token
     * @type {boolean}
     * @memberof Token
     */
    'serviceToken'?: boolean;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Token
     */
    '_links': { [key: string]: Link; };
    /**
     * The default API version for this token
     * @type {number}
     * @memberof Token
     */
    'defaultApiVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lastUsed'?: number;
}
/**
 * 
 * @export
 * @interface TokenSummary
 */
export interface TokenSummary {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof TokenSummary
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof TokenSummary
     */
    '_id'?: string;
    /**
     * The name of the token
     * @type {string}
     * @memberof TokenSummary
     */
    'name'?: string;
    /**
     * The last few characters of the token
     * @type {string}
     * @memberof TokenSummary
     */
    'ending'?: string;
    /**
     * Whether this is a service token
     * @type {boolean}
     * @memberof TokenSummary
     */
    'serviceToken'?: boolean;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * An array of access tokens
     * @type {Array<Token>}
     * @memberof Tokens
     */
    'items'?: Array<Token>;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof Tokens
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The number of access tokens returned
     * @type {number}
     * @memberof Tokens
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface TreatmentInput
 */
export interface TreatmentInput {
    /**
     * The treatment name
     * @type {string}
     * @memberof TreatmentInput
     */
    'name': string;
    /**
     * Whether this treatment is the baseline to compare other treatments against
     * @type {boolean}
     * @memberof TreatmentInput
     */
    'baseline': boolean;
    /**
     * The percentage of traffic allocated to this treatment during the iteration
     * @type {string}
     * @memberof TreatmentInput
     */
    'allocationPercent': string;
    /**
     * Details on the flag and variation to use for this treatment
     * @type {Array<TreatmentParameterInput>}
     * @memberof TreatmentInput
     */
    'parameters': Array<TreatmentParameterInput>;
}
/**
 * 
 * @export
 * @interface TreatmentParameterInput
 */
export interface TreatmentParameterInput {
    /**
     * The flag key
     * @type {string}
     * @memberof TreatmentParameterInput
     */
    'flagKey': string;
    /**
     * The ID of the flag variation
     * @type {string}
     * @memberof TreatmentParameterInput
     */
    'variationId': string;
}
/**
 * 
 * @export
 * @interface TreatmentRep
 */
export interface TreatmentRep {
    /**
     * The treatment ID. This is the variation ID from the flag.
     * @type {string}
     * @memberof TreatmentRep
     */
    '_id'?: string;
    /**
     * The treatment name. This is the variation name from the flag.
     * @type {string}
     * @memberof TreatmentRep
     */
    'name': string;
    /**
     * The percentage of traffic allocated to this treatment during the iteration
     * @type {string}
     * @memberof TreatmentRep
     */
    'allocationPercent': string;
    /**
     * Whether this treatment is the baseline to compare other treatments against
     * @type {boolean}
     * @memberof TreatmentRep
     */
    'baseline'?: boolean;
    /**
     * Details on the flag and variation used for this treatment
     * @type {Array<ParameterRep>}
     * @memberof TreatmentRep
     */
    'parameters'?: Array<ParameterRep>;
}
/**
 * 
 * @export
 * @interface TreatmentResultRep
 */
export interface TreatmentResultRep {
    /**
     * The ID of the treatment
     * @type {string}
     * @memberof TreatmentResultRep
     */
    'treatmentId'?: string;
    /**
     * The name of the treatment
     * @type {string}
     * @memberof TreatmentResultRep
     */
    'treatmentName'?: string;
    /**
     * The average value of the variation in this sample. It doesn’t capture the uncertainty in the measurement, so it should not be the only measurement you use to make decisions.
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'mean'?: number;
    /**
     * 
     * @type {CredibleIntervalRep}
     * @memberof TreatmentResultRep
     */
    'credibleInterval'?: CredibleIntervalRep;
    /**
     * The likelihood that this variation has the biggest effect on the primary metric. The variation with the highest probability is likely the best of the variations you\'re testing
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'pBest'?: number;
    /**
     * Estimates of the relative difference between this treatment\'s mean and the mean of each other treatment
     * @type {Array<RelativeDifferenceRep>}
     * @memberof TreatmentResultRep
     */
    'relativeDifferences'?: Array<RelativeDifferenceRep>;
    /**
     * The number of units exposed to this treatment that have event values, including those that are configured to default to 0
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'units'?: number;
    /**
     * The number of units exposed to this treatment.
     * @type {number}
     * @memberof TreatmentResultRep
     */
    'traffic'?: number;
    /**
     * 
     * @type {Distribution}
     * @memberof TreatmentResultRep
     */
    'distribution'?: Distribution;
}
/**
 * 
 * @export
 * @interface TriggerPost
 */
export interface TriggerPost {
    /**
     * Optional comment describing the trigger
     * @type {string}
     * @memberof TriggerPost
     */
    'comment'?: string;
    /**
     * The action to perform when triggering. This should be an array with a single object that looks like <code>{\"kind\": \"flag_action\"}</code>. Supported flag actions are <code>turnFlagOn</code> and <code>turnFlagOff</code>.
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TriggerPost
     */
    'instructions'?: Array<{ [key: string]: any; }>;
    /**
     * The unique identifier of the integration for your trigger. Use <code>generic-trigger</code> for integrations not explicitly supported.
     * @type {string}
     * @memberof TriggerPost
     */
    'integrationKey': string;
}
/**
 * 
 * @export
 * @interface TriggerWorkflowCollectionRep
 */
export interface TriggerWorkflowCollectionRep {
    /**
     * An array of flag triggers
     * @type {Array<TriggerWorkflowRep>}
     * @memberof TriggerWorkflowCollectionRep
     */
    'items'?: Array<TriggerWorkflowRep>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TriggerWorkflowCollectionRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface TriggerWorkflowRep
 */
export interface TriggerWorkflowRep {
    /**
     * 
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_id'?: string;
    /**
     * The flag trigger version
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_version'?: number;
    /**
     * 
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_creationDate'?: number;
    /**
     * The ID of the flag trigger maintainer
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_maintainerId'?: string;
    /**
     * 
     * @type {MemberSummary}
     * @memberof TriggerWorkflowRep
     */
    '_maintainer'?: MemberSummary;
    /**
     * Whether the flag trigger is currently enabled
     * @type {boolean}
     * @memberof TriggerWorkflowRep
     */
    'enabled'?: boolean;
    /**
     * The unique identifier of the integration for your trigger
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    '_integrationKey'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TriggerWorkflowRep
     */
    'instructions'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_lastTriggeredAt'?: number;
    /**
     * Details on recent flag trigger requests.
     * @type {Array<RecentTriggerBody>}
     * @memberof TriggerWorkflowRep
     */
    '_recentTriggerBodies'?: Array<RecentTriggerBody>;
    /**
     * Number of times the trigger has been executed
     * @type {number}
     * @memberof TriggerWorkflowRep
     */
    '_triggerCount'?: number;
    /**
     * The unguessable URL for this flag trigger
     * @type {string}
     * @memberof TriggerWorkflowRep
     */
    'triggerURL'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof TriggerWorkflowRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface UnauthorizedErrorRep
 */
export interface UnauthorizedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof UnauthorizedErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof UnauthorizedErrorRep
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpsertContextKindPayload
 */
export interface UpsertContextKindPayload {
    /**
     * The context kind name
     * @type {string}
     * @memberof UpsertContextKindPayload
     */
    'name': string;
    /**
     * The context kind description
     * @type {string}
     * @memberof UpsertContextKindPayload
     */
    'description'?: string;
    /**
     * Alias for archived.
     * @type {boolean}
     * @memberof UpsertContextKindPayload
     */
    'hideInTargeting'?: boolean;
    /**
     * Whether the context kind is archived. Archived context kinds are unavailable for targeting.
     * @type {boolean}
     * @memberof UpsertContextKindPayload
     */
    'archived'?: boolean;
    /**
     * The context kind version. If not specified when the context kind is created, defaults to 1.
     * @type {number}
     * @memberof UpsertContextKindPayload
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface UpsertFlagDefaultsPayload
 */
export interface UpsertFlagDefaultsPayload {
    /**
     * A list of default tags for each flag
     * @type {Array<string>}
     * @memberof UpsertFlagDefaultsPayload
     */
    'tags': Array<string>;
    /**
     * Whether the flag should be temporary by default
     * @type {boolean}
     * @memberof UpsertFlagDefaultsPayload
     */
    'temporary': boolean;
    /**
     * 
     * @type {BooleanFlagDefaults}
     * @memberof UpsertFlagDefaultsPayload
     */
    'booleanDefaults': BooleanFlagDefaults;
    /**
     * 
     * @type {DefaultClientSideAvailability}
     * @memberof UpsertFlagDefaultsPayload
     */
    'defaultClientSideAvailability': DefaultClientSideAvailability;
}
/**
 * 
 * @export
 * @interface UpsertPayloadRep
 */
export interface UpsertPayloadRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UpsertPayloadRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * A list of default tags for each flag
     * @type {Array<string>}
     * @memberof UpsertPayloadRep
     */
    'tags': Array<string>;
    /**
     * Whether the flag should be temporary by default
     * @type {boolean}
     * @memberof UpsertPayloadRep
     */
    'temporary': boolean;
    /**
     * 
     * @type {BooleanFlagDefaults}
     * @memberof UpsertPayloadRep
     */
    'booleanDefaults': BooleanFlagDefaults;
    /**
     * 
     * @type {DefaultClientSideAvailability}
     * @memberof UpsertPayloadRep
     */
    'defaultClientSideAvailability': DefaultClientSideAvailability;
}
/**
 * 
 * @export
 * @interface UpsertResponseRep
 */
export interface UpsertResponseRep {
    /**
     * The status of the create or update operation
     * @type {string}
     * @memberof UpsertResponseRep
     */
    'status'?: string;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UpsertResponseRep
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface UrlPost
 */
export interface UrlPost {
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'kind'?: UrlPostKindEnum;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'substring'?: string;
    /**
     * 
     * @type {string}
     * @memberof UrlPost
     */
    'pattern'?: string;
}

export const UrlPostKindEnum = {
    Exact: 'exact',
    Canonical: 'canonical',
    Substring: 'substring',
    Regex: 'regex'
} as const;

export type UrlPostKindEnum = typeof UrlPostKindEnum[keyof typeof UrlPostKindEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user key. This is the only mandatory user attribute.
     * @type {string}
     * @memberof User
     */
    'key'?: string;
    /**
     * If provided, used with the user key to generate a variation in percentage rollouts
     * @type {string}
     * @memberof User
     */
    'secondary'?: string;
    /**
     * The user\'s IP address
     * @type {string}
     * @memberof User
     */
    'ip'?: string;
    /**
     * The user\'s country
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * The user\'s email
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * The user\'s first name
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * The user\'s last name
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * An absolute URL to an avatar image.
     * @type {string}
     * @memberof User
     */
    'avatar'?: string;
    /**
     * The user\'s full name
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * Whether the user is anonymous. If true, this user does not appear on the Contexts list in the LaunchDarkly user interface.
     * @type {boolean}
     * @memberof User
     */
    'anonymous'?: boolean;
    /**
     * Any other custom attributes for this user. Custom attributes contain any other user data that you would like to use to conditionally target your users.
     * @type {{ [key: string]: any; }}
     * @memberof User
     */
    'custom'?: { [key: string]: any; };
    /**
     * A list of attribute names that are marked as private. You can use these attributes in targeting rules and segments. If you are using a server-side SDK, the SDK will not send the private attribute back to LaunchDarkly. If you are using a client-side SDK, the SDK will send the private attribute back to LaunchDarkly for evaluation. However, the SDK won\'t send the attribute to LaunchDarkly in events data, LaunchDarkly won\'t store the private attribute, and the private attribute will not appear on the Contexts list.
     * @type {Array<string>}
     * @memberof User
     */
    'privateAttrs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserAttributeNamesRep
 */
export interface UserAttributeNamesRep {
    /**
     * private attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'private'?: Array<string>;
    /**
     * custom attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'custom'?: Array<string>;
    /**
     * standard attributes
     * @type {Array<string>}
     * @memberof UserAttributeNamesRep
     */
    'standard'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserFlagSetting
 */
export interface UserFlagSetting {
    /**
     * The location and content type of related resources.
     * @type {{ [key: string]: Link; }}
     * @memberof UserFlagSetting
     */
    '_links': { [key: string]: Link; };
    /**
     * The value of the flag variation that the user receives. If there is no defined default rule, this is null.
     * @type {any}
     * @memberof UserFlagSetting
     */
    '_value': any;
    /**
     * Whether the user is explicitly targeted to receive a particular variation. The setting is false if you have turned off a feature flag for a user. It is null if you haven\'t assigned that user to a specific variation.
     * @type {any}
     * @memberof UserFlagSetting
     */
    'setting': any;
    /**
     * 
     * @type {EvaluationReason}
     * @memberof UserFlagSetting
     */
    'reason'?: EvaluationReason;
}
/**
 * 
 * @export
 * @interface UserFlagSettings
 */
export interface UserFlagSettings {
    /**
     * An array of flag settings for the user
     * @type {{ [key: string]: UserFlagSetting; }}
     * @memberof UserFlagSettings
     */
    'items': { [key: string]: UserFlagSetting; };
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserFlagSettings
     */
    '_links': { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface UserRecord
 */
export interface UserRecord {
    /**
     * Timestamp of the last time this user was seen
     * @type {string}
     * @memberof UserRecord
     */
    'lastPing'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    'environmentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    'ownerId'?: string;
    /**
     * 
     * @type {User}
     * @memberof UserRecord
     */
    'user'?: User;
    /**
     * If this record is returned as part of a list, the value used to sort the list. This is only included when the <code>sort</code> query parameter is specified. It is a time, in Unix milliseconds, if the sort is by <code>lastSeen</code>. It is a user key if the sort is by <code>userKey</code>.
     * @type {any}
     * @memberof UserRecord
     */
    'sortValue'?: any;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserRecord
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {Access}
     * @memberof UserRecord
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface UserSegment
 */
export interface UserSegment {
    /**
     * A human-friendly name for the segment.
     * @type {string}
     * @memberof UserSegment
     */
    'name': string;
    /**
     * A description of the segment\'s purpose. Defaults to <code>null</code> and is omitted in the response if not provided.
     * @type {string}
     * @memberof UserSegment
     */
    'description'?: string;
    /**
     * Tags for the segment. Defaults to an empty array.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'tags': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    'creationDate': number;
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    'lastModifiedDate': number;
    /**
     * A unique key used to reference the segment
     * @type {string}
     * @memberof UserSegment
     */
    'key': string;
    /**
     * An array of keys for included targets. Included individual targets are always segment members, regardless of segment rules. For list-based segments over 15,000 entries, also called big segments, this array is either empty or omitted.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'included'?: Array<string>;
    /**
     * An array of keys for excluded targets. Segment rules bypass individual excluded targets, so they will never be included based on rules. Excluded targets may still be included explicitly. This value is omitted for list-based segments over 15,000 entries, also called big segments.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    'excluded'?: Array<string>;
    /**
     * 
     * @type {Array<SegmentTarget>}
     * @memberof UserSegment
     */
    'includedContexts'?: Array<SegmentTarget>;
    /**
     * 
     * @type {Array<SegmentTarget>}
     * @memberof UserSegment
     */
    'excludedContexts'?: Array<SegmentTarget>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserSegment
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of the targeting rules for this segment.
     * @type {Array<UserSegmentRule>}
     * @memberof UserSegment
     */
    'rules': Array<UserSegmentRule>;
    /**
     * Version of the segment
     * @type {number}
     * @memberof UserSegment
     */
    'version': number;
    /**
     * Whether the segment has been deleted
     * @type {boolean}
     * @memberof UserSegment
     */
    'deleted': boolean;
    /**
     * 
     * @type {Access}
     * @memberof UserSegment
     */
    '_access'?: Access;
    /**
     * A list of flags targeting this segment. Only included when getting a single segment, using the <code>getSegment</code> endpoint.
     * @type {Array<FlagListingRep>}
     * @memberof UserSegment
     */
    '_flags'?: Array<FlagListingRep>;
    /**
     * Whether this is a standard segment (<code>false</code>) or a big segment (<code>true</code>). Standard segments include rule-based segments and smaller list-based segments. Big segments include larger list-based segments and synced segments. If omitted, the segment is a standard segment.
     * @type {boolean}
     * @memberof UserSegment
     */
    'unbounded'?: boolean;
    /**
     * For big segments, the targeted context kind.
     * @type {string}
     * @memberof UserSegment
     */
    'unboundedContextKind'?: string;
    /**
     * For big segments, how many times this segment has been created.
     * @type {number}
     * @memberof UserSegment
     */
    'generation': number;
    /**
     * 
     * @type {SegmentMetadata}
     * @memberof UserSegment
     */
    '_unboundedMetadata'?: SegmentMetadata;
    /**
     * The external data store backing this segment. Only applies to synced segments.
     * @type {string}
     * @memberof UserSegment
     */
    '_external'?: string;
    /**
     * The URL for the external data store backing this segment. Only applies to synced segments.
     * @type {string}
     * @memberof UserSegment
     */
    '_externalLink'?: string;
    /**
     * Whether an import is currently in progress for the specified segment. Only applies to big segments.
     * @type {boolean}
     * @memberof UserSegment
     */
    '_importInProgress'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSegmentRule
 */
export interface UserSegmentRule {
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    '_id'?: string;
    /**
     * 
     * @type {Array<Clause>}
     * @memberof UserSegmentRule
     */
    'clauses': Array<Clause>;
    /**
     * 
     * @type {number}
     * @memberof UserSegmentRule
     */
    'weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    'rolloutContextKind'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    'bucketBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UserSegments
 */
export interface UserSegments {
    /**
     * An array of segments
     * @type {Array<UserSegment>}
     * @memberof UserSegments
     */
    'items': Array<UserSegment>;
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UserSegments
     */
    '_links': { [key: string]: Link; };
    /**
     * The total number of segments
     * @type {number}
     * @memberof UserSegments
     */
    'totalCount': number;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Users
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total number of users in the environment
     * @type {number}
     * @memberof Users
     */
    'totalCount': number;
    /**
     * Details on the users
     * @type {Array<UserRecord>}
     * @memberof Users
     */
    'items': Array<UserRecord>;
}
/**
 * 
 * @export
 * @interface UsersRep
 */
export interface UsersRep {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof UsersRep
     */
    '_links'?: { [key: string]: Link; };
    /**
     * The total number of users in the environment
     * @type {number}
     * @memberof UsersRep
     */
    'totalCount': number;
    /**
     * Details on the users
     * @type {Array<UserRecord>}
     * @memberof UsersRep
     */
    'items': Array<UserRecord>;
}
/**
 * 
 * @export
 * @interface ValidationFailedErrorRep
 */
export interface ValidationFailedErrorRep {
    /**
     * Specific error code encountered
     * @type {string}
     * @memberof ValidationFailedErrorRep
     */
    'code': string;
    /**
     * Description of the error
     * @type {string}
     * @memberof ValidationFailedErrorRep
     */
    'message': string;
    /**
     * List of validation errors
     * @type {Array<FailureReasonRep>}
     * @memberof ValidationFailedErrorRep
     */
    'errors': Array<FailureReasonRep>;
}
/**
 * 
 * @export
 * @interface ValuePut
 */
export interface ValuePut {
    /**
     * The variation value to set for the context. Must match the flag\'s variation type.
     * @type {any}
     * @memberof ValuePut
     */
    'setting'?: any;
    /**
     * Optional comment describing the change
     * @type {string}
     * @memberof ValuePut
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface Variation
 */
export interface Variation {
    /**
     * The ID of the variation. Leave empty when you are creating a flag.
     * @type {string}
     * @memberof Variation
     */
    '_id'?: string;
    /**
     * The value of the variation. For boolean flags, this must be <code>true</code> or <code>false</code>. For multivariate flags, this may be a string, number, or JSON object.
     * @type {any}
     * @memberof Variation
     */
    'value': any;
    /**
     * Description of the variation. Defaults to an empty string, but is omitted from the response if not set.
     * @type {string}
     * @memberof Variation
     */
    'description'?: string;
    /**
     * A human-friendly name for the variation. Defaults to an empty string, but is omitted from the response if not set.
     * @type {string}
     * @memberof Variation
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface VariationEvalSummary
 */
export interface VariationEvalSummary {
    /**
     * The variation value
     * @type {any}
     * @memberof VariationEvalSummary
     */
    'value'?: any;
    /**
     * The number of evaluations in the ten minutes before the flag event
     * @type {number}
     * @memberof VariationEvalSummary
     */
    'before'?: number;
    /**
     * The number of evaluations in the ten minutes after the flag event
     * @type {number}
     * @memberof VariationEvalSummary
     */
    'after'?: number;
}
/**
 * 
 * @export
 * @interface VariationOrRolloutRep
 */
export interface VariationOrRolloutRep {
    /**
     * The index of the variation, from the array of variations for this flag
     * @type {number}
     * @memberof VariationOrRolloutRep
     */
    'variation'?: number;
    /**
     * 
     * @type {Rollout}
     * @memberof VariationOrRolloutRep
     */
    'rollout'?: Rollout;
}
/**
 * 
 * @export
 * @interface VariationSummary
 */
export interface VariationSummary {
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'rules': number;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'nullRules': number;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'targets': number;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'contextTargets': number;
    /**
     * 
     * @type {boolean}
     * @memberof VariationSummary
     */
    'isFallthrough'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VariationSummary
     */
    'isOff'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VariationSummary
     */
    'rollout'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariationSummary
     */
    'bucketBy'?: string;
}
/**
 * 
 * @export
 * @interface VersionsRep
 */
export interface VersionsRep {
    /**
     * A list of all valid API versions. To learn more about our versioning, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).
     * @type {Array<number>}
     * @memberof VersionsRep
     */
    'validVersions': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof VersionsRep
     */
    'latestVersion': number;
    /**
     * 
     * @type {number}
     * @memberof VersionsRep
     */
    'currentVersion': number;
    /**
     * Whether the version of the API currently is use is a beta version. This is always <code>true</code> if you add the <code>LD-API-Version: beta</code> header to your request.
     * @type {boolean}
     * @memberof VersionsRep
     */
    'beta'?: boolean;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Webhook
     */
    '_links': { [key: string]: Link; };
    /**
     * The ID of this webhook
     * @type {string}
     * @memberof Webhook
     */
    '_id': string;
    /**
     * A human-readable name for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'name'?: string;
    /**
     * The URL to which LaunchDarkly sends an HTTP POST payload for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * The secret for this webhook
     * @type {string}
     * @memberof Webhook
     */
    'secret'?: string;
    /**
     * Represents a Custom role policy, defining a resource kinds filter the webhook responds to.
     * @type {Array<Statement>}
     * @memberof Webhook
     */
    'statements'?: Array<Statement>;
    /**
     * Whether or not this webhook is enabled
     * @type {boolean}
     * @memberof Webhook
     */
    'on': boolean;
    /**
     * List of tags for this webhook
     * @type {Array<string>}
     * @memberof Webhook
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Access}
     * @memberof Webhook
     */
    '_access'?: Access;
}
/**
 * 
 * @export
 * @interface WebhookPost
 */
export interface WebhookPost {
    /**
     * A human-readable name for your webhook
     * @type {string}
     * @memberof WebhookPost
     */
    'name'?: string;
    /**
     * The URL of the remote webhook
     * @type {string}
     * @memberof WebhookPost
     */
    'url': string;
    /**
     * If sign is true, and the secret attribute is omitted, LaunchDarkly automatically generates a secret for you.
     * @type {string}
     * @memberof WebhookPost
     */
    'secret'?: string;
    /**
     * 
     * @type {Array<StatementPost>}
     * @memberof WebhookPost
     */
    'statements'?: Array<StatementPost>;
    /**
     * If sign is false, the webhook does not include a signature header, and the secret can be omitted.
     * @type {boolean}
     * @memberof WebhookPost
     */
    'sign': boolean;
    /**
     * Whether or not this webhook is enabled.
     * @type {boolean}
     * @memberof WebhookPost
     */
    'on': boolean;
    /**
     * List of tags for this webhook
     * @type {Array<string>}
     * @memberof WebhookPost
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhooks
 */
export interface Webhooks {
    /**
     * The location and content type of related resources
     * @type {{ [key: string]: Link; }}
     * @memberof Webhooks
     */
    '_links': { [key: string]: Link; };
    /**
     * An array of webhooks
     * @type {Array<Webhook>}
     * @memberof Webhooks
     */
    'items': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WeightedVariation
 */
export interface WeightedVariation {
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    'variation': number;
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    'weight': number;
    /**
     * 
     * @type {boolean}
     * @memberof WeightedVariation
     */
    '_untracked'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateMetadata
 */
export interface WorkflowTemplateMetadata {
    /**
     * 
     * @type {Array<WorkflowTemplateParameter>}
     * @memberof WorkflowTemplateMetadata
     */
    'parameters'?: Array<WorkflowTemplateParameter>;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateOutput
 */
export interface WorkflowTemplateOutput {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_key': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowTemplateOutput
     */
    '_creationDate': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    '_maintainerId': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof WorkflowTemplateOutput
     */
    '_links': { [key: string]: Link; };
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateOutput
     */
    'description'?: string;
    /**
     * 
     * @type {Array<StageOutput>}
     * @memberof WorkflowTemplateOutput
     */
    'stages'?: Array<StageOutput>;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateParameter
 */
export interface WorkflowTemplateParameter {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateParameter
     */
    '_id'?: string;
    /**
     * The path of the property to parameterize, relative to its parent condition or instruction
     * @type {string}
     * @memberof WorkflowTemplateParameter
     */
    'path'?: string;
    /**
     * 
     * @type {ParameterDefault}
     * @memberof WorkflowTemplateParameter
     */
    'default'?: ParameterDefault;
    /**
     * Whether the default value is valid for the target flag and environment
     * @type {boolean}
     * @memberof WorkflowTemplateParameter
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkflowTemplatesListingOutputRep
 */
export interface WorkflowTemplatesListingOutputRep {
    /**
     * 
     * @type {Array<WorkflowTemplateOutput>}
     * @memberof WorkflowTemplatesListingOutputRep
     */
    'items': Array<WorkflowTemplateOutput>;
}

/**
 * AccessTokensApi - axios parameter creator
 * @export
 */
export const AccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {number} [limit] The number of access tokens to return in the response. Defaults to 25.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (showAll?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (showAll !== undefined) {
                localVarQueryParameter['showAll'] = showAll;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an access token\'s settings. Updating an access token uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchToken', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchToken', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken: async (accessTokenPost: AccessTokenPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenPost' is not null or undefined
            assertParamExists('postToken', 'accessTokenPost', accessTokenPost)
            const localVarPath = `/api/v2/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken: async (id: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetToken', 'id', id)
            const localVarPath = `/api/v2/tokens/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessTokensApi - functional programming interface
 * @export
 */
export const AccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {number} [limit] The number of access tokens to return in the response. Defaults to 25.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(showAll?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(showAll, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an access token\'s settings. Updating an access token uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchToken(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchToken(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postToken(accessTokenPost: AccessTokenPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postToken(accessTokenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetToken(id: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetToken(id, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessTokensApi - factory interface
 * @export
 */
export const AccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessTokensApiFp(configuration)
    return {
        /**
         * Delete an access token by ID.
         * @summary Delete access token
         * @param {string} id The ID of the access token to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single access token by ID.
         * @summary Get access token
         * @param {string} id The ID of the access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(id: string, options?: any): AxiosPromise<Token> {
            return localVarFp.getToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all access tokens.
         * @summary List access tokens
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
         * @param {number} [limit] The number of access tokens to return in the response. Defaults to 25.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(showAll?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<Tokens> {
            return localVarFp.getTokens(showAll, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an access token\'s settings. Updating an access token uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch access token
         * @param {string} id The ID of the access token to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Token> {
            return localVarFp.patchToken(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new access token.
         * @summary Create access token
         * @param {AccessTokenPost} accessTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken(accessTokenPost: AccessTokenPost, options?: any): AxiosPromise<Token> {
            return localVarFp.postToken(accessTokenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an access token\'s secret key with an optional expiry time for the old key.
         * @summary Reset access token
         * @param {string} id The ID of the access token to update
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken(id: string, expiry?: number, options?: any): AxiosPromise<Token> {
            return localVarFp.resetToken(id, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessTokensApi - object-oriented interface
 * @export
 * @class AccessTokensApi
 * @extends {BaseAPI}
 */
export class AccessTokensApi extends BaseAPI {
    /**
     * Delete an access token by ID.
     * @summary Delete access token
     * @param {string} id The ID of the access token to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public deleteToken(id: string, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).deleteToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single access token by ID.
     * @summary Get access token
     * @param {string} id The ID of the access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getToken(id: string, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).getToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all access tokens.
     * @summary List access tokens
     * @param {boolean} [showAll] If set to true, and the authentication access token has the \&#39;Admin\&#39; role, personal access tokens for all members will be retrieved.
     * @param {number} [limit] The number of access tokens to return in the response. Defaults to 25.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getTokens(showAll?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).getTokens(showAll, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an access token\'s settings. Updating an access token uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Patch access token
     * @param {string} id The ID of the access token to update
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public patchToken(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).patchToken(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new access token.
     * @summary Create access token
     * @param {AccessTokenPost} accessTokenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public postToken(accessTokenPost: AccessTokenPost, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).postToken(accessTokenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an access token\'s secret key with an optional expiry time for the old key.
     * @summary Reset access token
     * @param {string} id The ID of the access token to update
     * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public resetToken(id: string, expiry?: number, options?: AxiosRequestConfig) {
        return AccessTokensApiFp(this.configuration).resetToken(id, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountMembersApi - axios parameter creator
 * @export
 */
export const AccountMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMember', 'id', id)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMember', 'id', id)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource. Note: `accessCheck` is only supported in API version `20220603` and earlier. To learn more, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).   - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (limit?: number, offset?: number, filter?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a single account member. Updating a member uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  You can update only an account member\'s role or custom role using a JSON patch. Members can update their own names and email addresses though the LaunchDarkly UI.  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchMember', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchMember', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMemberTeams: async (id: string, memberTeamsPostInput: MemberTeamsPostInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postMemberTeams', 'id', id)
            // verify required parameter 'memberTeamsPostInput' is not null or undefined
            assertParamExists('postMemberTeams', 'memberTeamsPostInput', memberTeamsPostInput)
            const localVarPath = `/api/v2/members/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberTeamsPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers: async (newMemberForm: Array<NewMemberForm>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newMemberForm' is not null or undefined
            assertParamExists('postMembers', 'newMemberForm', newMemberForm)
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newMemberForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountMembersApi - functional programming interface
 * @export
 */
export const AccountMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMember(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMember(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource. Note: `accessCheck` is only supported in API version `20220603` and earlier. To learn more, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).   - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(limit, offset, filter, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a single account member. Updating a member uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  You can update only an account member\'s role or custom role using a JSON patch. Members can update their own names and email addresses though the LaunchDarkly UI.  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMember(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMember(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMemberTeams(id, memberTeamsPostInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMembers(newMemberForm: Array<NewMemberForm>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMembers(newMemberForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountMembersApi - factory interface
 * @export
 */
export const AccountMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountMembersApiFp(configuration)
    return {
        /**
         * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
         * @summary Delete account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
         * @summary Get account member
         * @param {string} id The member ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id: string, options?: any): AxiosPromise<Member> {
            return localVarFp.getMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource. Note: `accessCheck` is only supported in API version `20220603` and earlier. To learn more, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).   - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
         * @summary List account members
         * @param {number} [limit] The number of members to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: any): AxiosPromise<Members> {
            return localVarFp.getMembers(limit, offset, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a single account member. Updating a member uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  You can update only an account member\'s role or custom role using a JSON patch. Members can update their own names and email addresses though the LaunchDarkly UI.  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
         * @summary Modify an account member
         * @param {string} id The member ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Member> {
            return localVarFp.patchMember(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Add one member to one or more teams.
         * @summary Add a member to teams
         * @param {string} id The member ID
         * @param {MemberTeamsPostInput} memberTeamsPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: any): AxiosPromise<Member> {
            return localVarFp.postMemberTeams(id, memberTeamsPostInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
         * @summary Invite new members
         * @param {Array<NewMemberForm>} newMemberForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers(newMemberForm: Array<NewMemberForm>, options?: any): AxiosPromise<Members> {
            return localVarFp.postMembers(newMemberForm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountMembersApi - object-oriented interface
 * @export
 * @class AccountMembersApi
 * @extends {BaseAPI}
 */
export class AccountMembersApi extends BaseAPI {
    /**
     * Delete a single account member by ID. Requests to delete account members will not work if SCIM is enabled for the account.
     * @summary Delete account member
     * @param {string} id The member ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public deleteMember(id: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).deleteMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single account member by member ID.  `me` is a reserved value for the `id` parameter that returns the caller\'s member information. 
     * @summary Get account member
     * @param {string} id The member ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public getMember(id: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).getMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of account members.  By default, this returns the first 20 members. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links are not present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Filtering members  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the members\' emails and names. It is not case sensitive. - `role` is a `|` separated list of roles and custom roles. It filters the list to members who have any of the roles in the list. For the purposes of this filtering, `Owner` counts as `Admin`. - `team` is a string that matches against the key of the teams the members belong to. It is not case sensitive. - `noteam` is a boolean that filters the list of members who are not on a team if true and members on a team if false. - `lastSeen` is a JSON object in one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `accessCheck` is a string that represents a specific action on a specific resource and is in the format `<ActionSpecifier>:<ResourceSpecifier>`. It filters the list to members who have the ability to perform that action on that resource. Note: `accessCheck` is only supported in API version `20220603` and earlier. To learn more, read [Versioning](https://apidocs.launchdarkly.com/#section/Overview/Versioning).   - For example, the filter `accessCheck:createApprovalRequest:proj/default:env/test:flag/alternate-page` matches members with the ability to create an approval request for the `alternate-page` flag in the `test` environment of the `default` project.   - Wildcard and tag filters are not supported when filtering for access.  For example, the filter `query:abc,role:admin|customrole` matches members with the string `abc` in their email or name, ignoring case, who also are either an `Owner` or `Admin` or have the custom role `customrole`.  ### Sorting members  LaunchDarkly supports two fields for sorting: `displayName` and `lastSeen`:  - `displayName` sorts by first + last name, using the member\'s email if no name is set. - `lastSeen` sorts by the `_lastSeen` property. LaunchDarkly considers members that have never been seen or have no data the oldest. 
     * @summary List account members
     * @param {number} [limit] The number of members to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).getMembers(limit, offset, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a single account member. Updating a member uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the account member object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array. For example, to add a new custom role to a member, use the following request body:  ```   [     {       \"op\": \"add\",       \"path\": \"/customRoles/0\",       \"value\": \"some-role-id\"     }   ] ```  You can update only an account member\'s role or custom role using a JSON patch. Members can update their own names and email addresses though the LaunchDarkly UI.  When SAML SSO or SCIM is enabled for the account, account members are managed in the Identity Provider (IdP). Requests to update account members will succeed, but the IdP will override the update shortly afterwards. 
     * @summary Modify an account member
     * @param {string} id The member ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public patchMember(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).patchMember(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add one member to one or more teams.
     * @summary Add a member to teams
     * @param {string} id The member ID
     * @param {MemberTeamsPostInput} memberTeamsPostInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public postMemberTeams(id: string, memberTeamsPostInput: MemberTeamsPostInput, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).postMemberTeams(id, memberTeamsPostInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite one or more new members to join an account. Each member is sent an invitation. Members with \"admin\" or \"owner\" roles may create new members, as well as anyone with a \"createMember\" permission for \"member/\\*\". If a member cannot be invited, the entire request is rejected and no members are invited from that request.  Each member _must_ have an `email` field and either a `role` or a `customRoles` field. If any of the fields are not populated correctly, the request is rejected with the reason specified in the \"message\" field of the response.  Requests to create account members will not work if SCIM is enabled for the account.  _No more than 50 members may be created per request._  A request may also fail because of conflicts with existing members. These conflicts are reported using the additional `code` and `invalid_emails` response fields with the following possible values for `code`:  - **email_already_exists_in_account**: A member with this email address already exists in this account. - **email_taken_in_different_account**: A member with this email address exists in another account. - **duplicate_email**s: This request contains two or more members with the same email address.  A request that fails for one of the above reasons returns an HTTP response code of 400 (Bad Request). 
     * @summary Invite new members
     * @param {Array<NewMemberForm>} newMemberForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersApi
     */
    public postMembers(newMemberForm: Array<NewMemberForm>, options?: AxiosRequestConfig) {
        return AccountMembersApiFp(this.configuration).postMembers(newMemberForm, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountMembersBetaApi - axios parameter creator
 * @export
 */
export const AccountMembersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to perform a partial update to multiple members is available to customers on an Enterprise plan. If you are on a Pro plan, you can update members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  <details> <summary>Click to expand instructions for <strong>updating members</strong></summary>  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMemberRoles\",     \"value\": \"reader\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersRoles\",     \"value\": \"reader\",     \"filterLastSeen\": { \"never\": true }   }] } ```  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMembers: async (membersPatchInput: MembersPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membersPatchInput' is not null or undefined
            assertParamExists('patchMembers', 'membersPatchInput', membersPatchInput)
            const localVarPath = `/api/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountMembersBetaApi - functional programming interface
 * @export
 */
export const AccountMembersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountMembersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to perform a partial update to multiple members is available to customers on an Enterprise plan. If you are on a Pro plan, you can update members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  <details> <summary>Click to expand instructions for <strong>updating members</strong></summary>  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMemberRoles\",     \"value\": \"reader\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersRoles\",     \"value\": \"reader\",     \"filterLastSeen\": { \"never\": true }   }] } ```  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMembers(membersPatchInput: MembersPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkEditMembersRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMembers(membersPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountMembersBetaApi - factory interface
 * @export
 */
export const AccountMembersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountMembersBetaApiFp(configuration)
    return {
        /**
         * > ### Full use of this API resource is an Enterprise feature > > The ability to perform a partial update to multiple members is available to customers on an Enterprise plan. If you are on a Pro plan, you can update members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  <details> <summary>Click to expand instructions for <strong>updating members</strong></summary>  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMemberRoles\",     \"value\": \"reader\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersRoles\",     \"value\": \"reader\",     \"filterLastSeen\": { \"never\": true }   }] } ```  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Modify account members
         * @param {MembersPatchInput} membersPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMembers(membersPatchInput: MembersPatchInput, options?: any): AxiosPromise<BulkEditMembersRep> {
            return localVarFp.patchMembers(membersPatchInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountMembersBetaApi - object-oriented interface
 * @export
 * @class AccountMembersBetaApi
 * @extends {BaseAPI}
 */
export class AccountMembersBetaApi extends BaseAPI {
    /**
     * > ### Full use of this API resource is an Enterprise feature > > The ability to perform a partial update to multiple members is available to customers on an Enterprise plan. If you are on a Pro plan, you can update members individually. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Perform a partial update to multiple members. Updating members uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating members.  <details> <summary>Click to expand instructions for <strong>updating members</strong></summary>  #### replaceMembersRoles  Replaces the roles of the specified members. This also removes all custom roles assigned to the specified members.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMemberRoles\",     \"value\": \"reader\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersRoles  Replaces the roles of all members. This also removes all custom roles assigned to the specified members.  Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `value`: The new role. Must be a valid built-in role. To learn more about built-in roles, read [LaunchDarkly\'s built-in roles](https://docs.launchdarkly.com/home/members/built-in-roles). - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersRoles\",     \"value\": \"reader\",     \"filterLastSeen\": { \"never\": true }   }] } ```  #### replaceMembersCustomRoles  Replaces the custom roles of the specified members.  ##### Parameters  - `values`: List of new custom roles. Must be a valid custom role key or ID. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"memberIDs\": [       \"1234a56b7c89d012345e678f\",       \"507f1f77bcf86cd799439011\"     ]   }] } ```  #### replaceAllMembersCustomRoles  Replaces the custom roles of all members. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `values`: List of new roles. Must be a valid custom role key or ID. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceAllMembersCustomRoles\",     \"values\": [ \"example-custom-role\" ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
     * @summary Modify account members
     * @param {MembersPatchInput} membersPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountMembersBetaApi
     */
    public patchMembers(membersPatchInput: MembersPatchInput, options?: AxiosRequestConfig) {
        return AccountMembersBetaApiFp(this.configuration).patchMembers(membersPatchInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountUsageBetaApi - axios parameter creator
 * @export
 */
export const AccountUsageBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a time-series array of the number of monthly data export events from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get data export events usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExportEventsUsage: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/data-export-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationsUsage: async (projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getEvaluationsUsage', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/usage/evaluations/{projectKey}/{environmentKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsage: async (type: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getEventsUsage', 'type', type)
            const localVarPath = `/api/v2/usage/events/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of monthly experimentation keys from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation keys usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationKeysUsage: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/experimentation-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of monthly experimentation units from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation units usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationUnitsUsage: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/experimentation-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauSdksByType: async (from?: string, to?: string, sdktype?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau/sdks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (sdktype !== undefined) {
                localVarQueryParameter['sdktype'] = sdktype;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsage: async (from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (sdktype !== undefined) {
                localVarQueryParameter['sdktype'] = sdktype;
            }

            if (sdk !== undefined) {
                localVarQueryParameter['sdk'] = sdk;
            }

            if (anonymous !== undefined) {
                localVarQueryParameter['anonymous'] = anonymous;
            }

            if (groupby !== undefined) {
                localVarQueryParameter['groupby'] = groupby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsageByCategory: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/mau/bycategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of monthly service connections from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get service connection usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceConnectionUsage: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/usage/service-connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsage: async (source: string, from?: string, to?: string, tz?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsage', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageBySdkVersion: async (source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsageBySdkVersion', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}/bysdkversion`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }

            if (sdk !== undefined) {
                localVarQueryParameter['sdk'] = sdk;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageSdkversion: async (source: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getStreamUsageSdkversion', 'source', source)
            const localVarPath = `/api/v2/usage/streams/{source}/sdkversions`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountUsageBetaApi - functional programming interface
 * @export
 */
export const AccountUsageBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountUsageBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a time-series array of the number of monthly data export events from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get data export events usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataExportEventsUsage(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesIntervalsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataExportEventsUsage(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsUsage(type: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsUsage(type, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of monthly experimentation keys from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation keys usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentationKeysUsage(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesIntervalsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentationKeysUsage(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of monthly experimentation units from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation units usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentationUnitsUsage(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesIntervalsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentationUnitsUsage(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauSdksByType(from, to, sdktype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMauUsageByCategory(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMauUsageByCategory(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of monthly service connections from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get service connection usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceConnectionUsage(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesIntervalsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceConnectionUsage(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsage(source, from, to, tz, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamUsageSdkversion(source: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkVersionListRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamUsageSdkversion(source, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountUsageBetaApi - factory interface
 * @export
 */
export const AccountUsageBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountUsageBetaApiFp(configuration)
    return {
        /**
         * Get a time-series array of the number of monthly data export events from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get data export events usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExportEventsUsage(from?: string, to?: string, options?: any): AxiosPromise<SeriesIntervalsRep> {
            return localVarFp.getDataExportEventsUsage(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get evaluations usage
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options).then((request) => request(axios, basePath));
        },
        /**
         * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get events usage
         * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsUsage(type: string, from?: string, to?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getEventsUsage(type, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of monthly experimentation keys from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation keys usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationKeysUsage(from?: string, to?: string, options?: any): AxiosPromise<SeriesIntervalsRep> {
            return localVarFp.getExperimentationKeysUsage(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of monthly experimentation units from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get experimentation units usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationUnitsUsage(from?: string, to?: string, options?: any): AxiosPromise<SeriesIntervalsRep> {
            return localVarFp.getExperimentationUnitsUsage(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU SDKs by type
         * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
         * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
         * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: any): AxiosPromise<SdkListRep> {
            return localVarFp.getMauSdksByType(from, to, sdktype, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
         * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
         * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
         * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
         * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
         * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options).then((request) => request(axios, basePath));
        },
        /**
         * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
         * @summary Get MAU usage by category
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMauUsageByCategory(from?: string, to?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getMauUsageByCategory(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of monthly service connections from your account. The granularity is always daily, with a maximum of 31 days.
         * @summary Get service connection usage
         * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
         * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceConnectionUsage(from?: string, to?: string, options?: any): AxiosPromise<SeriesIntervalsRep> {
            return localVarFp.getServiceConnectionUsage(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getStreamUsage(source, from, to, tz, options).then((request) => request(axios, basePath));
        },
        /**
         * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
         * @summary Get stream usage by SDK version
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
         * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
         * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
         * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
         * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: any): AxiosPromise<SeriesListRep> {
            return localVarFp.getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
         * @summary Get stream usage SDK versions
         * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamUsageSdkversion(source: string, options?: any): AxiosPromise<SdkVersionListRep> {
            return localVarFp.getStreamUsageSdkversion(source, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountUsageBetaApi - object-oriented interface
 * @export
 * @class AccountUsageBetaApi
 * @extends {BaseAPI}
 */
export class AccountUsageBetaApi extends BaseAPI {
    /**
     * Get a time-series array of the number of monthly data export events from your account. The granularity is always daily, with a maximum of 31 days.
     * @summary Get data export events usage
     * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
     * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getDataExportEventsUsage(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getDataExportEventsUsage(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get evaluations usage
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getEvaluationsUsage(projectKey: string, environmentKey: string, featureFlagKey: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getEvaluationsUsage(projectKey, environmentKey, featureFlagKey, from, to, tz, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get time-series arrays of the number of times a flag is evaluated, broken down by the variation that resulted from that evaluation. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get events usage
     * @param {string} type The type of event to retrieve. Must be either &#x60;received&#x60; or &#x60;published&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getEventsUsage(type: string, from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getEventsUsage(type, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of monthly experimentation keys from your account. The granularity is always daily, with a maximum of 31 days.
     * @summary Get experimentation keys usage
     * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
     * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getExperimentationKeysUsage(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getExperimentationKeysUsage(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of monthly experimentation units from your account. The granularity is always daily, with a maximum of 31 days.
     * @summary Get experimentation units usage
     * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
     * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getExperimentationUnitsUsage(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getExperimentationUnitsUsage(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of SDKs. These are all of the SDKs that have connected to LaunchDarkly by monthly active users (MAU) in the requested time period.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
     * @summary Get MAU SDKs by type
     * @param {string} [from] The data returned starts from this timestamp. Defaults to seven days ago. The timestamp is in Unix milliseconds, for example, 1656694800000.
     * @param {string} [to] The data returned ends at this timestamp. Defaults to the current time. The timestamp is in Unix milliseconds, for example, 1657904400000.
     * @param {string} [sdktype] The type of SDK with monthly active users (MAU) to list. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauSdksByType(from?: string, to?: string, sdktype?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauSdksByType(from, to, sdktype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of monthly active users (MAU) seen by LaunchDarkly from your account. The granularity is always daily.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
     * @summary Get MAU usage
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [project] A project key to filter results to. Can be specified multiple times, one query parameter per project key, to view data for multiple projects.
     * @param {string} [environment] An environment key to filter results to. When using this parameter, exactly one project key must also be set. Can be specified multiple times as separate query parameters to view data for multiple environments within a single project.
     * @param {string} [sdktype] An SDK type to filter results to. Can be specified multiple times, one query parameter per SDK type. Valid values: client, server
     * @param {string} [sdk] An SDK name to filter results to. Can be specified multiple times, one query parameter per SDK.
     * @param {string} [anonymous] If specified, filters results to either anonymous or nonanonymous users.
     * @param {string} [groupby] If specified, returns data for each distinct value of the given field. Can be specified multiple times to group data by multiple dimensions (for example, to group by both project and SDK). Valid values: project, environment, sdktype, sdk, anonymous
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauUsage(from?: string, to?: string, project?: string, environment?: string, sdktype?: string, sdk?: string, anonymous?: string, groupby?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauUsage(from, to, project, environment, sdktype, sdk, anonymous, groupby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get time-series arrays of the number of monthly active users (MAU) seen by LaunchDarkly from your account, broken down by the category of users. The category is either `browser`, `mobile`, or `backend`.<br/><br/>Endpoints for retrieving monthly active users (MAU) do not return information about active context instances. After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should not rely on this endpoint. To learn more, read [Account usage metrics](https://docs.launchdarkly.com/home/billing/usage-metrics).
     * @summary Get MAU usage by category
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getMauUsageByCategory(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getMauUsageByCategory(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of monthly service connections from your account. The granularity is always daily, with a maximum of 31 days.
     * @summary Get service connection usage
     * @param {string} [from] The series of data returned starts from this timestamp (Unix seconds). Defaults to the beginning of the current month.
     * @param {string} [to] The series of data returned ends at this timestamp (Unix seconds). Defaults to the current time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getServiceConnectionUsage(from?: string, to?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getServiceConnectionUsage(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a time-series array of the number of streaming connections to LaunchDarkly in each time period. The granularity of the data depends on the age of the data requested. If the requested range is within the past two hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get stream usage
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 30 days ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsage(source: string, from?: string, to?: string, tz?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsage(source, from, to, tz, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
     * @summary Get stream usage by SDK version
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {string} [from] The series of data returned starts from this timestamp. Defaults to 24 hours ago.
     * @param {string} [to] The series of data returned ends at this timestamp. Defaults to the current time.
     * @param {string} [tz] The timezone to use for breaks between days when returning daily data.
     * @param {string} [sdk] If included, this filters the returned series to only those that match this SDK name.
     * @param {string} [version] If included, this filters the returned series to only those that match this SDK version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsageBySdkVersion(source: string, from?: string, to?: string, tz?: string, sdk?: string, version?: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsageBySdkVersion(source, from, to, tz, sdk, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of SDK version objects, which contain an SDK name and version. These are all of the SDKs that have connected to LaunchDarkly from your account in the past 60 days.
     * @summary Get stream usage SDK versions
     * @param {string} source The source of streaming connections to describe. Must be either &#x60;client&#x60; or &#x60;server&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsageBetaApi
     */
    public getStreamUsageSdkversion(source: string, options?: AxiosRequestConfig) {
        return AccountUsageBetaApiFp(this.configuration).getStreamUsageSdkversion(source, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsBetaApi - axios parameter creator
 * @export
 */
export const ApplicationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an application.
         * @summary Delete application
         * @param {string} applicationKey The application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (applicationKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('deleteApplication', 'applicationKey', applicationKey)
            const localVarPath = `/api/v2/applications/{applicationKey}`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an application version.
         * @summary Delete application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationVersion: async (applicationKey: string, versionKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('deleteApplicationVersion', 'applicationKey', applicationKey)
            // verify required parameter 'versionKey' is not null or undefined
            assertParamExists('deleteApplicationVersion', 'versionKey', versionKey)
            const localVarPath = `/api/v2/applications/{applicationKey}/versions/{versionKey}`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)))
                .replace(`{${"versionKey"}}`, encodeURIComponent(String(versionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieve an application by the application key.  ### Expanding the application response  LaunchDarkly supports expanding the \"Get application\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get application by key
         * @param {string} applicationKey The application key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('getApplication', 'applicationKey', applicationKey)
            const localVarPath = `/api/v2/applications/{applicationKey}`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of versions for a specific application in an account.
         * @summary Get application versions by application key
         * @param {string} applicationKey The application key
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;supported&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of versions to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationVersions: async (applicationKey: string, filter?: string, limit?: number, offset?: number, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('getApplicationVersions', 'applicationKey', applicationKey)
            const localVarPath = `/api/v2/applications/{applicationKey}/versions`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a list of applications.  ### Expanding the applications response  LaunchDarkly supports expanding the \"Get applications\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get applications
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;kind&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;kind anyOf [\&#39;mobile\&#39;, \&#39;server\&#39;],key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of applications to return. Defaults to 10.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications: async (filter?: string, limit?: number, offset?: number, sort?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an application. You can update the `description` and `kind` fields. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application
         * @param {string} applicationKey The application key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApplication: async (applicationKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('patchApplication', 'applicationKey', applicationKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchApplication', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/applications/{applicationKey}`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an application version. You can update the `supported` field. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application version. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApplicationVersion: async (applicationKey: string, versionKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationKey' is not null or undefined
            assertParamExists('patchApplicationVersion', 'applicationKey', applicationKey)
            // verify required parameter 'versionKey' is not null or undefined
            assertParamExists('patchApplicationVersion', 'versionKey', versionKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchApplicationVersion', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/applications/{applicationKey}/versions/{versionKey}`
                .replace(`{${"applicationKey"}}`, encodeURIComponent(String(applicationKey)))
                .replace(`{${"versionKey"}}`, encodeURIComponent(String(versionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsBetaApi - functional programming interface
 * @export
 */
export const ApplicationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an application.
         * @summary Delete application
         * @param {string} applicationKey The application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(applicationKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(applicationKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an application version.
         * @summary Delete application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationVersion(applicationKey: string, versionKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationVersion(applicationKey, versionKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Retrieve an application by the application key.  ### Expanding the application response  LaunchDarkly supports expanding the \"Get application\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get application by key
         * @param {string} applicationKey The application key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of versions for a specific application in an account.
         * @summary Get application versions by application key
         * @param {string} applicationKey The application key
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;supported&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of versions to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationVersions(applicationKey: string, filter?: string, limit?: number, offset?: number, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationVersionsCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationVersions(applicationKey, filter, limit, offset, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a list of applications.  ### Expanding the applications response  LaunchDarkly supports expanding the \"Get applications\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get applications
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;kind&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;kind anyOf [\&#39;mobile\&#39;, \&#39;server\&#39;],key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of applications to return. Defaults to 10.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplications(filter?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplications(filter, limit, offset, sort, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an application. You can update the `description` and `kind` fields. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application
         * @param {string} applicationKey The application key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApplication(applicationKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApplication(applicationKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an application version. You can update the `supported` field. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application version. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApplicationVersion(applicationKey: string, versionKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationVersionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApplicationVersion(applicationKey, versionKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsBetaApi - factory interface
 * @export
 */
export const ApplicationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsBetaApiFp(configuration)
    return {
        /**
         * Delete an application.
         * @summary Delete application
         * @param {string} applicationKey The application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(applicationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an application version.
         * @summary Delete application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationVersion(applicationKey: string, versionKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationVersion(applicationKey, versionKey, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieve an application by the application key.  ### Expanding the application response  LaunchDarkly supports expanding the \"Get application\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get application by key
         * @param {string} applicationKey The application key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(applicationKey: string, expand?: string, options?: any): AxiosPromise<ApplicationRep> {
            return localVarFp.getApplication(applicationKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of versions for a specific application in an account.
         * @summary Get application versions by application key
         * @param {string} applicationKey The application key
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;supported&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of versions to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationVersions(applicationKey: string, filter?: string, limit?: number, offset?: number, sort?: string, options?: any): AxiosPromise<ApplicationVersionsCollectionRep> {
            return localVarFp.getApplicationVersions(applicationKey, filter, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a list of applications.  ### Expanding the applications response  LaunchDarkly supports expanding the \"Get applications\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
         * @summary Get applications
         * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;kind&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;kind anyOf [\&#39;mobile\&#39;, \&#39;server\&#39;],key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
         * @param {number} [limit] The number of applications to return. Defaults to 10.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications(filter?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): AxiosPromise<ApplicationCollectionRep> {
            return localVarFp.getApplications(filter, limit, offset, sort, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an application. You can update the `description` and `kind` fields. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application
         * @param {string} applicationKey The application key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApplication(applicationKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<ApplicationRep> {
            return localVarFp.patchApplication(applicationKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an application version. You can update the `supported` field. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application version. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update application version
         * @param {string} applicationKey The application key
         * @param {string} versionKey The application version key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApplicationVersion(applicationKey: string, versionKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<ApplicationVersionRep> {
            return localVarFp.patchApplicationVersion(applicationKey, versionKey, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsBetaApi - object-oriented interface
 * @export
 * @class ApplicationsBetaApi
 * @extends {BaseAPI}
 */
export class ApplicationsBetaApi extends BaseAPI {
    /**
     * Delete an application.
     * @summary Delete application
     * @param {string} applicationKey The application key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public deleteApplication(applicationKey: string, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).deleteApplication(applicationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an application version.
     * @summary Delete application version
     * @param {string} applicationKey The application key
     * @param {string} versionKey The application version key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public deleteApplicationVersion(applicationKey: string, versionKey: string, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).deleteApplicationVersion(applicationKey, versionKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieve an application by the application key.  ### Expanding the application response  LaunchDarkly supports expanding the \"Get application\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
     * @summary Get application by key
     * @param {string} applicationKey The application key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public getApplication(applicationKey: string, expand?: string, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).getApplication(applicationKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of versions for a specific application in an account.
     * @summary Get application versions by application key
     * @param {string} applicationKey The application key
     * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;supported&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
     * @param {number} [limit] The number of versions to return. Defaults to 50.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public getApplicationVersions(applicationKey: string, filter?: string, limit?: number, offset?: number, sort?: string, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).getApplicationVersions(applicationKey, filter, limit, offset, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a list of applications.  ### Expanding the applications response  LaunchDarkly supports expanding the \"Get applications\" response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `flags` includes details on the flags that have been evaluated by the application  For example, use `?expand=flags` to include the `flags` field in the response. By default, this field is **not** included in the response. 
     * @summary Get applications
     * @param {string} [filter] Accepts filter by &#x60;key&#x60;, &#x60;name&#x60;, &#x60;kind&#x60;, and &#x60;autoAdded&#x60;. Example: &#x60;filter&#x3D;kind anyOf [\&#39;mobile\&#39;, \&#39;server\&#39;],key equals \&#39;test-key\&#39;&#x60;. To learn more about the filter syntax, read [Filtering applications and application versions](/tag/Applications-(beta)#filtering-contexts-and-context-instances).
     * @param {number} [limit] The number of applications to return. Defaults to 10.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#x60;creationDate&#x60;, &#x60;name&#x60;. Examples: &#x60;sort&#x3D;name&#x60; sort by names ascending, &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Options: &#x60;flags&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public getApplications(filter?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).getApplications(filter, limit, offset, sort, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an application. You can update the `description` and `kind` fields. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update application
     * @param {string} applicationKey The application key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public patchApplication(applicationKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).patchApplication(applicationKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an application version. You can update the `supported` field. Requires a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes to the application version. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update application version
     * @param {string} applicationKey The application key
     * @param {string} versionKey The application version key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsBetaApi
     */
    public patchApplicationVersion(applicationKey: string, versionKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ApplicationsBetaApiFp(this.configuration).patchApplicationVersion(applicationKey, versionKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApprovalsApi - axios parameter creator
 * @export
 */
export const ApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an approval request.
         * @summary Delete approval request
         * @param {string} id The approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequest: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApprovalRequest', 'id', id)
            const localVarPath = `/api/v2/approval-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequestForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteApprovalRequestForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteApprovalRequestForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteApprovalRequestForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApprovalRequestForFlag', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getApprovalForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApprovalForFlag', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an approval request by approval request ID.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary Get approval request
         * @param {string} id The approval request ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequest: async (id: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApprovalRequest', 'id', id)
            const localVarPath = `/api/v2/approval-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all approval requests.  ### Filtering approvals  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `notifyMemberIds` filters for only approvals that are assigned to a member in the specified list. For example: `filter=notifyMemberIds anyOf [\"memberId1\", \"memberId2\"]`. - `requestorId` filters for only approvals that correspond to the ID of the member who requested the approval. For example: `filter=requestorId equals 457034721476302714390214`. - `resourceId` filters for only approvals that correspond to the the specified resource identifier. For example: `filter=resourceId equals proj/my-project:env/my-environment:flag/my-flag`. - `reviewStatus` filters for only approvals which correspond to the review status in the specified list. The possible values are `approved`, `declined`, and `pending`. For example: `filter=reviewStatus anyOf [\"pending\", \"approved\"]`. - `status` filters for only approvals which correspond to the status in the specified list. The possible values are `pending`, `scheduled`, `failed`, and `completed`. For example: `filter=status anyOf [\"pending\", \"scheduled\"]`.  You can also apply multiple filters at once. For example, setting `filter=projectKey equals my-project, reviewStatus anyOf [\"pending\",\"approved\"]` matches approval requests which correspond to the `my-project` project key, and a review status of either `pending` or `approved`.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary List approval requests
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {number} [limit] The number of approvals to return. Defaults to 20. Maximum limit is 200.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequests: async (filter?: string, expand?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/approval-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getApprovalsForFlag', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an approval request.  This endpoint currently supports creating an approval request for a flag across all environments with the following instructions:  - `addVariation` - `removeVariation` - `updateVariation` - `updateDefaultVariation`  For details on using these instructions, read [Update feature flag](/tag/Feature-flags#operation/patchFeatureFlag).  To create an approval for a flag specific to an environment, use [Create approval request for a flag](/tag/Approvals#operation/postApprovalRequestForFlag). 
         * @summary Create approval request
         * @param {CreateApprovalRequestRequest} createApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequest: async (createApprovalRequestRequest: CreateApprovalRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApprovalRequestRequest' is not null or undefined
            assertParamExists('postApprovalRequest', 'createApprovalRequestRequest', createApprovalRequestRequest)
            const localVarPath = `/api/v2/approval-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApprovalRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApply: async (id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestApply', 'id', id)
            // verify required parameter 'postApprovalRequestApplyRequest' is not null or undefined
            assertParamExists('postApprovalRequestApply', 'postApprovalRequestApplyRequest', postApprovalRequestApplyRequest)
            const localVarPath = `/api/v2/approval-requests/{id}/apply`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestApplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApplyForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequestApplyForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestApplyForFlag', 'id', id)
            // verify required parameter 'postApprovalRequestApplyRequest' is not null or undefined
            assertParamExists('postApprovalRequestApplyForFlag', 'postApprovalRequestApplyRequest', postApprovalRequestApplyRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/apply`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestApplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequestForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequestForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequestForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'createFlagConfigApprovalRequestRequest' is not null or undefined
            assertParamExists('postApprovalRequestForFlag', 'createFlagConfigApprovalRequestRequest', createFlagConfigApprovalRequestRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFlagConfigApprovalRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} id The approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReview: async (id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'id', id)
            // verify required parameter 'postApprovalRequestReviewRequest' is not null or undefined
            assertParamExists('postApprovalRequestReview', 'postApprovalRequestReviewRequest', postApprovalRequestReviewRequest)
            const localVarPath = `/api/v2/approval-requests/{id}/reviews`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReviewForFlag: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postApprovalRequestReviewForFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postApprovalRequestReviewForFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postApprovalRequestReviewForFlag', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postApprovalRequestReviewForFlag', 'id', id)
            // verify required parameter 'postApprovalRequestReviewRequest' is not null or undefined
            assertParamExists('postApprovalRequestReviewForFlag', 'postApprovalRequestReviewRequest', postApprovalRequestReviewRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{id}/reviews`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApprovalRequestReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagCopyConfigApprovalRequest: async (projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'environmentKey', environmentKey)
            // verify required parameter 'createCopyFlagConfigApprovalRequestRequest' is not null or undefined
            assertParamExists('postFlagCopyConfigApprovalRequest', 'createCopyFlagConfigApprovalRequestRequest', createCopyFlagConfigApprovalRequestRequest)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests-flag-copy`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCopyFlagConfigApprovalRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApprovalsApi - functional programming interface
 * @export
 */
export const ApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an approval request.
         * @summary Delete approval request
         * @param {string} id The approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApprovalRequest(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApprovalRequest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an approval request by approval request ID.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary Get approval request
         * @param {string} id The approval request ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalRequest(id: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandableApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalRequest(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all approval requests.  ### Filtering approvals  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `notifyMemberIds` filters for only approvals that are assigned to a member in the specified list. For example: `filter=notifyMemberIds anyOf [\"memberId1\", \"memberId2\"]`. - `requestorId` filters for only approvals that correspond to the ID of the member who requested the approval. For example: `filter=requestorId equals 457034721476302714390214`. - `resourceId` filters for only approvals that correspond to the the specified resource identifier. For example: `filter=resourceId equals proj/my-project:env/my-environment:flag/my-flag`. - `reviewStatus` filters for only approvals which correspond to the review status in the specified list. The possible values are `approved`, `declined`, and `pending`. For example: `filter=reviewStatus anyOf [\"pending\", \"approved\"]`. - `status` filters for only approvals which correspond to the status in the specified list. The possible values are `pending`, `scheduled`, `failed`, and `completed`. For example: `filter=status anyOf [\"pending\", \"scheduled\"]`.  You can also apply multiple filters at once. For example, setting `filter=projectKey equals my-project, reviewStatus anyOf [\"pending\",\"approved\"]` matches approval requests which correspond to the `my-project` project key, and a review status of either `pending` or `approved`.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary List approval requests
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {number} [limit] The number of approvals to return. Defaults to 20. Maximum limit is 200.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalRequests(filter?: string, expand?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandableApprovalRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalRequests(filter, expand, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an approval request.  This endpoint currently supports creating an approval request for a flag across all environments with the following instructions:  - `addVariation` - `removeVariation` - `updateVariation` - `updateDefaultVariation`  For details on using these instructions, read [Update feature flag](/tag/Feature-flags#operation/patchFeatureFlag).  To create an approval for a flag specific to an environment, use [Create approval request for a flag](/tag/Approvals#operation/postApprovalRequestForFlag). 
         * @summary Create approval request
         * @param {CreateApprovalRequestRequest} createApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequest(createApprovalRequestRequest: CreateApprovalRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequest(createApprovalRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestApply(id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestApply(id, postApprovalRequestApplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestApplyForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestApplyForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} id The approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestReview(id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestReview(id, postApprovalRequestReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApprovalRequestReviewForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApprovalRequestReviewForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagConfigApprovalRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApprovalsApi - factory interface
 * @export
 */
export const ApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApprovalsApiFp(configuration)
    return {
        /**
         * Delete an approval request.
         * @summary Delete approval request
         * @param {string} id The approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequest(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApprovalRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an approval request for a feature flag.
         * @summary Delete approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single approval request for a feature flag.
         * @summary Get approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an approval request by approval request ID.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary Get approval request
         * @param {string} id The approval request ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequest(id: string, expand?: string, options?: any): AxiosPromise<ExpandableApprovalRequestResponse> {
            return localVarFp.getApprovalRequest(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all approval requests.  ### Filtering approvals  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `notifyMemberIds` filters for only approvals that are assigned to a member in the specified list. For example: `filter=notifyMemberIds anyOf [\"memberId1\", \"memberId2\"]`. - `requestorId` filters for only approvals that correspond to the ID of the member who requested the approval. For example: `filter=requestorId equals 457034721476302714390214`. - `resourceId` filters for only approvals that correspond to the the specified resource identifier. For example: `filter=resourceId equals proj/my-project:env/my-environment:flag/my-flag`. - `reviewStatus` filters for only approvals which correspond to the review status in the specified list. The possible values are `approved`, `declined`, and `pending`. For example: `filter=reviewStatus anyOf [\"pending\", \"approved\"]`. - `status` filters for only approvals which correspond to the status in the specified list. The possible values are `pending`, `scheduled`, `failed`, and `completed`. For example: `filter=status anyOf [\"pending\", \"scheduled\"]`.  You can also apply multiple filters at once. For example, setting `filter=projectKey equals my-project, reviewStatus anyOf [\"pending\",\"approved\"]` matches approval requests which correspond to the `my-project` project key, and a review status of either `pending` or `approved`.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
         * @summary List approval requests
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {number} [limit] The number of approvals to return. Defaults to 20. Maximum limit is 200.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequests(filter?: string, expand?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ExpandableApprovalRequestsResponse> {
            return localVarFp.getApprovalRequests(filter, expand, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all approval requests for a feature flag.
         * @summary List approval requests for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FlagConfigApprovalRequestsResponse> {
            return localVarFp.getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an approval request.  This endpoint currently supports creating an approval request for a flag across all environments with the following instructions:  - `addVariation` - `removeVariation` - `updateVariation` - `updateDefaultVariation`  For details on using these instructions, read [Update feature flag](/tag/Feature-flags#operation/patchFeatureFlag).  To create an approval for a flag specific to an environment, use [Create approval request for a flag](/tag/Approvals#operation/postApprovalRequestForFlag). 
         * @summary Create approval request
         * @param {CreateApprovalRequestRequest} createApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequest(createApprovalRequestRequest: CreateApprovalRequestRequest, options?: any): AxiosPromise<ApprovalRequestResponse> {
            return localVarFp.postApprovalRequest(createApprovalRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApply(id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: any): AxiosPromise<ApprovalRequestResponse> {
            return localVarFp.postApprovalRequestApply(id, postApprovalRequestApplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply an approval request that has been approved.
         * @summary Apply approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestApplyForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequestApplyForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an approval request for a feature flag.
         * @summary Create approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request
         * @param {string} id The approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReview(id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: any): AxiosPromise<ApprovalRequestResponse> {
            return localVarFp.postApprovalRequestReview(id, postApprovalRequestReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Review an approval request by approving or denying changes.
         * @summary Review approval request for a flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The feature flag approval request ID
         * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApprovalRequestReviewForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postApprovalRequestReviewForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an approval request to copy a feature flag\'s configuration across environments.
         * @summary Create approval request to copy flag configurations across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key for the target environment
         * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: any): AxiosPromise<FlagConfigApprovalRequestResponse> {
            return localVarFp.postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApprovalsApi - object-oriented interface
 * @export
 * @class ApprovalsApi
 * @extends {BaseAPI}
 */
export class ApprovalsApi extends BaseAPI {
    /**
     * Delete an approval request.
     * @summary Delete approval request
     * @param {string} id The approval request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public deleteApprovalRequest(id: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).deleteApprovalRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an approval request for a feature flag.
     * @summary Delete approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public deleteApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).deleteApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single approval request for a feature flag.
     * @summary Get approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalForFlag(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an approval request by approval request ID.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
     * @summary Get approval request
     * @param {string} id The approval request ID
     * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalRequest(id: string, expand?: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalRequest(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all approval requests.  ### Filtering approvals  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `notifyMemberIds` filters for only approvals that are assigned to a member in the specified list. For example: `filter=notifyMemberIds anyOf [\"memberId1\", \"memberId2\"]`. - `requestorId` filters for only approvals that correspond to the ID of the member who requested the approval. For example: `filter=requestorId equals 457034721476302714390214`. - `resourceId` filters for only approvals that correspond to the the specified resource identifier. For example: `filter=resourceId equals proj/my-project:env/my-environment:flag/my-flag`. - `reviewStatus` filters for only approvals which correspond to the review status in the specified list. The possible values are `approved`, `declined`, and `pending`. For example: `filter=reviewStatus anyOf [\"pending\", \"approved\"]`. - `status` filters for only approvals which correspond to the status in the specified list. The possible values are `pending`, `scheduled`, `failed`, and `completed`. For example: `filter=status anyOf [\"pending\", \"scheduled\"]`.  You can also apply multiple filters at once. For example, setting `filter=projectKey equals my-project, reviewStatus anyOf [\"pending\",\"approved\"]` matches approval requests which correspond to the `my-project` project key, and a review status of either `pending` or `approved`.  ### Expanding approval response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `flag` includes the flag the approval request belongs to - `project` includes the project the approval request belongs to - `environments` includes the environments the approval request relates to  For example, `expand=project,flag` includes the `project` and `flag` fields in the response. 
     * @summary List approval requests
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
     * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
     * @param {number} [limit] The number of approvals to return. Defaults to 20. Maximum limit is 200.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalRequests(filter?: string, expand?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalRequests(filter, expand, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all approval requests for a feature flag.
     * @summary List approval requests for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public getApprovalsForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).getApprovalsForFlag(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an approval request.  This endpoint currently supports creating an approval request for a flag across all environments with the following instructions:  - `addVariation` - `removeVariation` - `updateVariation` - `updateDefaultVariation`  For details on using these instructions, read [Update feature flag](/tag/Feature-flags#operation/patchFeatureFlag).  To create an approval for a flag specific to an environment, use [Create approval request for a flag](/tag/Approvals#operation/postApprovalRequestForFlag). 
     * @summary Create approval request
     * @param {CreateApprovalRequestRequest} createApprovalRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequest(createApprovalRequestRequest: CreateApprovalRequestRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequest(createApprovalRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply an approval request that has been approved.
     * @summary Apply approval request
     * @param {string} id The feature flag approval request ID
     * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestApply(id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestApply(id, postApprovalRequestApplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply an approval request that has been approved.
     * @summary Apply approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {PostApprovalRequestApplyRequest} postApprovalRequestApplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestApplyForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestApplyRequest: PostApprovalRequestApplyRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestApplyForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestApplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an approval request for a feature flag.
     * @summary Create approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {CreateFlagConfigApprovalRequestRequest} createFlagConfigApprovalRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, createFlagConfigApprovalRequestRequest: CreateFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestForFlag(projectKey, featureFlagKey, environmentKey, createFlagConfigApprovalRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Review an approval request by approving or denying changes.
     * @summary Review approval request
     * @param {string} id The approval request ID
     * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestReview(id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestReview(id, postApprovalRequestReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Review an approval request by approving or denying changes.
     * @summary Review approval request for a flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The feature flag approval request ID
     * @param {PostApprovalRequestReviewRequest} postApprovalRequestReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postApprovalRequestReviewForFlag(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, postApprovalRequestReviewRequest: PostApprovalRequestReviewRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postApprovalRequestReviewForFlag(projectKey, featureFlagKey, environmentKey, id, postApprovalRequestReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an approval request to copy a feature flag\'s configuration across environments.
     * @summary Create approval request to copy flag configurations across environments
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key for the target environment
     * @param {CreateCopyFlagConfigApprovalRequestRequest} createCopyFlagConfigApprovalRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalsApi
     */
    public postFlagCopyConfigApprovalRequest(projectKey: string, featureFlagKey: string, environmentKey: string, createCopyFlagConfigApprovalRequestRequest: CreateCopyFlagConfigApprovalRequestRequest, options?: AxiosRequestConfig) {
        return ApprovalsApiFp(this.configuration).postFlagCopyConfigApprovalRequest(projectKey, featureFlagKey, environmentKey, createCopyFlagConfigApprovalRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditLogApi - axios parameter creator
 * @export
 */
export const AuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.  LaunchDarkly uses a resource specifier syntax to name resources or collections of resources. To learn more, read [Understanding the resource specifier syntax](https://docs.launchdarkly.com/home/members/role-resources#understanding-the-resource-specifier-syntax). 
         * @summary List audit log entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20. The default is 10.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries: async (before?: number, after?: number, q?: string, limit?: number, spec?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/auditlog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (spec !== undefined) {
                localVarQueryParameter['spec'] = spec;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAuditLogEntry', 'id', id)
            const localVarPath = `/api/v2/auditlog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogApi - functional programming interface
 * @export
 */
export const AuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.  LaunchDarkly uses a resource specifier syntax to name resources or collections of resources. To learn more, read [Understanding the resource specifier syntax](https://docs.launchdarkly.com/home/members/role-resources#understanding-the-resource-specifier-syntax). 
         * @summary List audit log entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20. The default is 10.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntryListingRepCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogEntries(before, after, q, limit, spec, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntry(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditLogApi - factory interface
 * @export
 */
export const AuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogApiFp(configuration)
    return {
        /**
         * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.  LaunchDarkly uses a resource specifier syntax to name resources or collections of resources. To learn more, read [Understanding the resource specifier syntax](https://docs.launchdarkly.com/home/members/role-resources#understanding-the-resource-specifier-syntax). 
         * @summary List audit log entries
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource.
         * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20. The default is 10.
         * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: any): AxiosPromise<AuditLogEntryListingRepCollection> {
            return localVarFp.getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
         * @summary Get audit log entry
         * @param {string} id The ID of the audit log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry(id: string, options?: any): AxiosPromise<AuditLogEntryRep> {
            return localVarFp.getAuditLogEntry(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export class AuditLogApi extends BaseAPI {
    /**
     * Get a list of all audit log entries. The query parameters let you restrict the results that return by date ranges, resource specifiers, or a full-text search query.  LaunchDarkly uses a resource specifier syntax to name resources or collections of resources. To learn more, read [Understanding the resource specifier syntax](https://docs.launchdarkly.com/home/members/role-resources#understanding-the-resource-specifier-syntax). 
     * @summary List audit log entries
     * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds.  All entries this returns occurred before the timestamp.
     * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries this returns occurred after the timestamp.
     * @param {string} [q] Text to search for. You can search for the full or partial name of the resource.
     * @param {number} [limit] A limit on the number of audit log entries that return. Set between 1 and 20. The default is 10.
     * @param {string} [spec] A resource specifier that lets you filter audit log listings by resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: AxiosRequestConfig) {
        return AuditLogApiFp(this.configuration).getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a detailed audit log entry representation. The detailed representation includes several fields that are not present in the summary representation, including:  - `delta`: the JSON patch body that was used in the request to update the entity - `previousVersion`: a JSON representation of the previous version of the entity - `currentVersion`: a JSON representation of the current version of the entity 
     * @summary Get audit log entry
     * @param {string} id The ID of the audit log entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntry(id: string, options?: AxiosRequestConfig) {
        return AuditLogApiFp(this.configuration).getAuditLogEntry(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CodeReferencesApi - axios parameter creator
 * @export
 */
export const CodeReferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranches: async (repo: string, requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('deleteBranches', 'repo', repo)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteBranches', 'requestBody', requestBody)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branch-delete-tasks`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('deleteRepository', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch: async (repo: string, branch: string, projKey?: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getBranch', 'branch', branch)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBranches', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtinctions: async (repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/extinctions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (repoName !== undefined) {
                localVarQueryParameter['repoName'] = repoName;
            }

            if (branchName !== undefined) {
                localVarQueryParameter['branchName'] = branchName;
            }

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories: async (withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withBranches !== undefined) {
                localVarQueryParameter['withBranches'] = withBranches;
            }

            if (withReferencesForDefaultBranch !== undefined) {
                localVarQueryParameter['withReferencesForDefaultBranch'] = withReferencesForDefaultBranch;
            }

            if (projKey !== undefined) {
                localVarQueryParameter['projKey'] = projKey;
            }

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getRepository', 'repo', repo)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootStatistic: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/code-refs/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (projectKey: string, flagKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getStatistics', 'projectKey', projectKey)
            const localVarPath = `/api/v2/code-refs/statistics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (flagKey !== undefined) {
                localVarQueryParameter['flagKey'] = flagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a repository\'s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepository: async (repo: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('patchRepository', 'repo', repo)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchRepository', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExtinction: async (repo: string, branch: string, extinction: Array<Extinction>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('postExtinction', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('postExtinction', 'branch', branch)
            // verify required parameter 'extinction' is not null or undefined
            assertParamExists('postExtinction', 'extinction', extinction)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}/extinction-events`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extinction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepository: async (repositoryPost: RepositoryPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryPost' is not null or undefined
            assertParamExists('postRepository', 'repositoryPost', repositoryPost)
            const localVarPath = `/api/v2/code-refs/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBranch: async (repo: string, branch: string, putBranch: PutBranch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('putBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('putBranch', 'branch', branch)
            // verify required parameter 'putBranch' is not null or undefined
            assertParamExists('putBranch', 'putBranch', putBranch)
            const localVarPath = `/api/v2/code-refs/repositories/{repo}/branches/{branch}`
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putBranch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CodeReferencesApi - functional programming interface
 * @export
 */
export const CodeReferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CodeReferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranches(repo: string, requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranches(repo, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranch(repo, branch, projKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranches(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranches(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtinctionCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtinctions(repoName, branchName, projKey, flagKey, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepository(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepository(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootStatistic(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsRoot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootStatistic(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(projectKey: string, flagKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(projectKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a repository\'s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepository(repo, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postExtinction(repo, branch, extinction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepository(repositoryPost: RepositoryPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepository(repositoryPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBranch(repo: string, branch: string, putBranch: PutBranch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBranch(repo, branch, putBranch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CodeReferencesApi - factory interface
 * @export
 */
export const CodeReferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CodeReferencesApiFp(configuration)
    return {
        /**
         * Asynchronously delete a number of branches.
         * @summary Delete branches
         * @param {string} repo The repository name to delete branches for.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranches(repo: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBranches(repo, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository with the specified name.
         * @summary Delete repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific branch in a repository.
         * @summary Get branch
         * @param {string} repo The repository name
         * @param {string} branch The url-encoded branch name
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: any): AxiosPromise<BranchRep> {
            return localVarFp.getBranch(repo, branch, projKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of branches.
         * @summary List branches
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches(repo: string, options?: any): AxiosPromise<BranchCollectionRep> {
            return localVarFp.getBranches(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
         * @summary List extinctions
         * @param {string} [repoName] Filter results to a specific repository
         * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
         * @param {string} [projKey] Filter results to a specific project
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
         * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: any): AxiosPromise<ExtinctionCollectionRep> {
            return localVarFp.getExtinctions(repoName, branchName, projKey, flagKey, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
         * @summary List repositories
         * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
         * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
         * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: any): AxiosPromise<RepositoryCollectionRep> {
            return localVarFp.getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single repository by name.
         * @summary Get repository
         * @param {string} repo The repository name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository(repo: string, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.getRepository(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get links for all projects that have code references.
         * @summary Get links to code reference repositories for each project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootStatistic(options?: any): AxiosPromise<StatisticsRoot> {
            return localVarFp.getRootStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
         * @summary Get code references statistics for flags
         * @param {string} projectKey The project key
         * @param {string} [flagKey] Filter results to a specific flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(projectKey: string, flagKey?: string, options?: any): AxiosPromise<StatisticCollectionRep> {
            return localVarFp.getStatistics(projectKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a repository\'s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update repository
         * @param {string} repo The repository name
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.patchRepository(repo, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new extinction.
         * @summary Create extinction
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {Array<Extinction>} extinction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: any): AxiosPromise<void> {
            return localVarFp.postExtinction(repo, branch, extinction, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a repository with the specified name.
         * @summary Create repository
         * @param {RepositoryPost} repositoryPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepository(repositoryPost: RepositoryPost, options?: any): AxiosPromise<RepositoryRep> {
            return localVarFp.postRepository(repositoryPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
         * @summary Upsert branch
         * @param {string} repo The repository name
         * @param {string} branch The URL-encoded branch name
         * @param {PutBranch} putBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBranch(repo: string, branch: string, putBranch: PutBranch, options?: any): AxiosPromise<void> {
            return localVarFp.putBranch(repo, branch, putBranch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CodeReferencesApi - object-oriented interface
 * @export
 * @class CodeReferencesApi
 * @extends {BaseAPI}
 */
export class CodeReferencesApi extends BaseAPI {
    /**
     * Asynchronously delete a number of branches.
     * @summary Delete branches
     * @param {string} repo The repository name to delete branches for.
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public deleteBranches(repo: string, requestBody: Array<string>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).deleteBranches(repo, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository with the specified name.
     * @summary Delete repository
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public deleteRepository(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).deleteRepository(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific branch in a repository.
     * @summary Get branch
     * @param {string} repo The repository name
     * @param {string} branch The url-encoded branch name
     * @param {string} [projKey] Filter results to a specific project
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getBranch(repo: string, branch: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getBranch(repo, branch, projKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of branches.
     * @summary List branches
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getBranches(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getBranches(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [Understanding extinction events](https://docs.launchdarkly.com/home/code/code-references#understanding-extinction-events).
     * @summary List extinctions
     * @param {string} [repoName] Filter results to a specific repository
     * @param {string} [branchName] Filter results to a specific branch. By default, only the default branch will be queried for extinctions.
     * @param {string} [projKey] Filter results to a specific project
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {number} [from] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;.
     * @param {number} [to] Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getExtinctions(repoName?: string, branchName?: string, projKey?: string, flagKey?: string, from?: number, to?: number, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getExtinctions(repoName, branchName, projKey, flagKey, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of connected repositories. Optionally, you can include branch metadata with the `withBranches` query parameter. Embed references for the default branch with `ReferencesForDefaultBranch`. You can also filter the list of code references by project key and flag key.
     * @summary List repositories
     * @param {string} [withBranches] If set to any value, the endpoint returns repositories with associated branch data
     * @param {string} [withReferencesForDefaultBranch] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
     * @param {string} [projKey] A LaunchDarkly project key. If provided, this filters code reference results to the specified project.
     * @param {string} [flagKey] If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRepositories(withBranches?: string, withReferencesForDefaultBranch?: string, projKey?: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRepositories(withBranches, withReferencesForDefaultBranch, projKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single repository by name.
     * @summary Get repository
     * @param {string} repo The repository name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRepository(repo: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRepository(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get links for all projects that have code references.
     * @summary Get links to code reference repositories for each project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getRootStatistic(options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getRootStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, `main`. Optionally, you can include the `flagKey` query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
     * @summary Get code references statistics for flags
     * @param {string} projectKey The project key
     * @param {string} [flagKey] Filter results to a specific flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public getStatistics(projectKey: string, flagKey?: string, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).getStatistics(projectKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a repository\'s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update repository
     * @param {string} repo The repository name
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public patchRepository(repo: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).patchRepository(repo, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new extinction.
     * @summary Create extinction
     * @param {string} repo The repository name
     * @param {string} branch The URL-encoded branch name
     * @param {Array<Extinction>} extinction 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public postExtinction(repo: string, branch: string, extinction: Array<Extinction>, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).postExtinction(repo, branch, extinction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a repository with the specified name.
     * @summary Create repository
     * @param {RepositoryPost} repositoryPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public postRepository(repositoryPost: RepositoryPost, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).postRepository(repositoryPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new branch if it doesn\'t exist, or update the branch if it already exists.
     * @summary Upsert branch
     * @param {string} repo The repository name
     * @param {string} branch The URL-encoded branch name
     * @param {PutBranch} putBranch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CodeReferencesApi
     */
    public putBranch(repo: string, branch: string, putBranch: PutBranch, options?: AxiosRequestConfig) {
        return CodeReferencesApiFp(this.configuration).putBranch(repo, branch, putBranch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContextSettingsApi - axios parameter creator
 * @export
 */
export const ContextSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a context.  If you previously patched the flag, and the patch included the context\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context\'s key and kind before, it calculates the flag values based on the context kind and key. 
         * @summary Update flag settings for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} contextKind The context kind
         * @param {string} contextKey The context key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putContextFlagSetting: async (projectKey: string, environmentKey: string, contextKind: string, contextKey: string, featureFlagKey: string, valuePut: ValuePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putContextFlagSetting', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('putContextFlagSetting', 'environmentKey', environmentKey)
            // verify required parameter 'contextKind' is not null or undefined
            assertParamExists('putContextFlagSetting', 'contextKind', contextKind)
            // verify required parameter 'contextKey' is not null or undefined
            assertParamExists('putContextFlagSetting', 'contextKey', contextKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('putContextFlagSetting', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'valuePut' is not null or undefined
            assertParamExists('putContextFlagSetting', 'valuePut', valuePut)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{contextKind}/{contextKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"contextKind"}}`, encodeURIComponent(String(contextKind)))
                .replace(`{${"contextKey"}}`, encodeURIComponent(String(contextKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextSettingsApi - functional programming interface
 * @export
 */
export const ContextSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a context.  If you previously patched the flag, and the patch included the context\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context\'s key and kind before, it calculates the flag values based on the context kind and key. 
         * @summary Update flag settings for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} contextKind The context kind
         * @param {string} contextKey The context key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putContextFlagSetting(projectKey: string, environmentKey: string, contextKind: string, contextKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putContextFlagSetting(projectKey, environmentKey, contextKind, contextKey, featureFlagKey, valuePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContextSettingsApi - factory interface
 * @export
 */
export const ContextSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextSettingsApiFp(configuration)
    return {
        /**
         *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a context.  If you previously patched the flag, and the patch included the context\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context\'s key and kind before, it calculates the flag values based on the context kind and key. 
         * @summary Update flag settings for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} contextKind The context kind
         * @param {string} contextKey The context key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putContextFlagSetting(projectKey: string, environmentKey: string, contextKind: string, contextKey: string, featureFlagKey: string, valuePut: ValuePut, options?: any): AxiosPromise<void> {
            return localVarFp.putContextFlagSetting(projectKey, environmentKey, contextKind, contextKey, featureFlagKey, valuePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextSettingsApi - object-oriented interface
 * @export
 * @class ContextSettingsApi
 * @extends {BaseAPI}
 */
export class ContextSettingsApi extends BaseAPI {
    /**
     *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a context.  If you previously patched the flag, and the patch included the context\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context\'s key and kind before, it calculates the flag values based on the context kind and key. 
     * @summary Update flag settings for context
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} contextKind The context kind
     * @param {string} contextKey The context key
     * @param {string} featureFlagKey The feature flag key
     * @param {ValuePut} valuePut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextSettingsApi
     */
    public putContextFlagSetting(projectKey: string, environmentKey: string, contextKind: string, contextKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig) {
        return ContextSettingsApiFp(this.configuration).putContextFlagSetting(projectKey, environmentKey, contextKind, contextKey, featureFlagKey, valuePut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContextsApi - axios parameter creator
 * @export
 */
export const ContextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete context instances by ID.
         * @summary Delete context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContextInstances: async (projectKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteContextInstances', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteContextInstances', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContextInstances', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evaluate flags for a context instance, for example, to determine the expected flag variation. **Do not use this API instead of an SDK.** The LaunchDarkly SDKs are specialized for the tasks of evaluating feature flags in your application at scale and generating analytics events based on those evaluations. This API is not designed for that use case. Any evaluations you perform with this API will not be reflected in features such as flag statuses and flag insights. Context instances evaluated by this API will not appear in the Contexts list. To learn more, read [Comparing LaunchDarkly\'s SDKs and REST API](https://docs.launchdarkly.com/guide/api/comparing-sdk-rest-api).  ### Filtering   LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `query` filters for a string that matches against the flags\' keys and names. It is not case sensitive. For example: `filter=query equals dark-mode`. - `tags` filters the list to flags that have all of the tags in the list. For example: `filter=tags contains [\"beta\",\"q1\"]`.  You can also apply multiple filters at once. For example, setting `filter=query equals dark-mode, tags contains [\"beta\",\"q1\"]` matches flags which match the key or name `dark-mode` and are tagged `beta` and `q1`. 
         * @summary Evaluate flags for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateContextInstance: async (projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, limit?: number, offset?: number, sort?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('evaluateContextInstance', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('evaluateContextInstance', 'environmentKey', environmentKey)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('evaluateContextInstance', 'requestBody', requestBody)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/flags/evaluate`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get context attribute names. Returns only the first 100 attribute names per context.
         * @summary Get context attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;name&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextAttributeNames: async (projectKey: string, environmentKey: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContextAttributeNames', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getContextAttributeNames', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get context attribute values.
         * @summary Get context attribute values
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} attributeName The attribute name
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;value&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextAttributeValues: async (projectKey: string, environmentKey: string, attributeName: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContextAttributeValues', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getContextAttributeValues', 'environmentKey', environmentKey)
            // verify required parameter 'attributeName' is not null or undefined
            assertParamExists('getContextAttributeValues', 'attributeName', attributeName)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/context-attributes/{attributeName}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"attributeName"}}`, encodeURIComponent(String(attributeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get context instances by ID.
         * @summary Get context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {number} [limit] Specifies the maximum number of context instances to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextInstances: async (projectKey: string, environmentKey: string, id: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContextInstances', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getContextInstances', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContextInstances', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (includeTotalCount !== undefined) {
                localVarQueryParameter['includeTotalCount'] = includeTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all context kinds for a given project.
         * @summary Get context kinds
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextKindsByProjectKey: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContextKindsByProjectKey', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/context-kinds`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contexts based on kind and key.
         * @summary Get contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} kind The context kind
         * @param {string} key The context key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContexts: async (projectKey: string, environmentKey: string, kind: string, key: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContexts', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getContexts', 'environmentKey', environmentKey)
            // verify required parameter 'kind' is not null or undefined
            assertParamExists('getContexts', 'kind', kind)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getContexts', 'key', key)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{kind}/{key}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (includeTotalCount !== undefined) {
                localVarQueryParameter['includeTotalCount'] = includeTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a context kind by key. Only the included fields will be updated.
         * @summary Create or update context kind
         * @param {string} projectKey The project key
         * @param {string} key The context kind key
         * @param {UpsertContextKindPayload} upsertContextKindPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putContextKind: async (projectKey: string, key: string, upsertContextKindPayload: UpsertContextKindPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putContextKind', 'projectKey', projectKey)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('putContextKind', 'key', key)
            // verify required parameter 'upsertContextKindPayload' is not null or undefined
            assertParamExists('putContextKind', 'upsertContextKindPayload', upsertContextKindPayload)
            const localVarPath = `/api/v2/projects/{projectKey}/context-kinds/{key}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertContextKindPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Search for context instances.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about context instances, read [Understanding context instances](https://docs.launchdarkly.com/home/contexts#understanding-context-instances). 
         * @summary Search for context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextInstanceSearch} contextInstanceSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchContextInstances: async (projectKey: string, environmentKey: string, contextInstanceSearch: ContextInstanceSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('searchContextInstances', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('searchContextInstances', 'environmentKey', environmentKey)
            // verify required parameter 'contextInstanceSearch' is not null or undefined
            assertParamExists('searchContextInstances', 'contextInstanceSearch', contextInstanceSearch)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/context-instances/search`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (includeTotalCount !== undefined) {
                localVarQueryParameter['includeTotalCount'] = includeTotalCount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextInstanceSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Search for contexts.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about contexts, read [Understanding contexts and context kinds](https://docs.launchdarkly.com/home/contexts#understanding-contexts-and-context-kinds). 
         * @summary Search for contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextSearch} contextSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchContexts: async (projectKey: string, environmentKey: string, contextSearch: ContextSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('searchContexts', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('searchContexts', 'environmentKey', environmentKey)
            // verify required parameter 'contextSearch' is not null or undefined
            assertParamExists('searchContexts', 'contextSearch', contextSearch)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/search`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuationToken'] = continuationToken;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (includeTotalCount !== undefined) {
                localVarQueryParameter['includeTotalCount'] = includeTotalCount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContextsApi - functional programming interface
 * @export
 */
export const ContextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContextsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete context instances by ID.
         * @summary Delete context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContextInstances(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContextInstances(projectKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Evaluate flags for a context instance, for example, to determine the expected flag variation. **Do not use this API instead of an SDK.** The LaunchDarkly SDKs are specialized for the tasks of evaluating feature flags in your application at scale and generating analytics events based on those evaluations. This API is not designed for that use case. Any evaluations you perform with this API will not be reflected in features such as flag statuses and flag insights. Context instances evaluated by this API will not appear in the Contexts list. To learn more, read [Comparing LaunchDarkly\'s SDKs and REST API](https://docs.launchdarkly.com/guide/api/comparing-sdk-rest-api).  ### Filtering   LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `query` filters for a string that matches against the flags\' keys and names. It is not case sensitive. For example: `filter=query equals dark-mode`. - `tags` filters the list to flags that have all of the tags in the list. For example: `filter=tags contains [\"beta\",\"q1\"]`.  You can also apply multiple filters at once. For example, setting `filter=query equals dark-mode, tags contains [\"beta\",\"q1\"]` matches flags which match the key or name `dark-mode` and are tagged `beta` and `q1`. 
         * @summary Evaluate flags for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateContextInstance(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, limit?: number, offset?: number, sort?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextInstanceEvaluations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateContextInstance(projectKey, environmentKey, requestBody, limit, offset, sort, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get context attribute names. Returns only the first 100 attribute names per context.
         * @summary Get context attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;name&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextAttributeNames(projectKey: string, environmentKey: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextAttributeNamesCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextAttributeNames(projectKey, environmentKey, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get context attribute values.
         * @summary Get context attribute values
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} attributeName The attribute name
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;value&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextAttributeValues(projectKey: string, environmentKey: string, attributeName: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextAttributeValuesCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextAttributeValues(projectKey, environmentKey, attributeName, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get context instances by ID.
         * @summary Get context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {number} [limit] Specifies the maximum number of context instances to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextInstances(projectKey: string, environmentKey: string, id: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextInstances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextInstances(projectKey, environmentKey, id, limit, continuationToken, sort, filter, includeTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all context kinds for a given project.
         * @summary Get context kinds
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextKindsByProjectKey(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextKindsCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextKindsByProjectKey(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get contexts based on kind and key.
         * @summary Get contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} kind The context kind
         * @param {string} key The context key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContexts(projectKey: string, environmentKey: string, kind: string, key: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contexts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContexts(projectKey, environmentKey, kind, key, limit, continuationToken, sort, filter, includeTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update a context kind by key. Only the included fields will be updated.
         * @summary Create or update context kind
         * @param {string} projectKey The project key
         * @param {string} key The context kind key
         * @param {UpsertContextKindPayload} upsertContextKindPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putContextKind(projectKey: string, key: string, upsertContextKindPayload: UpsertContextKindPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertResponseRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putContextKind(projectKey, key, upsertContextKindPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Search for context instances.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about context instances, read [Understanding context instances](https://docs.launchdarkly.com/home/contexts#understanding-context-instances). 
         * @summary Search for context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextInstanceSearch} contextInstanceSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchContextInstances(projectKey: string, environmentKey: string, contextInstanceSearch: ContextInstanceSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextInstances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchContextInstances(projectKey, environmentKey, contextInstanceSearch, limit, continuationToken, sort, filter, includeTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Search for contexts.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about contexts, read [Understanding contexts and context kinds](https://docs.launchdarkly.com/home/contexts#understanding-contexts-and-context-kinds). 
         * @summary Search for contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextSearch} contextSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchContexts(projectKey: string, environmentKey: string, contextSearch: ContextSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contexts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchContexts(projectKey, environmentKey, contextSearch, limit, continuationToken, sort, filter, includeTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContextsApi - factory interface
 * @export
 */
export const ContextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContextsApiFp(configuration)
    return {
        /**
         * Delete context instances by ID.
         * @summary Delete context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContextInstances(projectKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContextInstances(projectKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Evaluate flags for a context instance, for example, to determine the expected flag variation. **Do not use this API instead of an SDK.** The LaunchDarkly SDKs are specialized for the tasks of evaluating feature flags in your application at scale and generating analytics events based on those evaluations. This API is not designed for that use case. Any evaluations you perform with this API will not be reflected in features such as flag statuses and flag insights. Context instances evaluated by this API will not appear in the Contexts list. To learn more, read [Comparing LaunchDarkly\'s SDKs and REST API](https://docs.launchdarkly.com/guide/api/comparing-sdk-rest-api).  ### Filtering   LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `query` filters for a string that matches against the flags\' keys and names. It is not case sensitive. For example: `filter=query equals dark-mode`. - `tags` filters the list to flags that have all of the tags in the list. For example: `filter=tags contains [\"beta\",\"q1\"]`.  You can also apply multiple filters at once. For example, setting `filter=query equals dark-mode, tags contains [\"beta\",\"q1\"]` matches flags which match the key or name `dark-mode` and are tagged `beta` and `q1`. 
         * @summary Evaluate flags for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateContextInstance(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, limit?: number, offset?: number, sort?: string, filter?: string, options?: any): AxiosPromise<ContextInstanceEvaluations> {
            return localVarFp.evaluateContextInstance(projectKey, environmentKey, requestBody, limit, offset, sort, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get context attribute names. Returns only the first 100 attribute names per context.
         * @summary Get context attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;name&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextAttributeNames(projectKey: string, environmentKey: string, filter?: string, options?: any): AxiosPromise<ContextAttributeNamesCollection> {
            return localVarFp.getContextAttributeNames(projectKey, environmentKey, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get context attribute values.
         * @summary Get context attribute values
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} attributeName The attribute name
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;value&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextAttributeValues(projectKey: string, environmentKey: string, attributeName: string, filter?: string, options?: any): AxiosPromise<ContextAttributeValuesCollection> {
            return localVarFp.getContextAttributeValues(projectKey, environmentKey, attributeName, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get context instances by ID.
         * @summary Get context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The context instance ID
         * @param {number} [limit] Specifies the maximum number of context instances to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextInstances(projectKey: string, environmentKey: string, id: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: any): AxiosPromise<ContextInstances> {
            return localVarFp.getContextInstances(projectKey, environmentKey, id, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all context kinds for a given project.
         * @summary Get context kinds
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextKindsByProjectKey(projectKey: string, options?: any): AxiosPromise<ContextKindsCollectionRep> {
            return localVarFp.getContextKindsByProjectKey(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contexts based on kind and key.
         * @summary Get contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} kind The context kind
         * @param {string} key The context key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContexts(projectKey: string, environmentKey: string, kind: string, key: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: any): AxiosPromise<Contexts> {
            return localVarFp.getContexts(projectKey, environmentKey, kind, key, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a context kind by key. Only the included fields will be updated.
         * @summary Create or update context kind
         * @param {string} projectKey The project key
         * @param {string} key The context kind key
         * @param {UpsertContextKindPayload} upsertContextKindPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putContextKind(projectKey: string, key: string, upsertContextKindPayload: UpsertContextKindPayload, options?: any): AxiosPromise<UpsertResponseRep> {
            return localVarFp.putContextKind(projectKey, key, upsertContextKindPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *  Search for context instances.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about context instances, read [Understanding context instances](https://docs.launchdarkly.com/home/contexts#understanding-context-instances). 
         * @summary Search for context instances
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextInstanceSearch} contextInstanceSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchContextInstances(projectKey: string, environmentKey: string, contextInstanceSearch: ContextInstanceSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: any): AxiosPromise<ContextInstances> {
            return localVarFp.searchContextInstances(projectKey, environmentKey, contextInstanceSearch, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         *  Search for contexts.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about contexts, read [Understanding contexts and context kinds](https://docs.launchdarkly.com/home/contexts#understanding-contexts-and-context-kinds). 
         * @summary Search for contexts
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ContextSearch} contextSearch 
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
         * @param {string} [filter] A comma-separated list of context filters. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
         * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchContexts(projectKey: string, environmentKey: string, contextSearch: ContextSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: any): AxiosPromise<Contexts> {
            return localVarFp.searchContexts(projectKey, environmentKey, contextSearch, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContextsApi - object-oriented interface
 * @export
 * @class ContextsApi
 * @extends {BaseAPI}
 */
export class ContextsApi extends BaseAPI {
    /**
     * Delete context instances by ID.
     * @summary Delete context instances
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The context instance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public deleteContextInstances(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).deleteContextInstances(projectKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Evaluate flags for a context instance, for example, to determine the expected flag variation. **Do not use this API instead of an SDK.** The LaunchDarkly SDKs are specialized for the tasks of evaluating feature flags in your application at scale and generating analytics events based on those evaluations. This API is not designed for that use case. Any evaluations you perform with this API will not be reflected in features such as flag statuses and flag insights. Context instances evaluated by this API will not appear in the Contexts list. To learn more, read [Comparing LaunchDarkly\'s SDKs and REST API](https://docs.launchdarkly.com/guide/api/comparing-sdk-rest-api).  ### Filtering   LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `query` filters for a string that matches against the flags\' keys and names. It is not case sensitive. For example: `filter=query equals dark-mode`. - `tags` filters the list to flags that have all of the tags in the list. For example: `filter=tags contains [\"beta\",\"q1\"]`.  You can also apply multiple filters at once. For example, setting `filter=query equals dark-mode, tags contains [\"beta\",\"q1\"]` matches flags which match the key or name `dark-mode` and are tagged `beta` and `q1`. 
     * @summary Evaluate flags for context instance
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {{ [key: string]: any; }} requestBody 
     * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field operator value&#x60;. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public evaluateContextInstance(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, limit?: number, offset?: number, sort?: string, filter?: string, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).evaluateContextInstance(projectKey, environmentKey, requestBody, limit, offset, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get context attribute names. Returns only the first 100 attribute names per context.
     * @summary Get context attribute names
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;name&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public getContextAttributeNames(projectKey: string, environmentKey: string, filter?: string, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).getContextAttributeNames(projectKey, environmentKey, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get context attribute values.
     * @summary Get context attribute values
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} attributeName The attribute name
     * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts &#x60;kind&#x60; filters, with the &#x60;equals&#x60; operator, and &#x60;value&#x60; filters, with the &#x60;startsWith&#x60; operator. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public getContextAttributeValues(projectKey: string, environmentKey: string, attributeName: string, filter?: string, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).getContextAttributeValues(projectKey, environmentKey, attributeName, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get context instances by ID.
     * @summary Get context instances
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The context instance ID
     * @param {number} [limit] Specifies the maximum number of context instances to return (max: 50, default: 20)
     * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
     * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public getContextInstances(projectKey: string, environmentKey: string, id: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).getContextInstances(projectKey, environmentKey, id, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all context kinds for a given project.
     * @summary Get context kinds
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public getContextKindsByProjectKey(projectKey: string, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).getContextKindsByProjectKey(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contexts based on kind and key.
     * @summary Get contexts
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} kind The context kind
     * @param {string} key The context key
     * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
     * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public getContexts(projectKey: string, environmentKey: string, kind: string, key: string, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).getContexts(projectKey, environmentKey, kind, key, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a context kind by key. Only the included fields will be updated.
     * @summary Create or update context kind
     * @param {string} projectKey The project key
     * @param {string} key The context kind key
     * @param {UpsertContextKindPayload} upsertContextKindPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public putContextKind(projectKey: string, key: string, upsertContextKindPayload: UpsertContextKindPayload, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).putContextKind(projectKey, key, upsertContextKindPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Search for context instances.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about context instances, read [Understanding context instances](https://docs.launchdarkly.com/home/contexts#understanding-context-instances). 
     * @summary Search for context instances
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {ContextInstanceSearch} contextInstanceSearch 
     * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @param {string} [continuationToken] Limits results to context instances with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
     * @param {string} [filter] A comma-separated list of context filters. This endpoint only accepts an &#x60;applicationId&#x60; filter. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching context instances. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public searchContextInstances(projectKey: string, environmentKey: string, contextInstanceSearch: ContextInstanceSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).searchContextInstances(projectKey, environmentKey, contextInstanceSearch, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Search for contexts.  You can use either the query parameters or the request body parameters. If both are provided, there is an error.  To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances). To learn more about contexts, read [Understanding contexts and context kinds](https://docs.launchdarkly.com/home/contexts#understanding-contexts-and-context-kinds). 
     * @summary Search for contexts
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {ContextSearch} contextSearch 
     * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @param {string} [continuationToken] Limits results to contexts with sort values after the value specified. You can use this for pagination, however, we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports sorting by timestamp in ascending order by specifying &#x60;ts&#x60; for this value, or descending order by specifying &#x60;-ts&#x60;.
     * @param {string} [filter] A comma-separated list of context filters. To learn more about the filter syntax, read [Filtering contexts and context instances](/tag/Contexts#filtering-contexts-and-context-instances).
     * @param {boolean} [includeTotalCount] Specifies whether to include or omit the total count of matching contexts. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextsApi
     */
    public searchContexts(projectKey: string, environmentKey: string, contextSearch: ContextSearch, limit?: number, continuationToken?: string, sort?: string, filter?: string, includeTotalCount?: boolean, options?: AxiosRequestConfig) {
        return ContextsApiFp(this.configuration).searchContexts(projectKey, environmentKey, contextSearch, limit, continuationToken, sort, filter, includeTotalCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomRolesApi - axios parameter creator
 * @export
 */
export const CustomRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole: async (customRoleKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('deleteCustomRole', 'customRoleKey', customRoleKey)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole: async (customRoleKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('getCustomRole', 'customRoleKey', customRoleKey)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole: async (customRoleKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            assertParamExists('patchCustomRole', 'customRoleKey', customRoleKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchCustomRole', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole: async (customRolePost: CustomRolePost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRolePost' is not null or undefined
            assertParamExists('postCustomRole', 'customRolePost', customRolePost)
            const localVarPath = `/api/v2/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customRolePost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomRolesApi - functional programming interface
 * @export
 */
export const CustomRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomRole(customRoleKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomRole(customRoleKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRole(customRoleKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomRole(customRoleKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCustomRole(customRoleKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomRole(customRolePost: CustomRolePost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomRole(customRolePost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomRolesApi - factory interface
 * @export
 */
export const CustomRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomRolesApiFp(configuration)
    return {
        /**
         * Delete a custom role by key
         * @summary Delete custom role
         * @param {string} customRoleKey The custom role key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole(customRoleKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single custom role by key or ID
         * @summary Get custom role
         * @param {string} customRoleKey The custom role key or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole(customRoleKey: string, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.getCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
         * @summary List custom roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles(options?: any): AxiosPromise<CustomRoles> {
            return localVarFp.getCustomRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update custom role
         * @param {string} customRoleKey The custom role key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.patchCustomRole(customRoleKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new custom role
         * @summary Create custom role
         * @param {CustomRolePost} customRolePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole(customRolePost: CustomRolePost, options?: any): AxiosPromise<CustomRole> {
            return localVarFp.postCustomRole(customRolePost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomRolesApi - object-oriented interface
 * @export
 * @class CustomRolesApi
 * @extends {BaseAPI}
 */
export class CustomRolesApi extends BaseAPI {
    /**
     * Delete a custom role by key
     * @summary Delete custom role
     * @param {string} customRoleKey The custom role key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public deleteCustomRole(customRoleKey: string, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).deleteCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single custom role by key or ID
     * @summary Get custom role
     * @param {string} customRoleKey The custom role key or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRole(customRoleKey: string, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).getCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it\'s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you\'re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
     * @summary List custom roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRoles(options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).getCustomRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the `policy` array, set the `path` to `/policy` and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
     * @summary Update custom role
     * @param {string} customRoleKey The custom role key
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public patchCustomRole(customRoleKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).patchCustomRole(customRoleKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new custom role
     * @summary Create custom role
     * @param {CustomRolePost} customRolePost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public postCustomRole(customRolePost: CustomRolePost, options?: AxiosRequestConfig) {
        return CustomRolesApiFp(this.configuration).postCustomRole(customRolePost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataExportDestinationsApi - axios parameter creator
 * @export
 */
export const DataExportDestinationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination: async (projectKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDestination', 'id', id)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination: async (projectKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDestination', 'id', id)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Data Export destination. Updating a destination uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination: async (projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchDestination', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchDestination', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchDestination', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your end users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous end users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination: async (projectKey: string, environmentKey: string, destinationPost: DestinationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postDestination', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postDestination', 'environmentKey', environmentKey)
            // verify required parameter 'destinationPost' is not null or undefined
            assertParamExists('postDestination', 'destinationPost', destinationPost)
            const localVarPath = `/api/v2/destinations/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExportDestinationsApi - functional programming interface
 * @export
 */
export const DataExportDestinationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataExportDestinationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDestination(projectKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestination(projectKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destinations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDestinations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Data Export destination. Updating a destination uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchDestination(projectKey, environmentKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your end users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous end users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDestination(projectKey, environmentKey, destinationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataExportDestinationsApi - factory interface
 * @export
 */
export const DataExportDestinationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataExportDestinationsApiFp(configuration)
    return {
        /**
         * Delete a Data Export destination by ID.
         * @summary Delete Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(projectKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDestination(projectKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Data Export destination by ID.
         * @summary Get destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination(projectKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<Destination> {
            return localVarFp.getDestination(projectKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Data Export destinations configured across all projects and environments.
         * @summary List destinations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options?: any): AxiosPromise<Destinations> {
            return localVarFp.getDestinations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Data Export destination. Updating a destination uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} id The Data Export destination ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Destination> {
            return localVarFp.patchDestination(projectKey, environmentKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your end users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous end users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
         * @summary Create Data Export destination
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {DestinationPost} destinationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: any): AxiosPromise<Destination> {
            return localVarFp.postDestination(projectKey, environmentKey, destinationPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataExportDestinationsApi - object-oriented interface
 * @export
 * @class DataExportDestinationsApi
 * @extends {BaseAPI}
 */
export class DataExportDestinationsApi extends BaseAPI {
    /**
     * Delete a Data Export destination by ID.
     * @summary Delete Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public deleteDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).deleteDestination(projectKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Data Export destination by ID.
     * @summary Get destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestination(projectKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).getDestination(projectKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Data Export destinations configured across all projects and environments.
     * @summary List destinations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestinations(options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).getDestinations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Data Export destination. Updating a destination uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} id The Data Export destination ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public patchDestination(projectKey: string, environmentKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).patchDestination(projectKey, environmentKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new Data Export destination.  In the `config` request body parameter, the fields required depend on the type of Data Export destination.  <details> <summary>Click to expand <code>config</code> parameter details</summary>  #### Azure Event Hubs  To create a Data Export destination with a `kind` of `azure-event-hubs`, the `config` object requires the following fields:  * `namespace`: The Event Hub Namespace name * `name`: The Event Hub name * `policyName`: The shared access signature policy name. You can find your policy name in the settings of your Azure Event Hubs Namespace. * `policyKey`: The shared access signature key. You can find your policy key in the settings of your Azure Event Hubs Namespace.  #### Google Cloud Pub/Sub  To create a Data Export destination with a `kind` of `google-pubsub`, the `config` object requires the following fields:  * `project`: The Google PubSub project ID for the project to publish to * `topic`: The Google PubSub topic ID for the topic to publish to  #### Amazon Kinesis  To create a Data Export destination with a `kind` of `kinesis`, the `config` object requires the following fields:  * `region`: The Kinesis stream\'s AWS region key * `roleArn`: The Amazon Resource Name (ARN) of the AWS role that will be writing to Kinesis * `streamName`: The name of the Kinesis stream that LaunchDarkly is sending events to. This is not the ARN of the stream.  #### mParticle  To create a Data Export destination with a `kind` of `mparticle`, the `config` object requires the following fields:  * `apiKey`: The mParticle API key * `secret`: The mParticle API secret * `userIdentity`: The type of identifier you use to identify your end users in mParticle * `anonymousUserIdentity`: The type of identifier you use to identify your anonymous end users in mParticle  #### Segment  To create a Data Export destination with a `kind` of `segment`, the `config` object requires the following fields:  * `writeKey`: The Segment write key. This is used to authenticate LaunchDarkly\'s calls to Segment.  </details> 
     * @summary Create Data Export destination
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {DestinationPost} destinationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public postDestination(projectKey: string, environmentKey: string, destinationPost: DestinationPost, options?: AxiosRequestConfig) {
        return DataExportDestinationsApiFp(this.configuration).postDestination(projectKey, environmentKey, destinationPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting environments  LaunchDarkly supports the following fields for sorting:  - `createdOn` sorts by the creation date of the environment. - `critical` sorts by whether the environments are marked as critical. - `name` sorts by environment name.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsByProject: async (projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getEnvironmentsByProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update an environment. Updating an environment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment: async (projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchEnvironment', 'environmentKey', environmentKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchEnvironment', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment: async (projectKey: string, environmentPost: EnvironmentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentPost' is not null or undefined
            assertParamExists('postEnvironment', 'environmentPost', environmentPost)
            const localVarPath = `/api/v2/projects/{projectKey}/environments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('resetEnvironmentMobileKey', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('resetEnvironmentMobileKey', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/mobileKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately. During the period between this call and the time when the old SDK key expires, both the old SDK key and the new SDK key will work.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey: async (projectKey: string, environmentKey: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('resetEnvironmentSDKKey', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('resetEnvironmentSDKKey', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/apiKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting environments  LaunchDarkly supports the following fields for sorting:  - `createdOn` sorts by the creation date of the environment. - `critical` sorts by whether the environments are marked as critical. - `name` sorts by environment name.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update an environment. Updating an environment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEnvironment(projectKey, environmentKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEnvironment(projectKey, environmentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetEnvironmentMobileKey(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately. During the period between this call and the time when the old SDK key expires, both the old SDK key and the new SDK key will work.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * Delete a environment by key.
         * @summary Delete environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
         * @summary Get environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.getEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting environments  LaunchDarkly supports the following fields for sorting:  - `createdOn` sorts by the creation date of the environment. - `critical` sorts by whether the environments are marked as critical. - `name` sorts by environment name.  For example, `sort=name` sorts the response by environment name in ascending order. 
         * @summary List environments
         * @param {string} projectKey The project key
         * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: any): AxiosPromise<Environments> {
            return localVarFp.getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update an environment. Updating an environment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
         * @summary Update environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Environment> {
            return localVarFp.patchEnvironment(projectKey, environmentKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
         * @summary Create environment
         * @param {string} projectKey The project key
         * @param {EnvironmentPost} environmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: any): AxiosPromise<Environment> {
            return localVarFp.postEnvironment(projectKey, environmentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @summary Reset environment mobile SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: any): AxiosPromise<Environment> {
            return localVarFp.resetEnvironmentMobileKey(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @summary Reset environment SDK key
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately. During the period between this call and the time when the old SDK key expires, both the old SDK key and the new SDK key will work.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): AxiosPromise<Environment> {
            return localVarFp.resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * Delete a environment by key.
     * @summary Delete environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public deleteEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).deleteEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled.  Get an environment given a project and key. 
     * @summary Get environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of environments for the specified project.  By default, this returns the first 20 environments. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering environments  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the environments\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of environment tags. It filters the list of environments that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches environments with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting environments  LaunchDarkly supports the following fields for sorting:  - `createdOn` sorts by the creation date of the environment. - `critical` sorts by whether the environments are marked as critical. - `name` sorts by environment name.  For example, `sort=name` sorts the response by environment name in ascending order. 
     * @summary List environments
     * @param {string} projectKey The project key
     * @param {number} [limit] The number of environments to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironmentsByProject(projectKey: string, limit?: number, offset?: number, filter?: string, sort?: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).getEnvironmentsByProject(projectKey, limit, offset, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update an environment. Updating an environment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).  To update fields in the environment object that are arrays, set the `path` to the name of the field and then append `/<array index>`. Using `/0` appends to the beginning of the array.  ### Approval settings  This request only returns the `approvalSettings` key if the [Flag Approvals](https://docs.launchdarkly.com/home/feature-workflows/approvals) feature is enabled.  Only the `canReviewOwnRequest`, `canApplyDeclinedChanges`, `minNumApprovals`, `required` and `requiredApprovalTagsfields` are editable.  If you try to patch the environment by setting both `required` and `requiredApprovalTags`, the request fails and an error appears. You can specify either required approvals for all flags in an environment or those with specific tags, but not both. 
     * @summary Update environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public patchEnvironment(projectKey: string, environmentKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).patchEnvironment(projectKey, environmentKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Approval settings > > The `approvalSettings` key is only returned when the Flag Approvals feature is enabled. > > You cannot update approval settings when creating new environments. Update approval settings with the PATCH Environment API.  Create a new environment in a specified project with a given name, key, swatch color, and default TTL. 
     * @summary Create environment
     * @param {string} projectKey The project key
     * @param {EnvironmentPost} environmentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public postEnvironment(projectKey: string, environmentPost: EnvironmentPost, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).postEnvironment(projectKey, environmentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
     * @summary Reset environment mobile SDK key
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentMobileKey(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentMobileKey(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset an environment\'s SDK key with an optional expiry time for the old key.
     * @summary Reset environment SDK key
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [expiry] The time at which you want the old SDK key to expire, in UNIX milliseconds. By default, the key expires immediately. During the period between this call and the time when the old SDK key expires, both the old SDK key and the new SDK key will work.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: AxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExperimentsBetaApi - axios parameter creator
 * @export
 */
export const ExperimentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an experiment.  To run this experiment, you\'ll need to [create an iteration](/tag/Experiments-(beta)#operation/createIteration) and then [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` instruction.  To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments). 
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment: async (projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentPost' is not null or undefined
            assertParamExists('createExperiment', 'experimentPost', experimentPost)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experimentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an experiment iteration.  Experiment iterations let you record experiments in individual blocks of time. Initially, iterations are created with a status of `not_started` and appear in the `draftIteration` field of an experiment. To start or stop an iteration, [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` or `stopIteration` instruction.   To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations). 
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIteration: async (projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createIteration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createIteration', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('createIteration', 'experimentKey', experimentKey)
            // verify required parameter 'iterationInput' is not null or undefined
            assertParamExists('createIteration', 'iterationInput', iterationInput)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/iterations`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iterationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response  LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment: async (projectKey: string, environmentKey: string, experimentKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('getExperiment', 'experimentKey', experimentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get results from an experiment for a particular metric.  LaunchDarkly supports one field for expanding the \"Get experiment results\" response. By default, this field is **not** included in the response.  To expand the response, append the `expand` query parameter with the following field: * `traffic` includes the total count of units for each treatment.  For example, `expand=traffic` includes the `traffic` field for the project in the response. 
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {string} [iterationId] The iteration ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults: async (projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, iterationId?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperimentResults', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperimentResults', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('getExperimentResults', 'experimentKey', experimentKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getExperimentResults', 'metricKey', metricKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metrics/{metricKey}/results`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (iterationId !== undefined) {
                localVarQueryParameter['iterationId'] = iterationId;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get results from an experiment for a particular metric group.
         * @summary Get experiment results for metric group
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [iterationId] The iteration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResultsForMetricGroup: async (projectKey: string, environmentKey: string, experimentKey: string, metricGroupKey: string, iterationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperimentResultsForMetricGroup', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperimentResultsForMetricGroup', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('getExperimentResultsForMetricGroup', 'experimentKey', experimentKey)
            // verify required parameter 'metricGroupKey' is not null or undefined
            assertParamExists('getExperimentResultsForMetricGroup', 'metricGroupKey', metricGroupKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}/metric-groups/{metricGroupKey}/results`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)))
                .replace(`{${"metricGroupKey"}}`, encodeURIComponent(String(metricGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (iterationId !== undefined) {
                localVarQueryParameter['iterationId'] = iterationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current experimentation settings for the given project
         * @summary Get experimentation settings
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationSettings: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperimentationSettings', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/experimentation-settings`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration.  ### Expanding the experiments response  LaunchDarkly supports four fields for expanding the \"Get experiments\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments: async (projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExperiments', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExperiments', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (lifecycleState !== undefined) {
                localVarQueryParameter['lifecycleState'] = lifecycleState;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLegacyExperimentResults: async (projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'environmentKey', environmentKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getLegacyExperimentResults', 'metricKey', metricKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/experiments/{environmentKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Example updated experiment name\"   }] } ```  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Example updated description\"   }] } ```  #### startIteration  Starts a new iteration for this experiment. You must [create a new iteration](/tag/Experiments-(beta)#operation/createIteration) before calling this instruction.  An iteration may not be started until it meets the following criteria:  * Its associated flag is toggled on and is not archived * Its `randomizationUnit` is set * At least one of its `treatments` has a non-zero `allocationPercent`  ##### Parameters  - `changeJustification`: The reason for starting a new iteration. Required when you call `startIteration` on an already running experiment, otherwise optional.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"startIteration\",     \"changeJustification\": \"It\'s time to start a new iteration\"   }] } ```  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment. Treatment IDs are returned as part of the [Get experiment](/tag/Experiments-(beta)#operation/getExperiment) response. They are the `_id` of each element in the `treatments` array. - `winningReason`: The reason for the winner  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"stopIteration\",     \"winningTreatmentId\": \"3a548ec2-72ac-4e59-8518-5c24f5609ccf\",     \"winningReason\": \"Example reason to stop the iteration\"   }] } ```  #### archiveExperiment  Archives this experiment. Archived experiments are hidden by default in the LaunchDarkly user interface. You cannot start new iterations for archived experiments.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"archiveExperiment\" }] } ```  #### restoreExperiment  Restores an archived experiment. After restoring an experiment, you can start new iterations for it again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"restoreExperiment\" }] } ``` 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment: async (projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExperiment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExperiment', 'environmentKey', environmentKey)
            // verify required parameter 'experimentKey' is not null or undefined
            assertParamExists('patchExperiment', 'experimentKey', experimentKey)
            // verify required parameter 'experimentPatchInput' is not null or undefined
            assertParamExists('patchExperiment', 'experimentPatchInput', experimentPatchInput)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/experiments/{experimentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"experimentKey"}}`, encodeURIComponent(String(experimentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(experimentPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update experimentation settings for the given project
         * @summary Update experimentation settings
         * @param {string} projectKey The project key
         * @param {RandomizationSettingsPut} randomizationSettingsPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExperimentationSettings: async (projectKey: string, randomizationSettingsPut: RandomizationSettingsPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putExperimentationSettings', 'projectKey', projectKey)
            // verify required parameter 'randomizationSettingsPut' is not null or undefined
            assertParamExists('putExperimentationSettings', 'randomizationSettingsPut', randomizationSettingsPut)
            const localVarPath = `/api/v2/projects/{projectKey}/experimentation-settings`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(randomizationSettingsPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentsBetaApi - functional programming interface
 * @export
 */
export const ExperimentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperimentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an experiment.  To run this experiment, you\'ll need to [create an iteration](/tag/Experiments-(beta)#operation/createIteration) and then [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` instruction.  To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments). 
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExperiment(projectKey, environmentKey, experimentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an experiment iteration.  Experiment iterations let you record experiments in individual blocks of time. Initially, iterations are created with a status of `not_started` and appear in the `draftIteration` field of an experiment. To start or stop an iteration, [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` or `stopIteration` instruction.   To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations). 
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IterationRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIteration(projectKey, environmentKey, experimentKey, iterationInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response  LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiment(projectKey: string, environmentKey: string, experimentKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiment(projectKey, environmentKey, experimentKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get results from an experiment for a particular metric.  LaunchDarkly supports one field for expanding the \"Get experiment results\" response. By default, this field is **not** included in the response.  To expand the response, append the `expand` query parameter with the following field: * `traffic` includes the total count of units for each treatment.  For example, `expand=traffic` includes the `traffic` field for the project in the response. 
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {string} [iterationId] The iteration ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, iterationId?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentBayesianResultsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, iterationId, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get results from an experiment for a particular metric group.
         * @summary Get experiment results for metric group
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [iterationId] The iteration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentResultsForMetricGroup(projectKey: string, environmentKey: string, experimentKey: string, metricGroupKey: string, iterationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGroupResultsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentResultsForMetricGroup(projectKey, environmentKey, experimentKey, metricGroupKey, iterationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current experimentation settings for the given project
         * @summary Get experimentation settings
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperimentationSettings(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomizationSettingsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperimentationSettings(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration.  ### Expanding the experiments response  LaunchDarkly supports four fields for expanding the \"Get experiments\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Example updated experiment name\"   }] } ```  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Example updated description\"   }] } ```  #### startIteration  Starts a new iteration for this experiment. You must [create a new iteration](/tag/Experiments-(beta)#operation/createIteration) before calling this instruction.  An iteration may not be started until it meets the following criteria:  * Its associated flag is toggled on and is not archived * Its `randomizationUnit` is set * At least one of its `treatments` has a non-zero `allocationPercent`  ##### Parameters  - `changeJustification`: The reason for starting a new iteration. Required when you call `startIteration` on an already running experiment, otherwise optional.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"startIteration\",     \"changeJustification\": \"It\'s time to start a new iteration\"   }] } ```  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment. Treatment IDs are returned as part of the [Get experiment](/tag/Experiments-(beta)#operation/getExperiment) response. They are the `_id` of each element in the `treatments` array. - `winningReason`: The reason for the winner  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"stopIteration\",     \"winningTreatmentId\": \"3a548ec2-72ac-4e59-8518-5c24f5609ccf\",     \"winningReason\": \"Example reason to stop the iteration\"   }] } ```  #### archiveExperiment  Archives this experiment. Archived experiments are hidden by default in the LaunchDarkly user interface. You cannot start new iterations for archived experiments.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"archiveExperiment\" }] } ```  #### restoreExperiment  Restores an archived experiment. After restoring an experiment, you can start new iterations for it again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"restoreExperiment\" }] } ``` 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update experimentation settings for the given project
         * @summary Update experimentation settings
         * @param {string} projectKey The project key
         * @param {RandomizationSettingsPut} randomizationSettingsPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putExperimentationSettings(projectKey: string, randomizationSettingsPut: RandomizationSettingsPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomizationSettingsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putExperimentationSettings(projectKey, randomizationSettingsPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExperimentsBetaApi - factory interface
 * @export
 */
export const ExperimentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperimentsBetaApiFp(configuration)
    return {
        /**
         * Create an experiment.  To run this experiment, you\'ll need to [create an iteration](/tag/Experiments-(beta)#operation/createIteration) and then [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` instruction.  To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments). 
         * @summary Create experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {ExperimentPost} experimentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: any): AxiosPromise<Experiment> {
            return localVarFp.createExperiment(projectKey, environmentKey, experimentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an experiment iteration.  Experiment iterations let you record experiments in individual blocks of time. Initially, iterations are created with a status of `not_started` and appear in the `draftIteration` field of an experiment. To start or stop an iteration, [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` or `stopIteration` instruction.   To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations). 
         * @summary Create iteration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {IterationInput} iterationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: any): AxiosPromise<IterationRep> {
            return localVarFp.createIteration(projectKey, environmentKey, experimentKey, iterationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about an experiment.  ### Expanding the experiment response  LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(projectKey: string, environmentKey: string, experimentKey: string, expand?: string, options?: any): AxiosPromise<Experiment> {
            return localVarFp.getExperiment(projectKey, environmentKey, experimentKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get results from an experiment for a particular metric.  LaunchDarkly supports one field for expanding the \"Get experiment results\" response. By default, this field is **not** included in the response.  To expand the response, append the `expand` query parameter with the following field: * `traffic` includes the total count of units for each treatment.  For example, `expand=traffic` includes the `traffic` field for the project in the response. 
         * @summary Get experiment results
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricKey The metric key
         * @param {string} [iterationId] The iteration ID
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, iterationId?: string, expand?: string, options?: any): AxiosPromise<ExperimentBayesianResultsRep> {
            return localVarFp.getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, iterationId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get results from an experiment for a particular metric group.
         * @summary Get experiment results for metric group
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [iterationId] The iteration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentResultsForMetricGroup(projectKey: string, environmentKey: string, experimentKey: string, metricGroupKey: string, iterationId?: string, options?: any): AxiosPromise<MetricGroupResultsRep> {
            return localVarFp.getExperimentResultsForMetricGroup(projectKey, environmentKey, experimentKey, metricGroupKey, iterationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current experimentation settings for the given project
         * @summary Get experimentation settings
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentationSettings(projectKey: string, options?: any): AxiosPromise<RandomizationSettingsRep> {
            return localVarFp.getExperimentationSettings(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration.  ### Expanding the experiments response  LaunchDarkly supports four fields for expanding the \"Get experiments\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
         * @summary Get experiments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: any): AxiosPromise<ExperimentCollectionRep> {
            return localVarFp.getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed experiment result data for legacy experiments.
         * @summary Get legacy experiment results (deprecated)
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} metricKey The metric key
         * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: any): AxiosPromise<ExperimentResults> {
            return localVarFp.getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Example updated experiment name\"   }] } ```  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Example updated description\"   }] } ```  #### startIteration  Starts a new iteration for this experiment. You must [create a new iteration](/tag/Experiments-(beta)#operation/createIteration) before calling this instruction.  An iteration may not be started until it meets the following criteria:  * Its associated flag is toggled on and is not archived * Its `randomizationUnit` is set * At least one of its `treatments` has a non-zero `allocationPercent`  ##### Parameters  - `changeJustification`: The reason for starting a new iteration. Required when you call `startIteration` on an already running experiment, otherwise optional.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"startIteration\",     \"changeJustification\": \"It\'s time to start a new iteration\"   }] } ```  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment. Treatment IDs are returned as part of the [Get experiment](/tag/Experiments-(beta)#operation/getExperiment) response. They are the `_id` of each element in the `treatments` array. - `winningReason`: The reason for the winner  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"stopIteration\",     \"winningTreatmentId\": \"3a548ec2-72ac-4e59-8518-5c24f5609ccf\",     \"winningReason\": \"Example reason to stop the iteration\"   }] } ```  #### archiveExperiment  Archives this experiment. Archived experiments are hidden by default in the LaunchDarkly user interface. You cannot start new iterations for archived experiments.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"archiveExperiment\" }] } ```  #### restoreExperiment  Restores an archived experiment. After restoring an experiment, you can start new iterations for it again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"restoreExperiment\" }] } ``` 
         * @summary Patch experiment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} experimentKey The experiment key
         * @param {ExperimentPatchInput} experimentPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: any): AxiosPromise<Experiment> {
            return localVarFp.patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update experimentation settings for the given project
         * @summary Update experimentation settings
         * @param {string} projectKey The project key
         * @param {RandomizationSettingsPut} randomizationSettingsPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExperimentationSettings(projectKey: string, randomizationSettingsPut: RandomizationSettingsPut, options?: any): AxiosPromise<RandomizationSettingsRep> {
            return localVarFp.putExperimentationSettings(projectKey, randomizationSettingsPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperimentsBetaApi - object-oriented interface
 * @export
 * @class ExperimentsBetaApi
 * @extends {BaseAPI}
 */
export class ExperimentsBetaApi extends BaseAPI {
    /**
     * Create an experiment.  To run this experiment, you\'ll need to [create an iteration](/tag/Experiments-(beta)#operation/createIteration) and then [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` instruction.  To learn more, read [Creating experiments](https://docs.launchdarkly.com/home/creating-experiments). 
     * @summary Create experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {ExperimentPost} experimentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public createExperiment(projectKey: string, environmentKey: string, experimentPost: ExperimentPost, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).createExperiment(projectKey, environmentKey, experimentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an experiment iteration.  Experiment iterations let you record experiments in individual blocks of time. Initially, iterations are created with a status of `not_started` and appear in the `draftIteration` field of an experiment. To start or stop an iteration, [update the experiment](/tag/Experiments-(beta)#operation/patchExperiment) with the `startIteration` or `stopIteration` instruction.   To learn more, read [Starting experiment iterations](https://docs.launchdarkly.com/home/creating-experiments#starting-experiment-iterations). 
     * @summary Create iteration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {IterationInput} iterationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public createIteration(projectKey: string, environmentKey: string, experimentKey: string, iterationInput: IterationInput, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).createIteration(projectKey, environmentKey, experimentKey, iterationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about an experiment.  ### Expanding the experiment response  LaunchDarkly supports four fields for expanding the \"Get experiment\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
     * @summary Get experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperiment(projectKey: string, environmentKey: string, experimentKey: string, expand?: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperiment(projectKey, environmentKey, experimentKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get results from an experiment for a particular metric.  LaunchDarkly supports one field for expanding the \"Get experiment results\" response. By default, this field is **not** included in the response.  To expand the response, append the `expand` query parameter with the following field: * `traffic` includes the total count of units for each treatment.  For example, `expand=traffic` includes the `traffic` field for the project in the response. 
     * @summary Get experiment results
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {string} metricKey The metric key
     * @param {string} [iterationId] The iteration ID
     * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperimentResults(projectKey: string, environmentKey: string, experimentKey: string, metricKey: string, iterationId?: string, expand?: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperimentResults(projectKey, environmentKey, experimentKey, metricKey, iterationId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get results from an experiment for a particular metric group.
     * @summary Get experiment results for metric group
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {string} metricGroupKey The metric group key
     * @param {string} [iterationId] The iteration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperimentResultsForMetricGroup(projectKey: string, environmentKey: string, experimentKey: string, metricGroupKey: string, iterationId?: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperimentResultsForMetricGroup(projectKey, environmentKey, experimentKey, metricGroupKey, iterationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current experimentation settings for the given project
     * @summary Get experimentation settings
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperimentationSettings(projectKey: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperimentationSettings(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about all experiments in an environment.  ### Filtering experiments  LaunchDarkly supports the `filter` query param for filtering, with the following fields:  - `flagKey` filters for only experiments that use the flag with the given key. - `metricKey` filters for only experiments that use the metric with the given key. - `status` filters for only experiments with an iteration with the given status. An iteration can have the status `not_started`, `running` or `stopped`.  For example, `filter=flagKey:my-flag,status:running,metricKey:page-load-ms` filters for experiments for the given flag key and the given metric key which have a currently running iteration.  ### Expanding the experiments response  LaunchDarkly supports four fields for expanding the \"Get experiments\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `previousIterations` includes all iterations prior to the current iteration. By default only the current iteration is included in the response. - `draftIteration` includes the iteration which has not been started yet, if any. - `secondaryMetrics` includes secondary metrics. By default only the primary metric is included in the response. - `treatments` includes all treatment and parameter details. By default treatment data is not included in the response.  For example, `expand=draftIteration,treatments` includes the `draftIteration` and `treatments` fields in the response. If fields that you request with the `expand` query parameter are empty, they are not included in the response. 
     * @summary Get experiments
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [limit] The maximum number of experiments to return. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form &#x60;field:value&#x60;. Supported fields are explained above.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {string} [lifecycleState] A comma-separated list of experiment archived states. Supports &#x60;archived&#x60;, &#x60;active&#x60;, or both. Defaults to &#x60;active&#x60; experiments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getExperiments(projectKey: string, environmentKey: string, limit?: number, offset?: number, filter?: string, expand?: string, lifecycleState?: string, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getExperiments(projectKey, environmentKey, limit, offset, filter, expand, lifecycleState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed experiment result data for legacy experiments.
     * @summary Get legacy experiment results (deprecated)
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} metricKey The metric key
     * @param {number} [from] A timestamp denoting the start of the data collection period, expressed as a Unix epoch time in milliseconds.
     * @param {number} [to] A timestamp denoting the end of the data collection period, expressed as a Unix epoch time in milliseconds.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public getLegacyExperimentResults(projectKey: string, featureFlagKey: string, environmentKey: string, metricKey: string, from?: number, to?: number, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).getLegacyExperimentResults(projectKey, featureFlagKey, environmentKey, metricKey, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an experiment. Updating an experiment uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating experiments.  #### updateName  Updates the experiment name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Example updated experiment name\"   }] } ```  #### updateDescription  Updates the experiment description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Example updated description\"   }] } ```  #### startIteration  Starts a new iteration for this experiment. You must [create a new iteration](/tag/Experiments-(beta)#operation/createIteration) before calling this instruction.  An iteration may not be started until it meets the following criteria:  * Its associated flag is toggled on and is not archived * Its `randomizationUnit` is set * At least one of its `treatments` has a non-zero `allocationPercent`  ##### Parameters  - `changeJustification`: The reason for starting a new iteration. Required when you call `startIteration` on an already running experiment, otherwise optional.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"startIteration\",     \"changeJustification\": \"It\'s time to start a new iteration\"   }] } ```  #### stopIteration  Stops the current iteration for this experiment.  ##### Parameters  - `winningTreatmentId`: The ID of the winning treatment. Treatment IDs are returned as part of the [Get experiment](/tag/Experiments-(beta)#operation/getExperiment) response. They are the `_id` of each element in the `treatments` array. - `winningReason`: The reason for the winner  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"stopIteration\",     \"winningTreatmentId\": \"3a548ec2-72ac-4e59-8518-5c24f5609ccf\",     \"winningReason\": \"Example reason to stop the iteration\"   }] } ```  #### archiveExperiment  Archives this experiment. Archived experiments are hidden by default in the LaunchDarkly user interface. You cannot start new iterations for archived experiments.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"archiveExperiment\" }] } ```  #### restoreExperiment  Restores an archived experiment. After restoring an experiment, you can start new iterations for it again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"restoreExperiment\" }] } ``` 
     * @summary Patch experiment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} experimentKey The experiment key
     * @param {ExperimentPatchInput} experimentPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public patchExperiment(projectKey: string, environmentKey: string, experimentKey: string, experimentPatchInput: ExperimentPatchInput, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).patchExperiment(projectKey, environmentKey, experimentKey, experimentPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update experimentation settings for the given project
     * @summary Update experimentation settings
     * @param {string} projectKey The project key
     * @param {RandomizationSettingsPut} randomizationSettingsPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentsBetaApi
     */
    public putExperimentationSettings(projectKey: string, randomizationSettingsPut: RandomizationSettingsPut, options?: AxiosRequestConfig) {
        return ExperimentsBetaApiFp(this.configuration).putExperimentationSettings(projectKey, randomizationSettingsPut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureFlagsApi - axios parameter creator
 * @export
 */
export const FeatureFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag: async (projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('copyFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('copyFeatureFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'flagCopyConfigPost' is not null or undefined
            assertParamExists('copyFeatureFlag', 'flagCopyConfigPost', flagCopyConfigPost)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/copy`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagCopyConfigPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFeatureFlag', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of context targets on a feature flag that are scheduled for removal.
         * @summary Get expiring context targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringContextTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringContextTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringContextTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getExpiringContextTargets', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring context targets for feature flag](/tag/Feature-flags#operation/getExpiringContextTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of user targets on a feature flag that are scheduled for removal. 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getExpiringUserTargets', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.  > #### Recommended use > > This endpoint can return a large amount of information. Specifying one or multiple environments with the `env` parameter can decrease response time and overall payload size. We recommend using this parameter to return only the environments relevant to your query.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days  - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response. 
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag: async (projectKey: string, featureFlagKey: string, env?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlag', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagStatus', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments: async (projectKey: string, featureFlagKey: string, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatusAcrossEnvironments', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagStatusAcrossEnvironments', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-status/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: You created the flag fewer than seven days ago and it has never been requested. - `active`: LaunchDarkly is receiving requests for this flag, but there are either multiple variations configured, or it is toggled off, or there have been changes to configuration in the past seven days. - `inactive`: You created the feature flag more than seven days ago, and hasn\'t been requested within the past seven days. - `launched`: LaunchDarkly is receiving requests for this flag, it is toggled on, there is only one variation configured, and there have been no changes to configuration in the past seven days.  To learn more, read [Flag statuses](https://docs.launchdarkly.com/home/code/flag-status). 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagStatuses', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagStatuses', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/flag-statuses/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all feature flags in the given project. By default, each flag includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the `tag` query parameter.  > #### Recommended use > > This endpoint can return a large amount of information. We recommend using some or all of these query parameters to decrease response time and overall payload size: `limit`, `env`, `query`, and `filter=creationDate`.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  | Filter argument       | Description | Example              | |-----------------------|-------------|----------------------| | `applicationEvaluated`  | A string. It filters the list to flags that are evaluated in the application with the given key. | `filter=applicationEvaluated:com.launchdarkly.cafe` | | `archived`              | (deprecated) A boolean value. It filters the list to archived flags. | Use `filter=state:archived` instead | | `contextKindsEvaluated` | A `+`-separated list of context kind keys. It filters the list to flags which have been evaluated in the past 30 days for all of the context kinds in the list. | `filter=contextKindsEvaluated:user+application` | | `contextKindTargeted`   | A string. It filters the list to flags that are targeting the given context kind key. | `filter=contextKindTargeted:user` | | `codeReferences.max`    | An integer value. Use `0` to return flags that do not have code references. | `filter=codeReferences.max:0` | | `codeReferences.min`    | An integer value. Use `1` to return flags that do have code references. | `filter=codeReferences.min:1` | | `creationDate`          | An object with an optional `before` field whose value is Unix time in milliseconds. It filters the list to flags created before the date. | `filter=creationDate:{\"before\":1690527600000}` | | `evaluated`             | An object that contains a key of `after` and a value in Unix time in milliseconds. It filters the list to all flags that have been evaluated since the time you specify, in the environment provided. This filter requires the `filterEnv` filter. | `filter=evaluation:{\"after\":1690527600000}` | | `filterEnv`             | A string with the key of a valid environment. You must use this field for filters that are environment-specific. If there are multiple environment-specific filters, you only need to include this field once. | `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active` | | `followerId`            | A valid member ID. It filters the list to flags that are being followed by this member. |  `filter=followerId:12ab3c45de678910abc12345` | | `hasDataExport`         | A boolean value. It filters the list to flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter requires the `filterEnv` filter. | `filter=hasDataExport:true,filterEnv:production` | | `hasExperiment`         | A boolean value. It filters the list to flags that are used in an experiment. | `filter=hasExperiment:true` | | `maintainerId`          | A valid member ID. It filters the list to flags that are maintained by this member. | `filter=maintainerId:12ab3c45de678910abc12345` | | `maintainerTeamKey`     | A string. It filters the list to flags that are maintained by the team with this key. | `filter=maintainerTeamKey:example-team-key` | | `query`                 | A string. It filters the list to flags that include the specified string in their key or name. It is not case sensitive. | `filter=query:example` | | `state`                 | A string, either `live`, `deprecated`, or `archived`. It filters the list to flags in this state. | `filter=state:archived` | | `sdkAvailability`       | A string, one of `client`, `mobile`, `anyClient`, `server`. Using `client` filters the list to flags whose client-side SDK availability is set to use the client-side ID. Using `mobile` filters to flags set to use the mobile key. Using `anyClient` filters to flags set to use either the client-side ID or the mobile key. Using `server` filters to flags set to use neither, that is, to flags only available in server-side SDKs.  | `filter=sdkAvailability:client` | | `segmentTargeted`       | A string. It filters the list to flags that target the segment with this key. This filter requires the `filterEnv` filter. | `filter=segmentTargeted:example-segment-key,filterEnv:production` | | `status`                | A string, either `new`, `inactive`, `active`, or `launched`. It filters the list to flags with the specified status in the specified environment. This filter requires the `filterEnv` filter. | `filter=status:active,filterEnv:production` | | `tags`                  | A `+`-separated list of tags. It filters the list to flags that have all of the tags in the list. | `filter=tags:beta+test` | | `type`                  | A string, either `temporary` or `permanent`. It filters the list to flags with the specified type. | `filter=type:permanent` |  The documented values for the `filter` query are prior to URL encoding. For example, the `+` in `filter=tags:beta+test` must be encoded to `%2B`.  By default, this endpoint returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `codeReferences` includes code references for the feature flag - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response, and default cohort information is included in the `fallthrough` property of a flag\'s response. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] Deprecated, use &#x60;filter&#x3D;archived:true&#x60; instead. A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default, flags do _not_ include their lists of prerequisites, targets, or rules for each environment. Set &#x60;summary&#x3D;0&#x60; to include these fields for each flag returned.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags: async (projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlags', 'projectKey', projectKey)
            const localVarPath = `/api/v2/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (summary !== undefined) {
                localVarQueryParameter['summary'] = summary;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (compare !== undefined) {
                localVarQueryParameter['compare'] = compare;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a context for removal from individual targeting on a feature flag. The flag must already individually target the context.  You can add, update, or remove a scheduled removal date. You can only schedule a context for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring targets.  <details> <summary>Click to expand instructions for <strong>updating expiring targets</strong></summary>  #### addExpiringTarget  Adds a date and time that LaunchDarkly will remove the context from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### updateExpiringTarget  Updates the date and time that LaunchDarkly will remove the context from the flag\'s individual targeting  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey` * `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### removeExpiringTarget  Removes the scheduled removal of the context from the flag\'s individual targeting. The context will remain part of the flag\'s individual targeting until you explicitly remove it, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  </details> 
         * @summary Update expiring context targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchExpiringTargets', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'patchFlagsRequest' is not null or undefined
            assertParamExists('patchExpiringTargets', 'patchFlagsRequest', patchFlagsRequest)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchFlagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring context targets on feature flag](/tag/Feature-flags#operation/patchExpiringTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Schedule a target for removal from individual targeting on a feature flag. The flag must already serve a variation to specific targets based on their key.  You can add, update, or remove a scheduled removal date. You can only schedule a target for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting * `version`: (Optional) The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  </details> 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'patchFlagsRequest' is not null or undefined
            assertParamExists('patchExpiringUserTargets', 'patchFlagsRequest', patchFlagsRequest)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchFlagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some instructions only) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object. The body of a single semantic patch can contain many different instructions.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for <strong>turning flags on and off</strong></summary>  These instructions require the `environmentKey` parameter.  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>working with targeting and variations</strong></summary>  These instructions require the `environmentKey` parameter.  Several of the instructions for working with targeting and variations require flag rule IDs, variation IDs, or clause IDs as parameters. Each of these are returned as part of the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) response. The flag rule ID is the `_id` field of each element in the `rules` array within each environment listed in the `environments` object. The variation ID is the `_id` field in each element of the `variations` array. The clause ID is the `_id` field of each element of the `clauses` array within the `rules` array within each environment listed in the `environments` object.  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauses\": [{    \"contextKind\": \"user\",    \"attribute\": \"country\",    \"op\": \"in\",    \"negate\": false,    \"values\": [\"USA\", \"Canada\"]   }]  }] } ```  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addPrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights`, `rolloutBucketBy`, and `rolloutContextKind` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case. - `beforeRuleId`: (Optional) ID of a flag rule. - Either   - `variationId`: ID of a variation of the flag.    or    - `rolloutWeights`: (Optional) Map of `variationId` to weight, in thousandths of a percent (0-100000).   - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`.   - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }]   }] } ```  Here\'s an example that uses a percentage rollout:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }],     \"rolloutContextKind\": \"organization\",     \"rolloutWeights\": {       \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation       \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation     }   }] } ```  #### addTargets  Adds context keys to the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Returns an error if this causes the flag to target the same context key in multiple variations.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations. If you are working with contexts, use `addTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addValuesToClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### addVariation  Adds a variation to the flag.  ##### Parameters  - `value`: The variation value. - `name`: (Optional) The variation name. - `description`: (Optional) A description for the variation.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"addVariation\", \"value\": 20, \"name\": \"New variation\" } ] } ```  #### clearTargets  Removes all individual targets from the variation that `variationId` specifies. This includes both user and non-user targets.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies. If you are working with contexts, use `clearTargets` instead of this instruction.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearUserTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseIds\": [\"10a58772-3121-400f-846b-b8a04e8944ed\", \"36a461dc-235e-4b08-97b9-73ce9365873e\"]  }] } ```  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removePrerequisite\", \"key\": \"prereq-flag-key-123abc\" } ] } ```  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removeRule\", \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\" } ] } ```  #### removeTargets  Removes context keys from the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Does nothing if the flag does not target the context keys.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys. If you are working with contexts, use `removeTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeValuesFromClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### removeVariation  Removes a variation from the flag.  ##### Parameters  - `variationId`: ID of a variation of the flag to remove.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"removeVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"reorderRules\",   \"ruleIds\": [\"a902ef4a-2faf-4eaf-88e1-ecc356708a29\", \"63c238d1-835d-435e-8f21-c8d5e40b2a3d\"]  }] } ```  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key-123abc\",           \"variationId\": \"10a58772-3121-400f-846b-b8a04e8944ed\"         },         {           \"key\": \"another-prereq-flag-key-456def\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"description\": \"My new rule\",           \"clauses\": [             {               \"contextKind\": \"user\",               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceTargets  Removes all existing targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of context targeting. Each item in the list includes an optional `contextKind` that defaults to `user`, a required `variationId`, and a required list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceTargets\",       \"targets\": [         {           \"contextKind\": \"user\",           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\"]         },         {           \"contextKind\": \"device\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"device-key-456def\"]         }       ]     }       ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide. In the list of targets, you must include a target for each of the flag\'s variations. If you are working with contexts, use `replaceTargets` instead of this instruction.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\", \"user-key-456def\"]         },         {           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"user-key-789ghi\"]         }       ]     }   ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"updateClause\",     \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",     \"clauseId\": \"10c7462a-2062-45ba-a8bb-dfb3de0f8af5\",     \"clause\": {       \"contextKind\": \"user\",       \"attribute\": \"country\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Mexico\", \"Canada\"]     }   }] } ```  #### updateDefaultVariation  Updates the default on or off variation of the flag.  ##### Parameters  - `onVariationValue`: (Optional) The value of the variation of the new on variation. - `offVariationValue`: (Optional) The value of the variation of the new off variation  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateDefaultVariation\", \"OnVariationValue\": true, \"OffVariationValue\": false } ] } ```  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a context matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag.  or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  Here\'s an example that uses a percentage rollout:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"rolloutContextKind\": \"user\",   \"rolloutWeights\": {    \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation    \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation   }  }] } ```  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateOffVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updatePrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleDescription\",   \"description\": \"New rule description\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\"  }] } ```  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleTrackEvents\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"trackEvents\": true  }] } ```  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleVariationOrRollout\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEvents\", \"trackEvents\": true } ] } ```  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEventsFallthrough\", \"trackEvents\": true } ] } ```  #### updateVariation  Updates a variation of the flag.  ##### Parameters  - `variationId`: The ID of the variation to update. - `name`: (Optional) The updated variation name. - `value`: (Optional) The updated variation value. - `description`: (Optional) The updated variation description.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\", \"value\": 20 } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating flag settings</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### addCustomProperties  Adds a new custom property to the feature flag. Custom properties are used to associate feature flags with LaunchDarkly integrations. For example, if you create an integration with an issue tracking service, you may want to associate a flag with a list of issues related to a feature\'s development.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{   \"kind\": \"addCustomProperties\",   \"key\": \"example-custom-property\",   \"name\": \"Example custom property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"addTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your customers.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagPermanent\" } ] } ```  #### makeFlagTemporary  Marks the feature flag as temporary.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagTemporary\" } ] } ```  #### removeCustomProperties  Removes the associated values from a custom property. If all the associated values are removed, this instruction also removes the custom property.  ##### Parameters   - `key`: The custom property key.  - `values`: A list of the associated values to remove from the custom property.  ```json {  \"instructions\": [{   \"kind\": \"replaceCustomProperties\",   \"key\": \"example-custom-property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeMaintainer\" } ] } ```  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### replaceCustomProperties  Replaces the existing associated values for a custom property with the new values.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the new associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{    \"kind\": \"replaceCustomProperties\",    \"key\": \"example-custom-property\",    \"name\": \"Example custom property\",    \"values\": [\"value1\", \"value2\"]  }] } ```  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn off availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOffClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOnClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateDescription\", \"value\": \"Updated flag description\" } ] } ``` #### updateMaintainerMember  Updates the maintainer of the flag to an existing member and removes the existing maintainer.  ##### Parameters  - `value`: The ID of the member.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerMember\", \"value\": \"61e9b714fd47591727db558a\" } ] } ```  #### updateMaintainerTeam  Updates the maintainer of the flag to an existing team and removes the existing maintainer.  ##### Parameters  - `value`: The key of the team.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerTeam\", \"value\": \"example-team-key\" } ] } ```  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateName\", \"value\": \"Updated flag name\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating the flag lifecycle</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  ```json {   \"instructions\": [ { \"kind\": \"archiveFlag\" } ] } ```  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all contexts.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deleteFlag\" } ] } ```  #### deprecateFlag  Deprecates the feature flag. This hides it from the live flags list without archiving or deleting it.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deprecateFlag\" } ] } ```  #### restoreDeprecatedFlag  Restores the feature flag if it was previously deprecated.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreDeprecatedFlag\" } ] } ```  #### restoreFlag  Restores the feature flag if it was previously archived.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreFlag\" } ] } ```  </details>  ### Using JSON patches on a feature flag  If you do not include the semantic patch header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  In the JSON patch representation, use a JSON pointer in the `path` element to describe what field to change. Use the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) endpoint to find the field you want to update.  There are a few special cases to keep in mind when determining the value of the `path` element:    * To add an individual target to a specific variation if the flag variation already has individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/0/values/-\",       \"value\": \"TestClient10\"     }   ]   ```    * To add an individual target to a specific variation if the flag variation does not already have individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/-\",       \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }     }   ]   ```    * To add a flag to a release pipeline, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/releasePipelineKey\",       \"value\": \"example-release-pipeline-key\"     }   ]   ```  ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response. You can update cohorts by updating `rules`. Default cohort information is included in the `fallthrough` property of a flag\'s response. You can update the default cohort by updating `fallthrough`. When you update the rollout for a cohort or the default cohort through the API, provide a rollout instead of a single `variationId`. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag: async (projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchFeatureFlag', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchFeatureFlag', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a feature flag with the given name, key, and variations.  <details> <summary>Click to expand instructions for <strong>creating a migration flag</strong></summary>  ### Creating a migration flag  When you create a migration flag, the variations are pre-determined based on the number of stages in the migration.  To create a migration flag, omit the `variations` and `defaults` information. Instead, provide a `purpose` of `migration`, and `migrationSettings`. If you create a migration flag with six stages, `contextKind` is required. Otherwise, it should be omitted.  Here\'s an example:  ```json {   \"key\": \"flag-key-123\",   \"purpose\": \"migration\",   \"migrationSettings\": {     \"stageCount\": 6,     \"contextKind\": \"account\"   } } ```  To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags).  </details> 
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag: async (projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFeatureFlag', 'projectKey', projectKey)
            // verify required parameter 'featureFlagBody' is not null or undefined
            assertParamExists('postFeatureFlag', 'featureFlagBody', featureFlagBody)
            const localVarPath = `/api/v2/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (clone !== undefined) {
                localVarQueryParameter['clone'] = clone;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(featureFlagBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsApi - functional programming interface
 * @export
 */
export const FeatureFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeatureFlag(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of context targets on a feature flag that are scheduled for removal.
         * @summary Get expiring context targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringContextTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringContextTargets(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring context targets for feature flag](/tag/Feature-flags#operation/getExpiringContextTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of user targets on a feature flag that are scheduled for removal. 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.  > #### Recommended use > > This endpoint can return a large amount of information. Specifying one or multiple environments with the `env` parameter can decrease response time and overall payload size. We recommend using this parameter to return only the environments relevant to your query.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days  - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response. 
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlag(projectKey, featureFlagKey, env, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagStatusRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatusAcrossEnvironments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: You created the flag fewer than seven days ago and it has never been requested. - `active`: LaunchDarkly is receiving requests for this flag, but there are either multiple variations configured, or it is toggled off, or there have been changes to configuration in the past seven days. - `inactive`: You created the feature flag more than seven days ago, and hasn\'t been requested within the past seven days. - `launched`: LaunchDarkly is receiving requests for this flag, it is toggled on, there is only one variation configured, and there have been no changes to configuration in the past seven days.  To learn more, read [Flag statuses](https://docs.launchdarkly.com/home/code/flag-status). 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatuses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagStatuses(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all feature flags in the given project. By default, each flag includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the `tag` query parameter.  > #### Recommended use > > This endpoint can return a large amount of information. We recommend using some or all of these query parameters to decrease response time and overall payload size: `limit`, `env`, `query`, and `filter=creationDate`.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  | Filter argument       | Description | Example              | |-----------------------|-------------|----------------------| | `applicationEvaluated`  | A string. It filters the list to flags that are evaluated in the application with the given key. | `filter=applicationEvaluated:com.launchdarkly.cafe` | | `archived`              | (deprecated) A boolean value. It filters the list to archived flags. | Use `filter=state:archived` instead | | `contextKindsEvaluated` | A `+`-separated list of context kind keys. It filters the list to flags which have been evaluated in the past 30 days for all of the context kinds in the list. | `filter=contextKindsEvaluated:user+application` | | `contextKindTargeted`   | A string. It filters the list to flags that are targeting the given context kind key. | `filter=contextKindTargeted:user` | | `codeReferences.max`    | An integer value. Use `0` to return flags that do not have code references. | `filter=codeReferences.max:0` | | `codeReferences.min`    | An integer value. Use `1` to return flags that do have code references. | `filter=codeReferences.min:1` | | `creationDate`          | An object with an optional `before` field whose value is Unix time in milliseconds. It filters the list to flags created before the date. | `filter=creationDate:{\"before\":1690527600000}` | | `evaluated`             | An object that contains a key of `after` and a value in Unix time in milliseconds. It filters the list to all flags that have been evaluated since the time you specify, in the environment provided. This filter requires the `filterEnv` filter. | `filter=evaluation:{\"after\":1690527600000}` | | `filterEnv`             | A string with the key of a valid environment. You must use this field for filters that are environment-specific. If there are multiple environment-specific filters, you only need to include this field once. | `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active` | | `followerId`            | A valid member ID. It filters the list to flags that are being followed by this member. |  `filter=followerId:12ab3c45de678910abc12345` | | `hasDataExport`         | A boolean value. It filters the list to flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter requires the `filterEnv` filter. | `filter=hasDataExport:true,filterEnv:production` | | `hasExperiment`         | A boolean value. It filters the list to flags that are used in an experiment. | `filter=hasExperiment:true` | | `maintainerId`          | A valid member ID. It filters the list to flags that are maintained by this member. | `filter=maintainerId:12ab3c45de678910abc12345` | | `maintainerTeamKey`     | A string. It filters the list to flags that are maintained by the team with this key. | `filter=maintainerTeamKey:example-team-key` | | `query`                 | A string. It filters the list to flags that include the specified string in their key or name. It is not case sensitive. | `filter=query:example` | | `state`                 | A string, either `live`, `deprecated`, or `archived`. It filters the list to flags in this state. | `filter=state:archived` | | `sdkAvailability`       | A string, one of `client`, `mobile`, `anyClient`, `server`. Using `client` filters the list to flags whose client-side SDK availability is set to use the client-side ID. Using `mobile` filters to flags set to use the mobile key. Using `anyClient` filters to flags set to use either the client-side ID or the mobile key. Using `server` filters to flags set to use neither, that is, to flags only available in server-side SDKs.  | `filter=sdkAvailability:client` | | `segmentTargeted`       | A string. It filters the list to flags that target the segment with this key. This filter requires the `filterEnv` filter. | `filter=segmentTargeted:example-segment-key,filterEnv:production` | | `status`                | A string, either `new`, `inactive`, `active`, or `launched`. It filters the list to flags with the specified status in the specified environment. This filter requires the `filterEnv` filter. | `filter=status:active,filterEnv:production` | | `tags`                  | A `+`-separated list of tags. It filters the list to flags that have all of the tags in the list. | `filter=tags:beta+test` | | `type`                  | A string, either `temporary` or `permanent`. It filters the list to flags with the specified type. | `filter=type:permanent` |  The documented values for the `filter` query are prior to URL encoding. For example, the `+` in `filter=tags:beta+test` must be encoded to `%2B`.  By default, this endpoint returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `codeReferences` includes code references for the feature flag - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response, and default cohort information is included in the `fallthrough` property of a flag\'s response. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] Deprecated, use &#x60;filter&#x3D;archived:true&#x60; instead. A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default, flags do _not_ include their lists of prerequisites, targets, or rules for each environment. Set &#x60;summary&#x3D;0&#x60; to include these fields for each flag returned.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a context for removal from individual targeting on a feature flag. The flag must already individually target the context.  You can add, update, or remove a scheduled removal date. You can only schedule a context for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring targets.  <details> <summary>Click to expand instructions for <strong>updating expiring targets</strong></summary>  #### addExpiringTarget  Adds a date and time that LaunchDarkly will remove the context from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### updateExpiringTarget  Updates the date and time that LaunchDarkly will remove the context from the flag\'s individual targeting  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey` * `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### removeExpiringTarget  Removes the scheduled removal of the context from the flag\'s individual targeting. The context will remain part of the flag\'s individual targeting until you explicitly remove it, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  </details> 
         * @summary Update expiring context targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring context targets on feature flag](/tag/Feature-flags#operation/patchExpiringTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Schedule a target for removal from individual targeting on a feature flag. The flag must already serve a variation to specific targets based on their key.  You can add, update, or remove a scheduled removal date. You can only schedule a target for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting * `version`: (Optional) The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  </details> 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some instructions only) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object. The body of a single semantic patch can contain many different instructions.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for <strong>turning flags on and off</strong></summary>  These instructions require the `environmentKey` parameter.  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>working with targeting and variations</strong></summary>  These instructions require the `environmentKey` parameter.  Several of the instructions for working with targeting and variations require flag rule IDs, variation IDs, or clause IDs as parameters. Each of these are returned as part of the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) response. The flag rule ID is the `_id` field of each element in the `rules` array within each environment listed in the `environments` object. The variation ID is the `_id` field in each element of the `variations` array. The clause ID is the `_id` field of each element of the `clauses` array within the `rules` array within each environment listed in the `environments` object.  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauses\": [{    \"contextKind\": \"user\",    \"attribute\": \"country\",    \"op\": \"in\",    \"negate\": false,    \"values\": [\"USA\", \"Canada\"]   }]  }] } ```  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addPrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights`, `rolloutBucketBy`, and `rolloutContextKind` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case. - `beforeRuleId`: (Optional) ID of a flag rule. - Either   - `variationId`: ID of a variation of the flag.    or    - `rolloutWeights`: (Optional) Map of `variationId` to weight, in thousandths of a percent (0-100000).   - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`.   - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }]   }] } ```  Here\'s an example that uses a percentage rollout:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }],     \"rolloutContextKind\": \"organization\",     \"rolloutWeights\": {       \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation       \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation     }   }] } ```  #### addTargets  Adds context keys to the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Returns an error if this causes the flag to target the same context key in multiple variations.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations. If you are working with contexts, use `addTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addValuesToClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### addVariation  Adds a variation to the flag.  ##### Parameters  - `value`: The variation value. - `name`: (Optional) The variation name. - `description`: (Optional) A description for the variation.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"addVariation\", \"value\": 20, \"name\": \"New variation\" } ] } ```  #### clearTargets  Removes all individual targets from the variation that `variationId` specifies. This includes both user and non-user targets.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies. If you are working with contexts, use `clearTargets` instead of this instruction.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearUserTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseIds\": [\"10a58772-3121-400f-846b-b8a04e8944ed\", \"36a461dc-235e-4b08-97b9-73ce9365873e\"]  }] } ```  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removePrerequisite\", \"key\": \"prereq-flag-key-123abc\" } ] } ```  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removeRule\", \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\" } ] } ```  #### removeTargets  Removes context keys from the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Does nothing if the flag does not target the context keys.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys. If you are working with contexts, use `removeTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeValuesFromClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### removeVariation  Removes a variation from the flag.  ##### Parameters  - `variationId`: ID of a variation of the flag to remove.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"removeVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"reorderRules\",   \"ruleIds\": [\"a902ef4a-2faf-4eaf-88e1-ecc356708a29\", \"63c238d1-835d-435e-8f21-c8d5e40b2a3d\"]  }] } ```  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key-123abc\",           \"variationId\": \"10a58772-3121-400f-846b-b8a04e8944ed\"         },         {           \"key\": \"another-prereq-flag-key-456def\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"description\": \"My new rule\",           \"clauses\": [             {               \"contextKind\": \"user\",               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceTargets  Removes all existing targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of context targeting. Each item in the list includes an optional `contextKind` that defaults to `user`, a required `variationId`, and a required list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceTargets\",       \"targets\": [         {           \"contextKind\": \"user\",           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\"]         },         {           \"contextKind\": \"device\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"device-key-456def\"]         }       ]     }       ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide. In the list of targets, you must include a target for each of the flag\'s variations. If you are working with contexts, use `replaceTargets` instead of this instruction.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\", \"user-key-456def\"]         },         {           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"user-key-789ghi\"]         }       ]     }   ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"updateClause\",     \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",     \"clauseId\": \"10c7462a-2062-45ba-a8bb-dfb3de0f8af5\",     \"clause\": {       \"contextKind\": \"user\",       \"attribute\": \"country\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Mexico\", \"Canada\"]     }   }] } ```  #### updateDefaultVariation  Updates the default on or off variation of the flag.  ##### Parameters  - `onVariationValue`: (Optional) The value of the variation of the new on variation. - `offVariationValue`: (Optional) The value of the variation of the new off variation  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateDefaultVariation\", \"OnVariationValue\": true, \"OffVariationValue\": false } ] } ```  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a context matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag.  or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  Here\'s an example that uses a percentage rollout:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"rolloutContextKind\": \"user\",   \"rolloutWeights\": {    \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation    \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation   }  }] } ```  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateOffVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updatePrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleDescription\",   \"description\": \"New rule description\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\"  }] } ```  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleTrackEvents\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"trackEvents\": true  }] } ```  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleVariationOrRollout\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEvents\", \"trackEvents\": true } ] } ```  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEventsFallthrough\", \"trackEvents\": true } ] } ```  #### updateVariation  Updates a variation of the flag.  ##### Parameters  - `variationId`: The ID of the variation to update. - `name`: (Optional) The updated variation name. - `value`: (Optional) The updated variation value. - `description`: (Optional) The updated variation description.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\", \"value\": 20 } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating flag settings</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### addCustomProperties  Adds a new custom property to the feature flag. Custom properties are used to associate feature flags with LaunchDarkly integrations. For example, if you create an integration with an issue tracking service, you may want to associate a flag with a list of issues related to a feature\'s development.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{   \"kind\": \"addCustomProperties\",   \"key\": \"example-custom-property\",   \"name\": \"Example custom property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"addTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your customers.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagPermanent\" } ] } ```  #### makeFlagTemporary  Marks the feature flag as temporary.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagTemporary\" } ] } ```  #### removeCustomProperties  Removes the associated values from a custom property. If all the associated values are removed, this instruction also removes the custom property.  ##### Parameters   - `key`: The custom property key.  - `values`: A list of the associated values to remove from the custom property.  ```json {  \"instructions\": [{   \"kind\": \"replaceCustomProperties\",   \"key\": \"example-custom-property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeMaintainer\" } ] } ```  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### replaceCustomProperties  Replaces the existing associated values for a custom property with the new values.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the new associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{    \"kind\": \"replaceCustomProperties\",    \"key\": \"example-custom-property\",    \"name\": \"Example custom property\",    \"values\": [\"value1\", \"value2\"]  }] } ```  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn off availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOffClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOnClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateDescription\", \"value\": \"Updated flag description\" } ] } ``` #### updateMaintainerMember  Updates the maintainer of the flag to an existing member and removes the existing maintainer.  ##### Parameters  - `value`: The ID of the member.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerMember\", \"value\": \"61e9b714fd47591727db558a\" } ] } ```  #### updateMaintainerTeam  Updates the maintainer of the flag to an existing team and removes the existing maintainer.  ##### Parameters  - `value`: The key of the team.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerTeam\", \"value\": \"example-team-key\" } ] } ```  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateName\", \"value\": \"Updated flag name\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating the flag lifecycle</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  ```json {   \"instructions\": [ { \"kind\": \"archiveFlag\" } ] } ```  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all contexts.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deleteFlag\" } ] } ```  #### deprecateFlag  Deprecates the feature flag. This hides it from the live flags list without archiving or deleting it.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deprecateFlag\" } ] } ```  #### restoreDeprecatedFlag  Restores the feature flag if it was previously deprecated.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreDeprecatedFlag\" } ] } ```  #### restoreFlag  Restores the feature flag if it was previously archived.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreFlag\" } ] } ```  </details>  ### Using JSON patches on a feature flag  If you do not include the semantic patch header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  In the JSON patch representation, use a JSON pointer in the `path` element to describe what field to change. Use the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) endpoint to find the field you want to update.  There are a few special cases to keep in mind when determining the value of the `path` element:    * To add an individual target to a specific variation if the flag variation already has individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/0/values/-\",       \"value\": \"TestClient10\"     }   ]   ```    * To add an individual target to a specific variation if the flag variation does not already have individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/-\",       \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }     }   ]   ```    * To add a flag to a release pipeline, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/releasePipelineKey\",       \"value\": \"example-release-pipeline-key\"     }   ]   ```  ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response. You can update cohorts by updating `rules`. Default cohort information is included in the `fallthrough` property of a flag\'s response. You can update the default cohort by updating `fallthrough`. When you update the rollout for a cohort or the default cohort through the API, provide a rollout instead of a single `variationId`. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a feature flag with the given name, key, and variations.  <details> <summary>Click to expand instructions for <strong>creating a migration flag</strong></summary>  ### Creating a migration flag  When you create a migration flag, the variations are pre-determined based on the number of stages in the migration.  To create a migration flag, omit the `variations` and `defaults` information. Instead, provide a `purpose` of `migration`, and `migrationSettings`. If you create a migration flag with six stages, `contextKind` is required. Otherwise, it should be omitted.  Here\'s an example:  ```json {   \"key\": \"flag-key-123\",   \"purpose\": \"migration\",   \"migrationSettings\": {     \"stageCount\": 6,     \"contextKind\": \"account\"   } } ```  To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags).  </details> 
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFeatureFlag(projectKey, featureFlagBody, clone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureFlagsApi - factory interface
 * @export
 */
export const FeatureFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsApiFp(configuration)
    return {
        /**
         *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
         * @summary Copy feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {FlagCopyConfigPost} flagCopyConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
         * @summary Delete feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of context targets on a feature flag that are scheduled for removal.
         * @summary Get expiring context targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringContextTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<ExpiringTargetGetResponse> {
            return localVarFp.getExpiringContextTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring context targets for feature flag](/tag/Feature-flags#operation/getExpiringContextTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of user targets on a feature flag that are scheduled for removal. 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.  > #### Recommended use > > This endpoint can return a large amount of information. Specifying one or multiple environments with the `env` parameter can decrease response time and overall payload size. We recommend using this parameter to return only the environments relevant to your query.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days  - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response. 
         * @summary Get feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, expand?: string, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.getFeatureFlag(projectKey, featureFlagKey, env, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status for a particular feature flag.
         * @summary Get feature flag status
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<FlagStatusRep> {
            return localVarFp.getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status for a particular feature flag across environments.
         * @summary Get flag status across environments
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} [env] Optional environment filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: any): AxiosPromise<FeatureFlagStatusAcrossEnvironments> {
            return localVarFp.getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: You created the flag fewer than seven days ago and it has never been requested. - `active`: LaunchDarkly is receiving requests for this flag, but there are either multiple variations configured, or it is toggled off, or there have been changes to configuration in the past seven days. - `inactive`: You created the feature flag more than seven days ago, and hasn\'t been requested within the past seven days. - `launched`: LaunchDarkly is receiving requests for this flag, it is toggled on, there is only one variation configured, and there have been no changes to configuration in the past seven days.  To learn more, read [Flag statuses](https://docs.launchdarkly.com/home/code/flag-status). 
         * @summary List feature flag statuses
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: any): AxiosPromise<FeatureFlagStatuses> {
            return localVarFp.getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all feature flags in the given project. By default, each flag includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the `tag` query parameter.  > #### Recommended use > > This endpoint can return a large amount of information. We recommend using some or all of these query parameters to decrease response time and overall payload size: `limit`, `env`, `query`, and `filter=creationDate`.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  | Filter argument       | Description | Example              | |-----------------------|-------------|----------------------| | `applicationEvaluated`  | A string. It filters the list to flags that are evaluated in the application with the given key. | `filter=applicationEvaluated:com.launchdarkly.cafe` | | `archived`              | (deprecated) A boolean value. It filters the list to archived flags. | Use `filter=state:archived` instead | | `contextKindsEvaluated` | A `+`-separated list of context kind keys. It filters the list to flags which have been evaluated in the past 30 days for all of the context kinds in the list. | `filter=contextKindsEvaluated:user+application` | | `contextKindTargeted`   | A string. It filters the list to flags that are targeting the given context kind key. | `filter=contextKindTargeted:user` | | `codeReferences.max`    | An integer value. Use `0` to return flags that do not have code references. | `filter=codeReferences.max:0` | | `codeReferences.min`    | An integer value. Use `1` to return flags that do have code references. | `filter=codeReferences.min:1` | | `creationDate`          | An object with an optional `before` field whose value is Unix time in milliseconds. It filters the list to flags created before the date. | `filter=creationDate:{\"before\":1690527600000}` | | `evaluated`             | An object that contains a key of `after` and a value in Unix time in milliseconds. It filters the list to all flags that have been evaluated since the time you specify, in the environment provided. This filter requires the `filterEnv` filter. | `filter=evaluation:{\"after\":1690527600000}` | | `filterEnv`             | A string with the key of a valid environment. You must use this field for filters that are environment-specific. If there are multiple environment-specific filters, you only need to include this field once. | `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active` | | `followerId`            | A valid member ID. It filters the list to flags that are being followed by this member. |  `filter=followerId:12ab3c45de678910abc12345` | | `hasDataExport`         | A boolean value. It filters the list to flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter requires the `filterEnv` filter. | `filter=hasDataExport:true,filterEnv:production` | | `hasExperiment`         | A boolean value. It filters the list to flags that are used in an experiment. | `filter=hasExperiment:true` | | `maintainerId`          | A valid member ID. It filters the list to flags that are maintained by this member. | `filter=maintainerId:12ab3c45de678910abc12345` | | `maintainerTeamKey`     | A string. It filters the list to flags that are maintained by the team with this key. | `filter=maintainerTeamKey:example-team-key` | | `query`                 | A string. It filters the list to flags that include the specified string in their key or name. It is not case sensitive. | `filter=query:example` | | `state`                 | A string, either `live`, `deprecated`, or `archived`. It filters the list to flags in this state. | `filter=state:archived` | | `sdkAvailability`       | A string, one of `client`, `mobile`, `anyClient`, `server`. Using `client` filters the list to flags whose client-side SDK availability is set to use the client-side ID. Using `mobile` filters to flags set to use the mobile key. Using `anyClient` filters to flags set to use either the client-side ID or the mobile key. Using `server` filters to flags set to use neither, that is, to flags only available in server-side SDKs.  | `filter=sdkAvailability:client` | | `segmentTargeted`       | A string. It filters the list to flags that target the segment with this key. This filter requires the `filterEnv` filter. | `filter=segmentTargeted:example-segment-key,filterEnv:production` | | `status`                | A string, either `new`, `inactive`, `active`, or `launched`. It filters the list to flags with the specified status in the specified environment. This filter requires the `filterEnv` filter. | `filter=status:active,filterEnv:production` | | `tags`                  | A `+`-separated list of tags. It filters the list to flags that have all of the tags in the list. | `filter=tags:beta+test` | | `type`                  | A string, either `temporary` or `permanent`. It filters the list to flags with the specified type. | `filter=type:permanent` |  The documented values for the `filter` query are prior to URL encoding. For example, the `+` in `filter=tags:beta+test` must be encoded to `%2B`.  By default, this endpoint returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `codeReferences` includes code references for the feature flag - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response, and default cohort information is included in the `fallthrough` property of a flag\'s response. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary List feature flags
         * @param {string} projectKey The project key
         * @param {string} [env] Filter configurations by environment
         * @param {string} [tag] Filter feature flags by tag
         * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {boolean} [archived] Deprecated, use &#x60;filter&#x3D;archived:true&#x60; instead. A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
         * @param {boolean} [summary] By default, flags do _not_ include their lists of prerequisites, targets, or rules for each environment. Set &#x60;summary&#x3D;0&#x60; to include these fields for each flag returned.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
         * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
         * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, expand?: string, options?: any): AxiosPromise<FeatureFlags> {
            return localVarFp.getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a context for removal from individual targeting on a feature flag. The flag must already individually target the context.  You can add, update, or remove a scheduled removal date. You can only schedule a context for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring targets.  <details> <summary>Click to expand instructions for <strong>updating expiring targets</strong></summary>  #### addExpiringTarget  Adds a date and time that LaunchDarkly will remove the context from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### updateExpiringTarget  Updates the date and time that LaunchDarkly will remove the context from the flag\'s individual targeting  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey` * `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### removeExpiringTarget  Removes the scheduled removal of the context from the flag\'s individual targeting. The context will remain part of the flag\'s individual targeting until you explicitly remove it, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  </details> 
         * @summary Update expiring context targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: any): AxiosPromise<ExpiringTargetPatchResponse> {
            return localVarFp.patchExpiringTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring context targets on feature flag](/tag/Feature-flags#operation/patchExpiringTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Schedule a target for removal from individual targeting on a feature flag. The flag must already serve a variation to specific targets based on their key.  You can add, update, or remove a scheduled removal date. You can only schedule a target for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting * `version`: (Optional) The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  </details> 
         * @summary Update expiring user targets on feature flag
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {PatchFlagsRequest} patchFlagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a partial update to a feature flag. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some instructions only) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object. The body of a single semantic patch can contain many different instructions.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for <strong>turning flags on and off</strong></summary>  These instructions require the `environmentKey` parameter.  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>working with targeting and variations</strong></summary>  These instructions require the `environmentKey` parameter.  Several of the instructions for working with targeting and variations require flag rule IDs, variation IDs, or clause IDs as parameters. Each of these are returned as part of the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) response. The flag rule ID is the `_id` field of each element in the `rules` array within each environment listed in the `environments` object. The variation ID is the `_id` field in each element of the `variations` array. The clause ID is the `_id` field of each element of the `clauses` array within the `rules` array within each environment listed in the `environments` object.  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauses\": [{    \"contextKind\": \"user\",    \"attribute\": \"country\",    \"op\": \"in\",    \"negate\": false,    \"values\": [\"USA\", \"Canada\"]   }]  }] } ```  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addPrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights`, `rolloutBucketBy`, and `rolloutContextKind` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case. - `beforeRuleId`: (Optional) ID of a flag rule. - Either   - `variationId`: ID of a variation of the flag.    or    - `rolloutWeights`: (Optional) Map of `variationId` to weight, in thousandths of a percent (0-100000).   - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`.   - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }]   }] } ```  Here\'s an example that uses a percentage rollout:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }],     \"rolloutContextKind\": \"organization\",     \"rolloutWeights\": {       \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation       \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation     }   }] } ```  #### addTargets  Adds context keys to the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Returns an error if this causes the flag to target the same context key in multiple variations.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations. If you are working with contexts, use `addTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addValuesToClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### addVariation  Adds a variation to the flag.  ##### Parameters  - `value`: The variation value. - `name`: (Optional) The variation name. - `description`: (Optional) A description for the variation.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"addVariation\", \"value\": 20, \"name\": \"New variation\" } ] } ```  #### clearTargets  Removes all individual targets from the variation that `variationId` specifies. This includes both user and non-user targets.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies. If you are working with contexts, use `clearTargets` instead of this instruction.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearUserTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseIds\": [\"10a58772-3121-400f-846b-b8a04e8944ed\", \"36a461dc-235e-4b08-97b9-73ce9365873e\"]  }] } ```  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removePrerequisite\", \"key\": \"prereq-flag-key-123abc\" } ] } ```  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removeRule\", \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\" } ] } ```  #### removeTargets  Removes context keys from the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Does nothing if the flag does not target the context keys.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys. If you are working with contexts, use `removeTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeValuesFromClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### removeVariation  Removes a variation from the flag.  ##### Parameters  - `variationId`: ID of a variation of the flag to remove.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"removeVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"reorderRules\",   \"ruleIds\": [\"a902ef4a-2faf-4eaf-88e1-ecc356708a29\", \"63c238d1-835d-435e-8f21-c8d5e40b2a3d\"]  }] } ```  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key-123abc\",           \"variationId\": \"10a58772-3121-400f-846b-b8a04e8944ed\"         },         {           \"key\": \"another-prereq-flag-key-456def\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"description\": \"My new rule\",           \"clauses\": [             {               \"contextKind\": \"user\",               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceTargets  Removes all existing targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of context targeting. Each item in the list includes an optional `contextKind` that defaults to `user`, a required `variationId`, and a required list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceTargets\",       \"targets\": [         {           \"contextKind\": \"user\",           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\"]         },         {           \"contextKind\": \"device\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"device-key-456def\"]         }       ]     }       ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide. In the list of targets, you must include a target for each of the flag\'s variations. If you are working with contexts, use `replaceTargets` instead of this instruction.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\", \"user-key-456def\"]         },         {           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"user-key-789ghi\"]         }       ]     }   ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"updateClause\",     \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",     \"clauseId\": \"10c7462a-2062-45ba-a8bb-dfb3de0f8af5\",     \"clause\": {       \"contextKind\": \"user\",       \"attribute\": \"country\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Mexico\", \"Canada\"]     }   }] } ```  #### updateDefaultVariation  Updates the default on or off variation of the flag.  ##### Parameters  - `onVariationValue`: (Optional) The value of the variation of the new on variation. - `offVariationValue`: (Optional) The value of the variation of the new off variation  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateDefaultVariation\", \"OnVariationValue\": true, \"OffVariationValue\": false } ] } ```  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a context matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag.  or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  Here\'s an example that uses a percentage rollout:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"rolloutContextKind\": \"user\",   \"rolloutWeights\": {    \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation    \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation   }  }] } ```  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateOffVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updatePrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleDescription\",   \"description\": \"New rule description\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\"  }] } ```  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleTrackEvents\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"trackEvents\": true  }] } ```  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleVariationOrRollout\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEvents\", \"trackEvents\": true } ] } ```  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEventsFallthrough\", \"trackEvents\": true } ] } ```  #### updateVariation  Updates a variation of the flag.  ##### Parameters  - `variationId`: The ID of the variation to update. - `name`: (Optional) The updated variation name. - `value`: (Optional) The updated variation value. - `description`: (Optional) The updated variation description.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\", \"value\": 20 } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating flag settings</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### addCustomProperties  Adds a new custom property to the feature flag. Custom properties are used to associate feature flags with LaunchDarkly integrations. For example, if you create an integration with an issue tracking service, you may want to associate a flag with a list of issues related to a feature\'s development.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{   \"kind\": \"addCustomProperties\",   \"key\": \"example-custom-property\",   \"name\": \"Example custom property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"addTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your customers.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagPermanent\" } ] } ```  #### makeFlagTemporary  Marks the feature flag as temporary.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagTemporary\" } ] } ```  #### removeCustomProperties  Removes the associated values from a custom property. If all the associated values are removed, this instruction also removes the custom property.  ##### Parameters   - `key`: The custom property key.  - `values`: A list of the associated values to remove from the custom property.  ```json {  \"instructions\": [{   \"kind\": \"replaceCustomProperties\",   \"key\": \"example-custom-property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeMaintainer\" } ] } ```  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### replaceCustomProperties  Replaces the existing associated values for a custom property with the new values.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the new associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{    \"kind\": \"replaceCustomProperties\",    \"key\": \"example-custom-property\",    \"name\": \"Example custom property\",    \"values\": [\"value1\", \"value2\"]  }] } ```  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn off availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOffClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOnClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateDescription\", \"value\": \"Updated flag description\" } ] } ``` #### updateMaintainerMember  Updates the maintainer of the flag to an existing member and removes the existing maintainer.  ##### Parameters  - `value`: The ID of the member.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerMember\", \"value\": \"61e9b714fd47591727db558a\" } ] } ```  #### updateMaintainerTeam  Updates the maintainer of the flag to an existing team and removes the existing maintainer.  ##### Parameters  - `value`: The key of the team.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerTeam\", \"value\": \"example-team-key\" } ] } ```  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateName\", \"value\": \"Updated flag name\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating the flag lifecycle</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  ```json {   \"instructions\": [ { \"kind\": \"archiveFlag\" } ] } ```  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all contexts.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deleteFlag\" } ] } ```  #### deprecateFlag  Deprecates the feature flag. This hides it from the live flags list without archiving or deleting it.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deprecateFlag\" } ] } ```  #### restoreDeprecatedFlag  Restores the feature flag if it was previously deprecated.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreDeprecatedFlag\" } ] } ```  #### restoreFlag  Restores the feature flag if it was previously archived.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreFlag\" } ] } ```  </details>  ### Using JSON patches on a feature flag  If you do not include the semantic patch header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  In the JSON patch representation, use a JSON pointer in the `path` element to describe what field to change. Use the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) endpoint to find the field you want to update.  There are a few special cases to keep in mind when determining the value of the `path` element:    * To add an individual target to a specific variation if the flag variation already has individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/0/values/-\",       \"value\": \"TestClient10\"     }   ]   ```    * To add an individual target to a specific variation if the flag variation does not already have individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/-\",       \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }     }   ]   ```    * To add a flag to a release pipeline, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/releasePipelineKey\",       \"value\": \"example-release-pipeline-key\"     }   ]   ```  ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response. You can update cohorts by updating `rules`. Default cohort information is included in the `fallthrough` property of a flag\'s response. You can update the default cohort by updating `fallthrough`. When you update the rollout for a cohort or the default cohort through the API, provide a rollout instead of a single `variationId`. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
         * @summary Update feature flag
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a feature flag with the given name, key, and variations.  <details> <summary>Click to expand instructions for <strong>creating a migration flag</strong></summary>  ### Creating a migration flag  When you create a migration flag, the variations are pre-determined based on the number of stages in the migration.  To create a migration flag, omit the `variations` and `defaults` information. Instead, provide a `purpose` of `migration`, and `migrationSettings`. If you create a migration flag with six stages, `contextKind` is required. Otherwise, it should be omitted.  Here\'s an example:  ```json {   \"key\": \"flag-key-123\",   \"purpose\": \"migration\",   \"migrationSettings\": {     \"stageCount\": 6,     \"contextKind\": \"account\"   } } ```  To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags).  </details> 
         * @summary Create a feature flag
         * @param {string} projectKey The project key
         * @param {FeatureFlagBody} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: any): AxiosPromise<FeatureFlag> {
            return localVarFp.postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsApi - object-oriented interface
 * @export
 * @class FeatureFlagsApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsApi extends BaseAPI {
    /**
     *  > ### Copying flag settings is an Enterprise feature > > Copying flag settings is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  Copy flag settings from a source environment to a target environment.  By default, this operation copies the entire flag configuration. You can use the `includedActions` or `excludedActions` to specify that only part of the flag configuration is copied.  If you provide the optional `currentVersion` of a flag, this operation tests to ensure that the current flag version in the environment matches the version you\'ve specified. The operation rejects attempts to copy flag settings if the environment\'s current version  of the flag does not match the version you\'ve specified. You can use this to enforce optimistic locking on copy attempts. 
     * @summary Copy feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {FlagCopyConfigPost} flagCopyConfigPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public copyFeatureFlag(projectKey: string, featureFlagKey: string, flagCopyConfigPost: FlagCopyConfigPost, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).copyFeatureFlag(projectKey, featureFlagKey, flagCopyConfigPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feature flag in all environments. Use with caution: only delete feature flags your application no longer uses.
     * @summary Delete feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of context targets on a feature flag that are scheduled for removal.
     * @summary Get expiring context targets for feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getExpiringContextTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getExpiringContextTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring context targets for feature flag](/tag/Feature-flags#operation/getExpiringContextTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of user targets on a feature flag that are scheduled for removal. 
     * @summary Get expiring user targets for feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single feature flag by key. By default, this returns the configurations for all environments. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just the `production` environment.  > #### Recommended use > > This endpoint can return a large amount of information. Specifying one or multiple environments with the `env` parameter can decrease response time and overall payload size. We recommend using this parameter to return only the environments relevant to your query.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days  - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response. 
     * @summary Get feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [env] Filter configurations by environment
     * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlag(projectKey: string, featureFlagKey: string, env?: string, expand?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlag(projectKey, featureFlagKey, env, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status for a particular feature flag.
     * @summary Get feature flag status
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status for a particular feature flag across environments.
     * @summary Get flag status across environments
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} [env] Optional environment filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, env?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as a state, which is one of the following:  - `new`: You created the flag fewer than seven days ago and it has never been requested. - `active`: LaunchDarkly is receiving requests for this flag, but there are either multiple variations configured, or it is toggled off, or there have been changes to configuration in the past seven days. - `inactive`: You created the feature flag more than seven days ago, and hasn\'t been requested within the past seven days. - `launched`: LaunchDarkly is receiving requests for this flag, it is toggled on, there is only one variation configured, and there have been no changes to configuration in the past seven days.  To learn more, read [Flag statuses](https://docs.launchdarkly.com/home/code/flag-status). 
     * @summary List feature flag statuses
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all feature flags in the given project. By default, each flag includes configurations for each environment. You can filter environments with the `env` query parameter. For example, setting `env=production` restricts the returned configurations to just your production environment. You can also filter feature flags by tag with the `tag` query parameter.  > #### Recommended use > > This endpoint can return a large amount of information. We recommend using some or all of these query parameters to decrease response time and overall payload size: `limit`, `env`, `query`, and `filter=creationDate`.  ### Filtering flags  You can filter on certain fields using the `filter` query parameter. For example, setting `filter=query:dark-mode,tags:beta+test` matches flags with the string `dark-mode` in their key or name, ignoring case, which also have the tags `beta` and `test`.  The `filter` query parameter supports the following arguments:  | Filter argument       | Description | Example              | |-----------------------|-------------|----------------------| | `applicationEvaluated`  | A string. It filters the list to flags that are evaluated in the application with the given key. | `filter=applicationEvaluated:com.launchdarkly.cafe` | | `archived`              | (deprecated) A boolean value. It filters the list to archived flags. | Use `filter=state:archived` instead | | `contextKindsEvaluated` | A `+`-separated list of context kind keys. It filters the list to flags which have been evaluated in the past 30 days for all of the context kinds in the list. | `filter=contextKindsEvaluated:user+application` | | `contextKindTargeted`   | A string. It filters the list to flags that are targeting the given context kind key. | `filter=contextKindTargeted:user` | | `codeReferences.max`    | An integer value. Use `0` to return flags that do not have code references. | `filter=codeReferences.max:0` | | `codeReferences.min`    | An integer value. Use `1` to return flags that do have code references. | `filter=codeReferences.min:1` | | `creationDate`          | An object with an optional `before` field whose value is Unix time in milliseconds. It filters the list to flags created before the date. | `filter=creationDate:{\"before\":1690527600000}` | | `evaluated`             | An object that contains a key of `after` and a value in Unix time in milliseconds. It filters the list to all flags that have been evaluated since the time you specify, in the environment provided. This filter requires the `filterEnv` filter. | `filter=evaluation:{\"after\":1690527600000}` | | `filterEnv`             | A string with the key of a valid environment. You must use this field for filters that are environment-specific. If there are multiple environment-specific filters, you only need to include this field once. | `filter=evaluated:{\"after\": 1590768455282},filterEnv:production,status:active` | | `followerId`            | A valid member ID. It filters the list to flags that are being followed by this member. |  `filter=followerId:12ab3c45de678910abc12345` | | `hasDataExport`         | A boolean value. It filters the list to flags that are exporting data in the specified environment. This includes flags that are exporting data from Experimentation. This filter requires the `filterEnv` filter. | `filter=hasDataExport:true,filterEnv:production` | | `hasExperiment`         | A boolean value. It filters the list to flags that are used in an experiment. | `filter=hasExperiment:true` | | `maintainerId`          | A valid member ID. It filters the list to flags that are maintained by this member. | `filter=maintainerId:12ab3c45de678910abc12345` | | `maintainerTeamKey`     | A string. It filters the list to flags that are maintained by the team with this key. | `filter=maintainerTeamKey:example-team-key` | | `query`                 | A string. It filters the list to flags that include the specified string in their key or name. It is not case sensitive. | `filter=query:example` | | `state`                 | A string, either `live`, `deprecated`, or `archived`. It filters the list to flags in this state. | `filter=state:archived` | | `sdkAvailability`       | A string, one of `client`, `mobile`, `anyClient`, `server`. Using `client` filters the list to flags whose client-side SDK availability is set to use the client-side ID. Using `mobile` filters to flags set to use the mobile key. Using `anyClient` filters to flags set to use either the client-side ID or the mobile key. Using `server` filters to flags set to use neither, that is, to flags only available in server-side SDKs.  | `filter=sdkAvailability:client` | | `segmentTargeted`       | A string. It filters the list to flags that target the segment with this key. This filter requires the `filterEnv` filter. | `filter=segmentTargeted:example-segment-key,filterEnv:production` | | `status`                | A string, either `new`, `inactive`, `active`, or `launched`. It filters the list to flags with the specified status in the specified environment. This filter requires the `filterEnv` filter. | `filter=status:active,filterEnv:production` | | `tags`                  | A `+`-separated list of tags. It filters the list to flags that have all of the tags in the list. | `filter=tags:beta+test` | | `type`                  | A string, either `temporary` or `permanent`. It filters the list to flags with the specified type. | `filter=type:permanent` |  The documented values for the `filter` query are prior to URL encoding. For example, the `+` in `filter=tags:beta+test` must be encoded to `%2B`.  By default, this endpoint returns all flags. You can page through the list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the returned `_links` field. These links will not be present if the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page.  ### Sorting flags  You can sort flags based on the following fields:  - `creationDate` sorts by the creation date of the flag. - `key` sorts by the key of the flag. - `maintainerId` sorts by the flag maintainer. - `name` sorts by flag name. - `tags` sorts by tags. - `targetingModifiedDate` sorts by the date that the flag\'s targeting rules were last modified in a given environment. It must be used with `env` parameter and it can not be combined with any other sort. If multiple `env` values are provided, it will perform sort using the first one. For example, `sort=-targetingModifiedDate&env=production&env=staging` returns results sorted by `targetingModifiedDate` for the `production` environment. - `type` sorts by flag type  All fields are sorted in ascending order by default. To sort in descending order, prefix the field with a dash ( - ). For example, `sort=-name` sorts the response by flag name in descending order.  ### Expanding response  LaunchDarkly supports the `expand` query param to include additional fields in the response, with the following fields:  - `codeReferences` includes code references for the feature flag - `evaluation` includes evaluation information within returned environments, including which context kinds the flag has been evaluated for in the past 30 days - `migrationSettings` includes migration settings information within the flag and within returned environments. These settings are only included for migration flags, that is, where `purpose` is `migration`.  For example, `expand=evaluation` includes the `evaluation` field in the response.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response, and default cohort information is included in the `fallthrough` property of a flag\'s response. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
     * @summary List feature flags
     * @param {string} projectKey The project key
     * @param {string} [env] Filter configurations by environment
     * @param {string} [tag] Filter feature flags by tag
     * @param {number} [limit] The number of feature flags to return. Defaults to -1, which returns all flags
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {boolean} [archived] Deprecated, use &#x60;filter&#x3D;archived:true&#x60; instead. A boolean to filter the list to archived flags. When this is absent, only unarchived flags will be returned
     * @param {boolean} [summary] By default, flags do _not_ include their lists of prerequisites, targets, or rules for each environment. Set &#x60;summary&#x3D;0&#x60; to include these fields for each flag returned.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order. Read the endpoint description for a full list of available sort fields.
     * @param {boolean} [compare] A boolean to filter results by only flags that have differences between environments
     * @param {string} [expand] A comma-separated list of fields to expand in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlags(projectKey: string, env?: string, tag?: string, limit?: number, offset?: number, archived?: boolean, summary?: boolean, filter?: string, sort?: string, compare?: boolean, expand?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlags(projectKey, env, tag, limit, offset, archived, summary, filter, sort, compare, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a context for removal from individual targeting on a feature flag. The flag must already individually target the context.  You can add, update, or remove a scheduled removal date. You can only schedule a context for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring targets.  <details> <summary>Click to expand instructions for <strong>updating expiring targets</strong></summary>  #### addExpiringTarget  Adds a date and time that LaunchDarkly will remove the context from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### updateExpiringTarget  Updates the date and time that LaunchDarkly will remove the context from the flag\'s individual targeting  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey` * `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"value\": 1754006460000,     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  #### removeExpiringTarget  Removes the scheduled removal of the context from the flag\'s individual targeting. The context will remain part of the flag\'s individual targeting until you explicitly remove it, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `contextKey`: The context key for the context to remove from individual targeting * `contextKind`: The kind of context represented by the `contextKey`  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"variationId\": \"4254742c-71ae-411f-a992-43b18a51afe0\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\"   }] } ```  </details> 
     * @summary Update expiring context targets on feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {PatchFlagsRequest} patchFlagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchExpiringTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).patchExpiringTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring context targets on feature flag](/tag/Feature-flags#operation/patchExpiringTargets) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Schedule a target for removal from individual targeting on a feature flag. The flag must already serve a variation to specific targets based on their key.  You can add, update, or remove a scheduled removal date. You can only schedule a target for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting * `version`: (Optional) The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until you explicitly remove them, or until you schedule another removal.  ##### Parameters  * `variationId`: ID of a variation on the flag * `userKey`: The user key for the user to remove from individual targeting  </details> 
     * @summary Update expiring user targets on feature flag
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {PatchFlagsRequest} patchFlagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, patchFlagsRequest: PatchFlagsRequest, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, patchFlagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a partial update to a feature flag. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a feature flag  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating feature flags takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required for some instructions only) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object. The body of a single semantic patch can contain many different instructions.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating feature flags.  <details> <summary>Click to expand instructions for <strong>turning flags on and off</strong></summary>  These instructions require the `environmentKey` parameter.  #### turnFlagOff  Sets the flag\'s targeting state to **Off**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOff\" } ] } ```  #### turnFlagOn  Sets the flag\'s targeting state to **On**.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"turnFlagOn\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>working with targeting and variations</strong></summary>  These instructions require the `environmentKey` parameter.  Several of the instructions for working with targeting and variations require flag rule IDs, variation IDs, or clause IDs as parameters. Each of these are returned as part of the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) response. The flag rule ID is the `_id` field of each element in the `rules` array within each environment listed in the `environments` object. The variation ID is the `_id` field in each element of the `variations` array. The clause ID is the `_id` field of each element of the `clauses` array within the `rules` array within each environment listed in the `environments` object.  #### addClauses  Adds the given clauses to the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauses\": [{    \"contextKind\": \"user\",    \"attribute\": \"country\",    \"op\": \"in\",    \"negate\": false,    \"values\": [\"USA\", \"Canada\"]   }]  }] } ```  #### addPrerequisite  Adds the flag indicated by `key` with variation `variationId` as a prerequisite to the flag in the path parameter.  ##### Parameters  - `key`: Flag key of the prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addPrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addRule  Adds a new targeting rule to the flag. The rule may contain `clauses` and serve the variation that `variationId` indicates, or serve a percentage rollout that `rolloutWeights`, `rolloutBucketBy`, and `rolloutContextKind` indicate.  If you set `beforeRuleId`, this adds the new rule before the indicated rule. Otherwise, adds the new rule to the end of the list.  ##### Parameters  - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case. - `beforeRuleId`: (Optional) ID of a flag rule. - Either   - `variationId`: ID of a variation of the flag.    or    - `rolloutWeights`: (Optional) Map of `variationId` to weight, in thousandths of a percent (0-100000).   - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`.   - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }]   }] } ```  Here\'s an example that uses a percentage rollout:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"addRule\",     \"clauses\": [{       \"contextKind\": \"organization\",       \"attribute\": \"located_in\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Sweden\", \"Norway\"]     }],     \"rolloutContextKind\": \"organization\",     \"rolloutWeights\": {       \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation       \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation     }   }] } ```  #### addTargets  Adds context keys to the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Returns an error if this causes the flag to target the same context key in multiple variations.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addUserTargets  Adds user keys to the individual user targets for the variation that `variationId` specifies. Returns an error if this causes the flag to target the same user key in multiple variations. If you are working with contexts, use `addTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### addValuesToClause  Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"addValuesToClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### addVariation  Adds a variation to the flag.  ##### Parameters  - `value`: The variation value. - `name`: (Optional) The variation name. - `description`: (Optional) A description for the variation.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"addVariation\", \"value\": 20, \"name\": \"New variation\" } ] } ```  #### clearTargets  Removes all individual targets from the variation that `variationId` specifies. This includes both user and non-user targets.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### clearUserTargets  Removes all individual user targets from the variation that `variationId` specifies. If you are working with contexts, use `clearTargets` instead of this instruction.  ##### Parameters  - `variationId`: ID of a variation on the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"clearUserTargets\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### removeClauses  Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseIds`: Array of IDs of clauses in the rule.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeClauses\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseIds\": [\"10a58772-3121-400f-846b-b8a04e8944ed\", \"36a461dc-235e-4b08-97b9-73ce9365873e\"]  }] } ```  #### removePrerequisite  Removes the prerequisite flag indicated by `key`. Does nothing if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removePrerequisite\", \"key\": \"prereq-flag-key-123abc\" } ] } ```  #### removeRule  Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.  ##### Parameters  - `ruleId`: ID of a rule in the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"removeRule\", \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\" } ] } ```  #### removeTargets  Removes context keys from the individual context targets for the context kind that `contextKind` specifies and the variation that `variationId` specifies. Does nothing if the flag does not target the context keys.  ##### Parameters  - `values`: List of context keys. - `contextKind`: (Optional) Context kind to target, defaults to `user` - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeTargets\",   \"values\": [\"context-key-123abc\", \"context-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeUserTargets  Removes user keys from the individual user targets for the variation that `variationId` specifies. Does nothing if the flag does not target the user keys. If you are working with contexts, use `removeTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys. - `variationId`: ID of a flag variation.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeUserTargets\",   \"values\": [\"user-key-123abc\", \"user-key-456def\"],   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### removeValuesFromClause  Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`. Does not update the context kind, attribute, or operator.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `values`: Array of strings, case sensitive.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"removeValuesFromClause\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"clauseId\": \"10a58772-3121-400f-846b-b8a04e8944ed\",   \"values\": [\"beta_testers\"]  }] } ```  #### removeVariation  Removes a variation from the flag.  ##### Parameters  - `variationId`: ID of a variation of the flag to remove.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"removeVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### reorderRules  Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules on the flag.  ##### Parameters  - `ruleIds`: Array of IDs of all rules in the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"reorderRules\",   \"ruleIds\": [\"a902ef4a-2faf-4eaf-88e1-ecc356708a29\", \"63c238d1-835d-435e-8f21-c8d5e40b2a3d\"]  }] } ```  #### replacePrerequisites  Removes all existing prerequisites and replaces them with the list you provide.  ##### Parameters  - `prerequisites`: A list of prerequisites. Each item in the list must include a flag `key` and `variationId`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replacePrerequisites\",       \"prerequisites\": [         {           \"key\": \"prereq-flag-key-123abc\",           \"variationId\": \"10a58772-3121-400f-846b-b8a04e8944ed\"         },         {           \"key\": \"another-prereq-flag-key-456def\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\"         }       ]     }   ] } ```  #### replaceRules  Removes all targeting rules for the flag and replaces them with the list you provide.  ##### Parameters  - `rules`: A list of rules.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceRules\",       \"rules\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"description\": \"My new rule\",           \"clauses\": [             {               \"contextKind\": \"user\",               \"attribute\": \"segmentMatch\",               \"op\": \"segmentMatch\",               \"values\": [\"test\"]             }           ],           \"trackEvents\": true         }       ]     }   ] } ```  #### replaceTargets  Removes all existing targeting and replaces it with the list of targets you provide.  ##### Parameters  - `targets`: A list of context targeting. Each item in the list includes an optional `contextKind` that defaults to `user`, a required `variationId`, and a required list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceTargets\",       \"targets\": [         {           \"contextKind\": \"user\",           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\"]         },         {           \"contextKind\": \"device\",           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"device-key-456def\"]         }       ]     }       ] } ```  #### replaceUserTargets  Removes all existing user targeting and replaces it with the list of targets you provide. In the list of targets, you must include a target for each of the flag\'s variations. If you are working with contexts, use `replaceTargets` instead of this instruction.  ##### Parameters  - `targets`: A list of user targeting. Each item in the list must include a `variationId` and a list of `values`.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [     {       \"kind\": \"replaceUserTargets\",       \"targets\": [         {           \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\",           \"values\": [\"user-key-123abc\", \"user-key-456def\"]         },         {           \"variationId\": \"e5830889-1ec5-4b0c-9cc9-c48790090c43\",           \"values\": [\"user-key-789ghi\"]         }       ]     }   ] } ```  #### updateClause  Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `clauseId`: ID of a clause in that rule. - `clause`: New `clause` object, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [{     \"kind\": \"updateClause\",     \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",     \"clauseId\": \"10c7462a-2062-45ba-a8bb-dfb3de0f8af5\",     \"clause\": {       \"contextKind\": \"user\",       \"attribute\": \"country\",       \"op\": \"in\",       \"negate\": false,       \"values\": [\"Mexico\", \"Canada\"]     }   }] } ```  #### updateDefaultVariation  Updates the default on or off variation of the flag.  ##### Parameters  - `onVariationValue`: (Optional) The value of the variation of the new on variation. - `offVariationValue`: (Optional) The value of the variation of the new off variation  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateDefaultVariation\", \"OnVariationValue\": true, \"OffVariationValue\": false } ] } ```  #### updateFallthroughVariationOrRollout  Updates the default or \"fallthrough\" rule for the flag, which the flag serves when a context matches none of the targeting rules. The rule can serve either the variation that `variationId` indicates, or a percentage rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `variationId`: ID of a variation of the flag.  or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example that uses a `variationId`:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  Here\'s an example that uses a percentage rollout:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateFallthroughVariationOrRollout\",   \"rolloutContextKind\": \"user\",   \"rolloutWeights\": {    \"2f43f67c-3e4e-4945-a18a-26559378ca00\": 15000, // serve 15% this variation    \"e5830889-1ec5-4b0c-9cc9-c48790090c43\": 85000  // serve 85% this variation   }  }] } ```  #### updateOffVariation  Updates the default off variation to `variationId`. The flag serves the default off variation when the flag\'s targeting is **Off**.  ##### Parameters  - `variationId`: ID of a variation of the flag.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateOffVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\" } ] } ```  #### updatePrerequisite  Changes the prerequisite flag that `key` indicates to use the variation that `variationId` indicates. Returns an error if this prerequisite does not exist.  ##### Parameters  - `key`: Flag key of an existing prerequisite flag. - `variationId`: ID of a variation of the prerequisite flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updatePrerequisite\",   \"key\": \"example-prereq-flag-key\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateRuleDescription  Updates the description of the feature flag rule.  ##### Parameters  - `description`: The new human-readable description for this rule. - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleDescription\",   \"description\": \"New rule description\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\"  }] } ```  #### updateRuleTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag associated with this rule.  ##### Parameters  - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the flag. - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleTrackEvents\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"trackEvents\": true  }] } ```  #### updateRuleVariationOrRollout  Updates what `ruleId` serves when its clauses evaluate to true. The rule can serve either the variation that `variationId` indicates, or a percent rollout that `rolloutWeights` and `rolloutBucketBy` indicate.  ##### Parameters  - `ruleId`: ID of a rule in the flag. - `variationId`: ID of a variation of the flag.    or  - `rolloutWeights`: Map of `variationId` to weight, in thousandths of a percent (0-100000). - `rolloutBucketBy`: (Optional) Context attribute available in the specified `rolloutContextKind`. - `rolloutContextKind`: (Optional) Context kind, defaults to `user`  Here\'s an example:  ```json {  \"environmentKey\": \"environment-key-123abc\",  \"instructions\": [{   \"kind\": \"updateRuleVariationOrRollout\",   \"ruleId\": \"a902ef4a-2faf-4eaf-88e1-ecc356708a29\",   \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\"  }] } ```  #### updateTrackEvents  Updates whether or not LaunchDarkly tracks events for the feature flag, for all rules.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEvents\", \"trackEvents\": true } ] } ```  #### updateTrackEventsFallthrough  Updates whether or not LaunchDarkly tracks events for the feature flag, for the default rule.  ##### Parameters  - `trackEvents`: Whether or not events are tracked.  Here\'s an example:  ```json {   \"environmentKey\": \"environment-key-123abc\",   \"instructions\": [ { \"kind\": \"updateTrackEventsFallthrough\", \"trackEvents\": true } ] } ```  #### updateVariation  Updates a variation of the flag.  ##### Parameters  - `variationId`: The ID of the variation to update. - `name`: (Optional) The updated variation name. - `value`: (Optional) The updated variation value. - `description`: (Optional) The updated variation description.  Here\'s an example:  ```json {  \"instructions\": [ { \"kind\": \"updateVariation\", \"variationId\": \"2f43f67c-3e4e-4945-a18a-26559378ca00\", \"value\": 20 } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating flag settings</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### addCustomProperties  Adds a new custom property to the feature flag. Custom properties are used to associate feature flags with LaunchDarkly integrations. For example, if you create an integration with an issue tracking service, you may want to associate a flag with a list of issues related to a feature\'s development.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{   \"kind\": \"addCustomProperties\",   \"key\": \"example-custom-property\",   \"name\": \"Example custom property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### addTags  Adds tags to the feature flag.  ##### Parameters  - `values`: A list of tags to add.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"addTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### makeFlagPermanent  Marks the feature flag as permanent. LaunchDarkly does not prompt you to remove permanent flags, even if one variation is rolled out to all your customers.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagPermanent\" } ] } ```  #### makeFlagTemporary  Marks the feature flag as temporary.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"makeFlagTemporary\" } ] } ```  #### removeCustomProperties  Removes the associated values from a custom property. If all the associated values are removed, this instruction also removes the custom property.  ##### Parameters   - `key`: The custom property key.  - `values`: A list of the associated values to remove from the custom property.  ```json {  \"instructions\": [{   \"kind\": \"replaceCustomProperties\",   \"key\": \"example-custom-property\",   \"values\": [\"value1\", \"value2\"]  }] } ```  #### removeMaintainer  Removes the flag\'s maintainer. To set a new maintainer, use the flag\'s **Settings** tab in the LaunchDarkly user interface.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeMaintainer\" } ] } ```  #### removeTags  Removes tags from the feature flag.  ##### Parameters  - `values`: A list of tags to remove.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"removeTags\", \"values\": [\"tag1\", \"tag2\"] } ] } ```  #### replaceCustomProperties  Replaces the existing associated values for a custom property with the new values.  ##### Parameters   - `key`: The custom property key.  - `name`: The custom property name.  - `values`: A list of the new associated values for the custom property.  Here\'s an example:  ```json {  \"instructions\": [{    \"kind\": \"replaceCustomProperties\",    \"key\": \"example-custom-property\",    \"name\": \"Example custom property\",    \"values\": [\"value1\", \"value2\"]  }] } ```  #### turnOffClientSideAvailability  Turns off client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn off availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOffClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### turnOnClientSideAvailability  Turns on client-side SDK availability for the flag. This is equivalent to unchecking the **SDKs using Mobile Key** and/or **SDKs using client-side ID** boxes for the flag. If you\'re using a client-side or mobile SDK, you must expose your feature flags in order for the client-side or mobile SDKs to evaluate them.  ##### Parameters  - `value`: Use \"usingMobileKey\" to turn on availability for mobile SDKs. Use \"usingEnvironmentId\" to turn on availability for client-side SDKs.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"turnOnClientSideAvailability\", \"value\": \"usingMobileKey\" } ] } ```  #### updateDescription  Updates the feature flag description.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateDescription\", \"value\": \"Updated flag description\" } ] } ``` #### updateMaintainerMember  Updates the maintainer of the flag to an existing member and removes the existing maintainer.  ##### Parameters  - `value`: The ID of the member.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerMember\", \"value\": \"61e9b714fd47591727db558a\" } ] } ```  #### updateMaintainerTeam  Updates the maintainer of the flag to an existing team and removes the existing maintainer.  ##### Parameters  - `value`: The key of the team.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateMaintainerTeam\", \"value\": \"example-team-key\" } ] } ```  #### updateName  Updates the feature flag name.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"updateName\", \"value\": \"Updated flag name\" } ] } ```  </details><br />  <details> <summary>Click to expand instructions for <strong>updating the flag lifecycle</strong></summary>  These instructions do not require the `environmentKey` parameter. They make changes that apply to the flag across all environments.  #### archiveFlag  Archives the feature flag. This retires it from LaunchDarkly without deleting it. You cannot archive a flag that is a prerequisite of other flags.  ```json {   \"instructions\": [ { \"kind\": \"archiveFlag\" } ] } ```  #### deleteFlag  Deletes the feature flag and its rules. You cannot restore a deleted flag. If this flag is requested again, the flag value defined in code will be returned for all contexts.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deleteFlag\" } ] } ```  #### deprecateFlag  Deprecates the feature flag. This hides it from the live flags list without archiving or deleting it.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"deprecateFlag\" } ] } ```  #### restoreDeprecatedFlag  Restores the feature flag if it was previously deprecated.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreDeprecatedFlag\" } ] } ```  #### restoreFlag  Restores the feature flag if it was previously archived.  Here\'s an example:  ```json {   \"instructions\": [ { \"kind\": \"restoreFlag\" } ] } ```  </details>  ### Using JSON patches on a feature flag  If you do not include the semantic patch header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  In the JSON patch representation, use a JSON pointer in the `path` element to describe what field to change. Use the [Get feature flag](/tag/Feature-flags#operation/getFeatureFlag) endpoint to find the field you want to update.  There are a few special cases to keep in mind when determining the value of the `path` element:    * To add an individual target to a specific variation if the flag variation already has individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/0/values/-\",       \"value\": \"TestClient10\"     }   ]   ```    * To add an individual target to a specific variation if the flag variation does not already have individual targets, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/environments/devint/targets/-\",       \"value\": { \"variation\": 0, \"values\": [\"TestClient10\"] }     }   ]   ```    * To add a flag to a release pipeline, the path for the JSON patch operation is:    ```json   [     {       \"op\": \"add\",       \"path\": \"/releasePipelineKey\",       \"value\": \"example-release-pipeline-key\"     }   ]   ```  ### Required approvals If a request attempts to alter a flag configuration in an environment where approvals are required for the flag, the request will fail with a 405. Changes to the flag configuration in that environment will require creating an [approval request](/tag/Approvals) or a [workflow](/tag/Workflows).  ### Conflicts If a flag configuration change made through this endpoint would cause a pending scheduled change or approval request to fail, this endpoint will return a 400. You can ignore this check by adding an `ignoreConflicts` query parameter set to `true`.  ### Migration flags For migration flags, the cohort information is included in the `rules` property of a flag\'s response. You can update cohorts by updating `rules`. Default cohort information is included in the `fallthrough` property of a flag\'s response. You can update the default cohort by updating `fallthrough`. When you update the rollout for a cohort or the default cohort through the API, provide a rollout instead of a single `variationId`. To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags). 
     * @summary Update feature flag
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key. The key identifies the flag in your code.
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchFeatureFlag(projectKey: string, featureFlagKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).patchFeatureFlag(projectKey, featureFlagKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a feature flag with the given name, key, and variations.  <details> <summary>Click to expand instructions for <strong>creating a migration flag</strong></summary>  ### Creating a migration flag  When you create a migration flag, the variations are pre-determined based on the number of stages in the migration.  To create a migration flag, omit the `variations` and `defaults` information. Instead, provide a `purpose` of `migration`, and `migrationSettings`. If you create a migration flag with six stages, `contextKind` is required. Otherwise, it should be omitted.  Here\'s an example:  ```json {   \"key\": \"flag-key-123\",   \"purpose\": \"migration\",   \"migrationSettings\": {     \"stageCount\": 6,     \"contextKind\": \"account\"   } } ```  To learn more, read [Migration Flags](https://docs.launchdarkly.com/home/flag-types/migration-flags).  </details> 
     * @summary Create a feature flag
     * @param {string} projectKey The project key
     * @param {FeatureFlagBody} featureFlagBody 
     * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code. For example, setting &#x60;clone&#x3D;flagKey&#x60; copies the full targeting configuration for all environments, including &#x60;on/off&#x60; state, from the original flag to the new flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public postFeatureFlag(projectKey: string, featureFlagBody: FeatureFlagBody, clone?: string, options?: AxiosRequestConfig) {
        return FeatureFlagsApiFp(this.configuration).postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureFlagsBetaApi - axios parameter creator
 * @export
 */
export const FeatureFlagsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlags: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDependentFlags', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getDependentFlags', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/dependent-flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlagsByEnv: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getDependentFlagsByEnv', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the migration safety issues that are associated with the POSTed flag patch. The patch must use the semantic patch format for updating feature flags.
         * @summary Get migration safety issues
         * @param {string} projectKey The project key
         * @param {string} flagKey The migration flag key
         * @param {string} environmentKey The environment key
         * @param {FlagSempatch} flagSempatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMigrationSafetyIssues: async (projectKey: string, flagKey: string, environmentKey: string, flagSempatch: FlagSempatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postMigrationSafetyIssues', 'projectKey', projectKey)
            // verify required parameter 'flagKey' is not null or undefined
            assertParamExists('postMigrationSafetyIssues', 'flagKey', flagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postMigrationSafetyIssues', 'environmentKey', environmentKey)
            // verify required parameter 'flagSempatch' is not null or undefined
            assertParamExists('postMigrationSafetyIssues', 'flagSempatch', flagSempatch)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{flagKey}/environments/{environmentKey}/migration-safety-issues`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"flagKey"}}`, encodeURIComponent(String(flagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagSempatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsBetaApi - functional programming interface
 * @export
 */
export const FeatureFlagsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureFlagsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentFlags(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiEnvironmentDependentFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentFlags(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependentFlagsByEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the migration safety issues that are associated with the POSTed flag patch. The patch must use the semantic patch format for updating feature flags.
         * @summary Get migration safety issues
         * @param {string} projectKey The project key
         * @param {string} flagKey The migration flag key
         * @param {string} environmentKey The environment key
         * @param {FlagSempatch} flagSempatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMigrationSafetyIssues(projectKey: string, flagKey: string, environmentKey: string, flagSempatch: FlagSempatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MigrationSafetyIssueRep>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMigrationSafetyIssues(projectKey, flagKey, environmentKey, flagSempatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureFlagsBetaApi - factory interface
 * @export
 */
export const FeatureFlagsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureFlagsBetaApiFp(configuration)
    return {
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlags(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<MultiEnvironmentDependentFlags> {
            return localVarFp.getDependentFlags(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
         * @summary List dependent feature flags by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<DependentFlagsByEnvironment> {
            return localVarFp.getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the migration safety issues that are associated with the POSTed flag patch. The patch must use the semantic patch format for updating feature flags.
         * @summary Get migration safety issues
         * @param {string} projectKey The project key
         * @param {string} flagKey The migration flag key
         * @param {string} environmentKey The environment key
         * @param {FlagSempatch} flagSempatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMigrationSafetyIssues(projectKey: string, flagKey: string, environmentKey: string, flagSempatch: FlagSempatch, options?: any): AxiosPromise<Array<MigrationSafetyIssueRep>> {
            return localVarFp.postMigrationSafetyIssues(projectKey, flagKey, environmentKey, flagSempatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsBetaApi - object-oriented interface
 * @export
 * @class FeatureFlagsBetaApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsBetaApi extends BaseAPI {
    /**
     * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
     * @summary List dependent feature flags
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsBetaApi
     */
    public getDependentFlags(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsBetaApiFp(this.configuration).getDependentFlags(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Flag prerequisites is an Enterprise feature > > Flag prerequisites is available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact Sales](https://launchdarkly.com/contact-sales/).  List dependent flags across all environments for the flag specified in the path parameters. A dependent flag is a flag that uses another flag as a prerequisite. To learn more, read [Flag prerequisites](https://docs.launchdarkly.com/home/targeting-flags/prerequisites). 
     * @summary List dependent feature flags by environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsBetaApi
     */
    public getDependentFlagsByEnv(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FeatureFlagsBetaApiFp(this.configuration).getDependentFlagsByEnv(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the migration safety issues that are associated with the POSTed flag patch. The patch must use the semantic patch format for updating feature flags.
     * @summary Get migration safety issues
     * @param {string} projectKey The project key
     * @param {string} flagKey The migration flag key
     * @param {string} environmentKey The environment key
     * @param {FlagSempatch} flagSempatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsBetaApi
     */
    public postMigrationSafetyIssues(projectKey: string, flagKey: string, environmentKey: string, flagSempatch: FlagSempatch, options?: AxiosRequestConfig) {
        return FeatureFlagsBetaApiFp(this.configuration).postMigrationSafetyIssues(projectKey, flagKey, environmentKey, flagSempatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlagLinksBetaApi - axios parameter creator
 * @export
 */
export const FlagLinksBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlagLink: async (projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('createFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'flagLinkPost' is not null or undefined
            assertParamExists('createFlagLink', 'flagLinkPost', flagLinkPost)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagLinkPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagLink: async (projectKey: string, featureFlagKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFlagLink', 'id', id)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagLinks: async (projectKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagLinks', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagLinks', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag link. Updating a flag link uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlagLink: async (projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('updateFlagLink', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('updateFlagLink', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFlagLink', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('updateFlagLink', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/flag-links/projects/{projectKey}/flags/{featureFlagKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlagLinksBetaApi - functional programming interface
 * @export
 */
export const FlagLinksBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlagLinksBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlagLink(projectKey, featureFlagKey, flagLinkPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagLink(projectKey, featureFlagKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagLinks(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagLinks(projectKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag link. Updating a flag link uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagLinkRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlagLinksBetaApi - factory interface
 * @export
 */
export const FlagLinksBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlagLinksBetaApiFp(configuration)
    return {
        /**
         * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
         * @summary Create flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {FlagLinkPost} flagLinkPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: any): AxiosPromise<FlagLinkRep> {
            return localVarFp.createFlagLink(projectKey, featureFlagKey, flagLinkPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a flag link by ID or key.
         * @summary Delete flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID or Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagLink(projectKey, featureFlagKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all flag links.
         * @summary List flag links
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagLinks(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<FlagLinkCollectionRep> {
            return localVarFp.getFlagLinks(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag link. Updating a flag link uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag link
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag link ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<FlagLinkRep> {
            return localVarFp.updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlagLinksBetaApi - object-oriented interface
 * @export
 * @class FlagLinksBetaApi
 * @extends {BaseAPI}
 */
export class FlagLinksBetaApi extends BaseAPI {
    /**
     * Create a new flag link. Flag links let you reference external resources and associate them with your flags.
     * @summary Create flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {FlagLinkPost} flagLinkPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public createFlagLink(projectKey: string, featureFlagKey: string, flagLinkPost: FlagLinkPost, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).createFlagLink(projectKey, featureFlagKey, flagLinkPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a flag link by ID or key.
     * @summary Delete flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag link ID or Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public deleteFlagLink(projectKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).deleteFlagLink(projectKey, featureFlagKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all flag links.
     * @summary List flag links
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public getFlagLinks(projectKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).getFlagLinks(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag link. Updating a flag link uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update flag link
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag link ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagLinksBetaApi
     */
    public updateFlagLink(projectKey: string, featureFlagKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return FlagLinksBetaApiFp(this.configuration).updateFlagLink(projectKey, featureFlagKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlagTriggersApi - axios parameter creator
 * @export
 */
export const FlagTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'triggerPost' is not null or undefined
            assertParamExists('createTriggerWorkflow', 'triggerPost', triggerPost)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(triggerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTriggerWorkflow', 'id', id)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflowById: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTriggerWorkflowById', 'id', id)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflows: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getTriggerWorkflows', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  <details> <summary>Click to expand instructions for <strong>updating flag triggers</strong></summary>  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the existing action with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"cycleTriggerUrl\" }] } ```  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"disableTrigger\" }] } ```  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"enableTrigger\" }] } ```  </details> 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTriggerWorkflow: async (projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'id', id)
            // verify required parameter 'flagTriggerInput' is not null or undefined
            assertParamExists('patchTriggerWorkflow', 'flagTriggerInput', flagTriggerInput)
            const localVarPath = `/api/v2/flags/{projectKey}/{featureFlagKey}/triggers/{environmentKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagTriggerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlagTriggersApi - functional programming interface
 * @export
 */
export const FlagTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlagTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  <details> <summary>Click to expand instructions for <strong>updating flag triggers</strong></summary>  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the existing action with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"cycleTriggerUrl\" }] } ```  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"disableTrigger\" }] } ```  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"enableTrigger\" }] } ```  </details> 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerWorkflowRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlagTriggersApi - factory interface
 * @export
 */
export const FlagTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlagTriggersApiFp(configuration)
    return {
        /**
         * Create a new flag trigger.
         * @summary Create flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {TriggerPost} triggerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a flag trigger by ID.
         * @summary Delete flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a flag trigger by ID.
         * @summary Get flag trigger by ID
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The flag trigger ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all flag triggers.
         * @summary List flag triggers
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<TriggerWorkflowCollectionRep> {
            return localVarFp.getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  <details> <summary>Click to expand instructions for <strong>updating flag triggers</strong></summary>  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the existing action with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"cycleTriggerUrl\" }] } ```  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"disableTrigger\" }] } ```  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"enableTrigger\" }] } ```  </details> 
         * @summary Update flag trigger
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} id The flag trigger ID
         * @param {FlagTriggerInput} flagTriggerInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: any): AxiosPromise<TriggerWorkflowRep> {
            return localVarFp.patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlagTriggersApi - object-oriented interface
 * @export
 * @class FlagTriggersApi
 * @extends {BaseAPI}
 */
export class FlagTriggersApi extends BaseAPI {
    /**
     * Create a new flag trigger.
     * @summary Create flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {TriggerPost} triggerPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public createTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, triggerPost: TriggerPost, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).createTriggerWorkflow(projectKey, environmentKey, featureFlagKey, triggerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a flag trigger by ID.
     * @summary Delete flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag trigger ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public deleteTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).deleteTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a flag trigger by ID.
     * @summary Get flag trigger by ID
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The flag trigger ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public getTriggerWorkflowById(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).getTriggerWorkflowById(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all flag triggers.
     * @summary List flag triggers
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public getTriggerWorkflows(projectKey: string, environmentKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).getTriggerWorkflows(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag trigger. Updating a flag trigger uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating flag triggers.  <details> <summary>Click to expand instructions for <strong>updating flag triggers</strong></summary>  #### replaceTriggerActionInstructions  Removes the existing trigger action and replaces it with the new instructions.  ##### Parameters  - `value`: An array of the new `kind`s of actions to perform when triggering. Supported flag actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the existing action with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceTriggerActionInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### cycleTriggerUrl  Generates a new URL for this trigger. You must update any clients using the trigger to use this new URL.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"cycleTriggerUrl\" }] } ```  #### disableTrigger  Disables the trigger. This saves the trigger configuration, but the trigger stops running. To re-enable, use `enableTrigger`.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"disableTrigger\" }] } ```  #### enableTrigger  Enables the trigger. If you previously disabled the trigger, it begins running again.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"enableTrigger\" }] } ```  </details> 
     * @summary Update flag trigger
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} id The flag trigger ID
     * @param {FlagTriggerInput} flagTriggerInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlagTriggersApi
     */
    public patchTriggerWorkflow(projectKey: string, environmentKey: string, featureFlagKey: string, id: string, flagTriggerInput: FlagTriggerInput, options?: AxiosRequestConfig) {
        return FlagTriggersApiFp(this.configuration).patchTriggerWorkflow(projectKey, environmentKey, featureFlagKey, id, flagTriggerInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FollowFlagsApi - axios parameter creator
 * @export
 */
export const FollowFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag. Reader roles can only remove themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'environmentKey', environmentKey)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteFlagFollowers', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagFollowers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByProjEnv: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFollowersByProjEnv', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFollowersByProjEnv', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/followers`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag. Reader roles can only add themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagFollowers: async (projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('putFlagFollowers', 'environmentKey', environmentKey)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('putFlagFollowers', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/followers/{memberId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowFlagsApi - functional programming interface
 * @export
 */
export const FollowFlagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowFlagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag. Reader roles can only remove themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagFollowersGetRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagFollowers(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagFollowersByProjEnvGetRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersByProjEnv(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag. Reader roles can only add themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FollowFlagsApi - factory interface
 * @export
 */
export const FollowFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowFlagsApiFp(configuration)
    return {
        /**
         * Remove a member as a follower to a flag in a project and environment
         * @summary Remove a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to remove as a follower of the flag. Reader roles can only remove themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of members following a flag in a project and environment
         * @summary Get followers of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FlagFollowersGetRep> {
            return localVarFp.getFlagFollowers(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get followers of all flags in a given environment and project
         * @summary Get followers of all flags in a given project and environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: any): AxiosPromise<FlagFollowersByProjEnvGetRep> {
            return localVarFp.getFollowersByProjEnv(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a member as a follower to a flag in a project and environment
         * @summary Add a member as a follower of a flag in a project and environment
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} memberId The memberId of the member to add as a follower of the flag. Reader roles can only add themselves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowFlagsApi - object-oriented interface
 * @export
 * @class FollowFlagsApi
 * @extends {BaseAPI}
 */
export class FollowFlagsApi extends BaseAPI {
    /**
     * Remove a member as a follower to a flag in a project and environment
     * @summary Remove a member as a follower of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} memberId The memberId of the member to remove as a follower of the flag. Reader roles can only remove themselves.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public deleteFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).deleteFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of members following a flag in a project and environment
     * @summary Get followers of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public getFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).getFlagFollowers(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get followers of all flags in a given environment and project
     * @summary Get followers of all flags in a given project and environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public getFollowersByProjEnv(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).getFollowersByProjEnv(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a member as a follower to a flag in a project and environment
     * @summary Add a member as a follower of a flag in a project and environment
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} memberId The memberId of the member to add as a follower of the flag. Reader roles can only add themselves.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowFlagsApi
     */
    public putFlagFollowers(projectKey: string, featureFlagKey: string, environmentKey: string, memberId: string, options?: AxiosRequestConfig) {
        return FollowFlagsApiFp(this.configuration).putFlagFollowers(projectKey, featureFlagKey, environmentKey, memberId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsChartsBetaApi - axios parameter creator
 * @export
 */
export const InsightsChartsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get deployment frequency chart data. Engineering insights displays deployment frequency data in the [deployment frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/deployment).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to deployment frequency  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment frequency chart data
         * @param {string} [projectKey] The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;kind&#x60;
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentFrequencyChart: async (projectKey?: string, environmentKey?: string, applicationKey?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/engineering-insights/charts/deployments/frequency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (bucketType !== undefined) {
                localVarQueryParameter['bucketType'] = bucketType;
            }

            if (bucketMs !== undefined) {
                localVarQueryParameter['bucketMs'] = bucketMs;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get flag status chart data. To learn more, read [Using the flag status chart](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health#using-the-flag-status-chart).
         * @summary Get flag status chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagStatusChart: async (projectKey: string, environmentKey: string, applicationKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagStatusChart', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagStatusChart', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/charts/flags/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lead time chart data. The engineering insights UI displays lead time data in the [lead time metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/lead-time).
         * @summary Get lead time chart data
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;stage&#x60;. Default: &#x60;stage&#x60;.
         * @param {string} [expand] Options: &#x60;metrics&#x60;, &#x60;percentiles&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadTimeChart: async (projectKey: string, environmentKey?: string, applicationKey?: string, from?: number, to?: number, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getLeadTimeChart', 'projectKey', projectKey)
            const localVarPath = `/api/v2/engineering-insights/charts/lead-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (bucketType !== undefined) {
                localVarQueryParameter['bucketType'] = bucketType;
            }

            if (bucketMs !== undefined) {
                localVarQueryParameter['bucketMs'] = bucketMs;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get release frequency chart data. Engineering insights displays release frequency data in the [release frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/release).
         * @summary Get release frequency chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [groupBy] Property to group results by. Options: &#x60;impact&#x60;
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseFrequencyChart: async (projectKey: string, environmentKey: string, applicationKey?: string, hasExperiments?: boolean, global?: string, groupBy?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getReleaseFrequencyChart', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getReleaseFrequencyChart', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/charts/releases/frequency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (hasExperiments !== undefined) {
                localVarQueryParameter['hasExperiments'] = hasExperiments;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (bucketType !== undefined) {
                localVarQueryParameter['bucketType'] = bucketType;
            }

            if (bucketMs !== undefined) {
                localVarQueryParameter['bucketMs'] = bucketMs;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stale flags chart data. Engineering insights displays stale flags data in the [flag health metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to stale flags  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get stale flags chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [groupBy] Property to group results by. Options: &#x60;maintainer&#x60;
         * @param {string} [maintainerId] Comma-separated list of individual maintainers to filter results.
         * @param {string} [maintainerTeamKey] Comma-separated list of team maintainer keys to filter results.
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaleFlagsChart: async (projectKey: string, environmentKey: string, applicationKey?: string, groupBy?: string, maintainerId?: string, maintainerTeamKey?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getStaleFlagsChart', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getStaleFlagsChart', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/charts/flags/stale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (maintainerId !== undefined) {
                localVarQueryParameter['maintainerId'] = maintainerId;
            }

            if (maintainerTeamKey !== undefined) {
                localVarQueryParameter['maintainerTeamKey'] = maintainerTeamKey;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsChartsBetaApi - functional programming interface
 * @export
 */
export const InsightsChartsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsChartsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get deployment frequency chart data. Engineering insights displays deployment frequency data in the [deployment frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/deployment).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to deployment frequency  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment frequency chart data
         * @param {string} [projectKey] The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;kind&#x60;
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeploymentFrequencyChart(projectKey?: string, environmentKey?: string, applicationKey?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeploymentFrequencyChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get flag status chart data. To learn more, read [Using the flag status chart](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health#using-the-flag-status-chart).
         * @summary Get flag status chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagStatusChart(projectKey: string, environmentKey: string, applicationKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagStatusChart(projectKey, environmentKey, applicationKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get lead time chart data. The engineering insights UI displays lead time data in the [lead time metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/lead-time).
         * @summary Get lead time chart data
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;stage&#x60;. Default: &#x60;stage&#x60;.
         * @param {string} [expand] Options: &#x60;metrics&#x60;, &#x60;percentiles&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeadTimeChart(projectKey: string, environmentKey?: string, applicationKey?: string, from?: number, to?: number, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadTimeChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get release frequency chart data. Engineering insights displays release frequency data in the [release frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/release).
         * @summary Get release frequency chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [groupBy] Property to group results by. Options: &#x60;impact&#x60;
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleaseFrequencyChart(projectKey: string, environmentKey: string, applicationKey?: string, hasExperiments?: boolean, global?: string, groupBy?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReleaseFrequencyChart(projectKey, environmentKey, applicationKey, hasExperiments, global, groupBy, from, to, bucketType, bucketMs, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stale flags chart data. Engineering insights displays stale flags data in the [flag health metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to stale flags  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get stale flags chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [groupBy] Property to group results by. Options: &#x60;maintainer&#x60;
         * @param {string} [maintainerId] Comma-separated list of individual maintainers to filter results.
         * @param {string} [maintainerTeamKey] Comma-separated list of team maintainer keys to filter results.
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaleFlagsChart(projectKey: string, environmentKey: string, applicationKey?: string, groupBy?: string, maintainerId?: string, maintainerTeamKey?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsChart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaleFlagsChart(projectKey, environmentKey, applicationKey, groupBy, maintainerId, maintainerTeamKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsChartsBetaApi - factory interface
 * @export
 */
export const InsightsChartsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsChartsBetaApiFp(configuration)
    return {
        /**
         * Get deployment frequency chart data. Engineering insights displays deployment frequency data in the [deployment frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/deployment).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to deployment frequency  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment frequency chart data
         * @param {string} [projectKey] The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;kind&#x60;
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentFrequencyChart(projectKey?: string, environmentKey?: string, applicationKey?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: any): AxiosPromise<InsightsChart> {
            return localVarFp.getDeploymentFrequencyChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get flag status chart data. To learn more, read [Using the flag status chart](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health#using-the-flag-status-chart).
         * @summary Get flag status chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagStatusChart(projectKey: string, environmentKey: string, applicationKey?: string, options?: any): AxiosPromise<InsightsChart> {
            return localVarFp.getFlagStatusChart(projectKey, environmentKey, applicationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get lead time chart data. The engineering insights UI displays lead time data in the [lead time metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/lead-time).
         * @summary Get lead time chart data
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;stage&#x60;. Default: &#x60;stage&#x60;.
         * @param {string} [expand] Options: &#x60;metrics&#x60;, &#x60;percentiles&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadTimeChart(projectKey: string, environmentKey?: string, applicationKey?: string, from?: number, to?: number, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: any): AxiosPromise<InsightsChart> {
            return localVarFp.getLeadTimeChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get release frequency chart data. Engineering insights displays release frequency data in the [release frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/release).
         * @summary Get release frequency chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [groupBy] Property to group results by. Options: &#x60;impact&#x60;
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
         * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseFrequencyChart(projectKey: string, environmentKey: string, applicationKey?: string, hasExperiments?: boolean, global?: string, groupBy?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, expand?: string, options?: any): AxiosPromise<InsightsChart> {
            return localVarFp.getReleaseFrequencyChart(projectKey, environmentKey, applicationKey, hasExperiments, global, groupBy, from, to, bucketType, bucketMs, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stale flags chart data. Engineering insights displays stale flags data in the [flag health metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to stale flags  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
         * @summary Get stale flags chart data
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [groupBy] Property to group results by. Options: &#x60;maintainer&#x60;
         * @param {string} [maintainerId] Comma-separated list of individual maintainers to filter results.
         * @param {string} [maintainerTeamKey] Comma-separated list of team maintainer keys to filter results.
         * @param {string} [expand] Options: &#x60;metrics&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaleFlagsChart(projectKey: string, environmentKey: string, applicationKey?: string, groupBy?: string, maintainerId?: string, maintainerTeamKey?: string, expand?: string, options?: any): AxiosPromise<InsightsChart> {
            return localVarFp.getStaleFlagsChart(projectKey, environmentKey, applicationKey, groupBy, maintainerId, maintainerTeamKey, expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsChartsBetaApi - object-oriented interface
 * @export
 * @class InsightsChartsBetaApi
 * @extends {BaseAPI}
 */
export class InsightsChartsBetaApi extends BaseAPI {
    /**
     * Get deployment frequency chart data. Engineering insights displays deployment frequency data in the [deployment frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/deployment).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to deployment frequency  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
     * @summary Get deployment frequency chart data
     * @param {string} [projectKey] The project key
     * @param {string} [environmentKey] The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
     * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
     * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;kind&#x60;
     * @param {string} [expand] Options: &#x60;metrics&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsChartsBetaApi
     */
    public getDeploymentFrequencyChart(projectKey?: string, environmentKey?: string, applicationKey?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsChartsBetaApiFp(this.configuration).getDeploymentFrequencyChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get flag status chart data. To learn more, read [Using the flag status chart](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health#using-the-flag-status-chart).
     * @summary Get flag status chart data
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsChartsBetaApi
     */
    public getFlagStatusChart(projectKey: string, environmentKey: string, applicationKey?: string, options?: AxiosRequestConfig) {
        return InsightsChartsBetaApiFp(this.configuration).getFlagStatusChart(projectKey, environmentKey, applicationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get lead time chart data. The engineering insights UI displays lead time data in the [lead time metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/lead-time).
     * @summary Get lead time chart data
     * @param {string} projectKey The project key
     * @param {string} [environmentKey] The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
     * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
     * @param {string} [groupBy] Options: &#x60;application&#x60;, &#x60;stage&#x60;. Default: &#x60;stage&#x60;.
     * @param {string} [expand] Options: &#x60;metrics&#x60;, &#x60;percentiles&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsChartsBetaApi
     */
    public getLeadTimeChart(projectKey: string, environmentKey?: string, applicationKey?: string, from?: number, to?: number, bucketType?: string, bucketMs?: number, groupBy?: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsChartsBetaApiFp(this.configuration).getLeadTimeChart(projectKey, environmentKey, applicationKey, from, to, bucketType, bucketMs, groupBy, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get release frequency chart data. Engineering insights displays release frequency data in the [release frequency metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/release).
     * @summary Get release frequency chart data
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
     * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
     * @param {string} [groupBy] Property to group results by. Options: &#x60;impact&#x60;
     * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [bucketType] Specify type of bucket. Options: &#x60;rolling&#x60;, &#x60;hour&#x60;, &#x60;day&#x60;. Default: &#x60;rolling&#x60;.
     * @param {number} [bucketMs] Duration of intervals for x-axis in milliseconds. Default value is one day (&#x60;86400000&#x60; milliseconds).
     * @param {string} [expand] Options: &#x60;metrics&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsChartsBetaApi
     */
    public getReleaseFrequencyChart(projectKey: string, environmentKey: string, applicationKey?: string, hasExperiments?: boolean, global?: string, groupBy?: string, from?: string, to?: string, bucketType?: string, bucketMs?: number, expand?: string, options?: AxiosRequestConfig) {
        return InsightsChartsBetaApiFp(this.configuration).getReleaseFrequencyChart(projectKey, environmentKey, applicationKey, hasExperiments, global, groupBy, from, to, bucketType, bucketMs, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stale flags chart data. Engineering insights displays stale flags data in the [flag health metric view](https://docs.launchdarkly.com/home/engineering-insights/metrics/flag-health).  ### Expanding the chart response  LaunchDarkly supports expanding the chart response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `metrics` includes details on the metrics related to stale flags  For example, use `?expand=metrics` to include the `metrics` field in the response. By default, this field is **not** included in the response. 
     * @summary Get stale flags chart data
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {string} [groupBy] Property to group results by. Options: &#x60;maintainer&#x60;
     * @param {string} [maintainerId] Comma-separated list of individual maintainers to filter results.
     * @param {string} [maintainerTeamKey] Comma-separated list of team maintainer keys to filter results.
     * @param {string} [expand] Options: &#x60;metrics&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsChartsBetaApi
     */
    public getStaleFlagsChart(projectKey: string, environmentKey: string, applicationKey?: string, groupBy?: string, maintainerId?: string, maintainerTeamKey?: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsChartsBetaApiFp(this.configuration).getStaleFlagsChart(projectKey, environmentKey, applicationKey, groupBy, maintainerId, maintainerTeamKey, expand, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsDeploymentsBetaApi - axios parameter creator
 * @export
 */
export const InsightsDeploymentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create deployment event
         * @summary Create deployment event
         * @param {PostDeploymentEventInput} postDeploymentEventInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentEvent: async (postDeploymentEventInput: PostDeploymentEventInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postDeploymentEventInput' is not null or undefined
            assertParamExists('createDeploymentEvent', 'postDeploymentEventInput', postDeploymentEventInput)
            const localVarPath = `/api/v2/engineering-insights/deployment-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postDeploymentEventInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a deployment by ID.  The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.  ### Expanding the deployment response  LaunchDarkly supports expanding the deployment response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment
         * @param {string} deploymentID The deployment ID
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (deploymentID: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentID' is not null or undefined
            assertParamExists('getDeployment', 'deploymentID', deploymentID)
            const localVarPath = `/api/v2/engineering-insights/deployments/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of deployments  ### Expanding the deployment collection response  LaunchDarkly supports expanding the deployment collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary List deployments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {string} [kind] The deployment kind
         * @param {string} [status] The deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments: async (projectKey: string, environmentKey: string, applicationKey?: string, limit?: number, expand?: string, from?: number, to?: number, after?: string, before?: string, kind?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getDeployments', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getDeployments', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a deployment by ID. Updating a deployment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.
         * @summary Update deployment
         * @param {string} deploymentID The deployment ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeployment: async (deploymentID: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentID' is not null or undefined
            assertParamExists('updateDeployment', 'deploymentID', deploymentID)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('updateDeployment', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/engineering-insights/deployments/{deploymentID}`
                .replace(`{${"deploymentID"}}`, encodeURIComponent(String(deploymentID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsDeploymentsBetaApi - functional programming interface
 * @export
 */
export const InsightsDeploymentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsDeploymentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create deployment event
         * @summary Create deployment event
         * @param {PostDeploymentEventInput} postDeploymentEventInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeploymentEvent(postDeploymentEventInput: PostDeploymentEventInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeploymentEvent(postDeploymentEventInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a deployment by ID.  The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.  ### Expanding the deployment response  LaunchDarkly supports expanding the deployment response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment
         * @param {string} deploymentID The deployment ID
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(deploymentID: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(deploymentID, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of deployments  ### Expanding the deployment collection response  LaunchDarkly supports expanding the deployment collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary List deployments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {string} [kind] The deployment kind
         * @param {string} [status] The deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployments(projectKey: string, environmentKey: string, applicationKey?: string, limit?: number, expand?: string, from?: number, to?: number, after?: string, before?: string, kind?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployments(projectKey, environmentKey, applicationKey, limit, expand, from, to, after, before, kind, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a deployment by ID. Updating a deployment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.
         * @summary Update deployment
         * @param {string} deploymentID The deployment ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeployment(deploymentID: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeployment(deploymentID, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsDeploymentsBetaApi - factory interface
 * @export
 */
export const InsightsDeploymentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsDeploymentsBetaApiFp(configuration)
    return {
        /**
         * Create deployment event
         * @summary Create deployment event
         * @param {PostDeploymentEventInput} postDeploymentEventInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeploymentEvent(postDeploymentEventInput: PostDeploymentEventInput, options?: any): AxiosPromise<void> {
            return localVarFp.createDeploymentEvent(postDeploymentEventInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a deployment by ID.  The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.  ### Expanding the deployment response  LaunchDarkly supports expanding the deployment response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary Get deployment
         * @param {string} deploymentID The deployment ID
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(deploymentID: string, expand?: string, options?: any): AxiosPromise<DeploymentRep> {
            return localVarFp.getDeployment(deploymentID, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of deployments  ### Expanding the deployment collection response  LaunchDarkly supports expanding the deployment collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
         * @summary List deployments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {string} [kind] The deployment kind
         * @param {string} [status] The deployment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(projectKey: string, environmentKey: string, applicationKey?: string, limit?: number, expand?: string, from?: number, to?: number, after?: string, before?: string, kind?: string, status?: string, options?: any): AxiosPromise<DeploymentCollectionRep> {
            return localVarFp.getDeployments(projectKey, environmentKey, applicationKey, limit, expand, from, to, after, before, kind, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a deployment by ID. Updating a deployment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.
         * @summary Update deployment
         * @param {string} deploymentID The deployment ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeployment(deploymentID: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<DeploymentRep> {
            return localVarFp.updateDeployment(deploymentID, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsDeploymentsBetaApi - object-oriented interface
 * @export
 * @class InsightsDeploymentsBetaApi
 * @extends {BaseAPI}
 */
export class InsightsDeploymentsBetaApi extends BaseAPI {
    /**
     * Create deployment event
     * @summary Create deployment event
     * @param {PostDeploymentEventInput} postDeploymentEventInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsDeploymentsBetaApi
     */
    public createDeploymentEvent(postDeploymentEventInput: PostDeploymentEventInput, options?: AxiosRequestConfig) {
        return InsightsDeploymentsBetaApiFp(this.configuration).createDeploymentEvent(postDeploymentEventInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a deployment by ID.  The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.  ### Expanding the deployment response  LaunchDarkly supports expanding the deployment response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
     * @summary Get deployment
     * @param {string} deploymentID The deployment ID
     * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsDeploymentsBetaApi
     */
    public getDeployment(deploymentID: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsDeploymentsBetaApiFp(this.configuration).getDeployment(deploymentID, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of deployments  ### Expanding the deployment collection response  LaunchDarkly supports expanding the deployment collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `pullRequests` includes details on all of the pull requests associated with each deployment * `flagReferences` includes details on all of the references to flags in each deployment  For example, use `?expand=pullRequests` to include the `pullRequests` field in the response. By default, this field is **not** included in the response. 
     * @summary List deployments
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
     * @param {string} [expand] Expand properties in response. Options: &#x60;pullRequests&#x60;, &#x60;flagReferences&#x60;
     * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [after] Identifier used for pagination
     * @param {string} [before] Identifier used for pagination
     * @param {string} [kind] The deployment kind
     * @param {string} [status] The deployment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsDeploymentsBetaApi
     */
    public getDeployments(projectKey: string, environmentKey: string, applicationKey?: string, limit?: number, expand?: string, from?: number, to?: number, after?: string, before?: string, kind?: string, status?: string, options?: AxiosRequestConfig) {
        return InsightsDeploymentsBetaApiFp(this.configuration).getDeployments(projectKey, environmentKey, applicationKey, limit, expand, from, to, after, before, kind, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a deployment by ID. Updating a deployment uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>The deployment ID is returned as part of the [List deployments](#operation/getDeployments) response. It is the `id` field of each element in the `items` array.
     * @summary Update deployment
     * @param {string} deploymentID The deployment ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsDeploymentsBetaApi
     */
    public updateDeployment(deploymentID: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return InsightsDeploymentsBetaApiFp(this.configuration).updateDeployment(deploymentID, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsFlagEventsBetaApi - axios parameter creator
 * @export
 */
export const InsightsFlagEventsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of flag events  ### Expanding the flag event collection response  LaunchDarkly supports expanding the flag event collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `experiments` includes details on all of the experiments run on each flag  For example, use `?expand=experiments` to include the `experiments` field in the response. By default, this field is **not** included in the response. 
         * @summary List flag events
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [query] Filter events by flag key
         * @param {string} [impactSize] Filter events by impact size. A small impact created a less than 20% change in the proportion of end users receiving one or more flag variations. A medium impact created between a 20%-80% change. A large impact created a more than 80% change. Options: &#x60;none&#x60;, &#x60;small&#x60;, &#x60;medium&#x60;, &#x60;large&#x60;
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [expand] Expand properties in response. Options: &#x60;experiments&#x60;
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagEvents: async (projectKey: string, environmentKey: string, applicationKey?: string, query?: string, impactSize?: string, hasExperiments?: boolean, global?: string, expand?: string, limit?: number, from?: number, to?: number, after?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagEvents', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagEvents', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/flag-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (impactSize !== undefined) {
                localVarQueryParameter['impactSize'] = impactSize;
            }

            if (hasExperiments !== undefined) {
                localVarQueryParameter['hasExperiments'] = hasExperiments;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsFlagEventsBetaApi - functional programming interface
 * @export
 */
export const InsightsFlagEventsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsFlagEventsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of flag events  ### Expanding the flag event collection response  LaunchDarkly supports expanding the flag event collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `experiments` includes details on all of the experiments run on each flag  For example, use `?expand=experiments` to include the `experiments` field in the response. By default, this field is **not** included in the response. 
         * @summary List flag events
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [query] Filter events by flag key
         * @param {string} [impactSize] Filter events by impact size. A small impact created a less than 20% change in the proportion of end users receiving one or more flag variations. A medium impact created between a 20%-80% change. A large impact created a more than 80% change. Options: &#x60;none&#x60;, &#x60;small&#x60;, &#x60;medium&#x60;, &#x60;large&#x60;
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [expand] Expand properties in response. Options: &#x60;experiments&#x60;
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagEvents(projectKey: string, environmentKey: string, applicationKey?: string, query?: string, impactSize?: string, hasExperiments?: boolean, global?: string, expand?: string, limit?: number, from?: number, to?: number, after?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagEventCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagEvents(projectKey, environmentKey, applicationKey, query, impactSize, hasExperiments, global, expand, limit, from, to, after, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsFlagEventsBetaApi - factory interface
 * @export
 */
export const InsightsFlagEventsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsFlagEventsBetaApiFp(configuration)
    return {
        /**
         * Get a list of flag events  ### Expanding the flag event collection response  LaunchDarkly supports expanding the flag event collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `experiments` includes details on all of the experiments run on each flag  For example, use `?expand=experiments` to include the `experiments` field in the response. By default, this field is **not** included in the response. 
         * @summary List flag events
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {string} [query] Filter events by flag key
         * @param {string} [impactSize] Filter events by impact size. A small impact created a less than 20% change in the proportion of end users receiving one or more flag variations. A medium impact created between a 20%-80% change. A large impact created a more than 80% change. Options: &#x60;none&#x60;, &#x60;small&#x60;, &#x60;medium&#x60;, &#x60;large&#x60;
         * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
         * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
         * @param {string} [expand] Expand properties in response. Options: &#x60;experiments&#x60;
         * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
         * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagEvents(projectKey: string, environmentKey: string, applicationKey?: string, query?: string, impactSize?: string, hasExperiments?: boolean, global?: string, expand?: string, limit?: number, from?: number, to?: number, after?: string, before?: string, options?: any): AxiosPromise<FlagEventCollectionRep> {
            return localVarFp.getFlagEvents(projectKey, environmentKey, applicationKey, query, impactSize, hasExperiments, global, expand, limit, from, to, after, before, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsFlagEventsBetaApi - object-oriented interface
 * @export
 * @class InsightsFlagEventsBetaApi
 * @extends {BaseAPI}
 */
export class InsightsFlagEventsBetaApi extends BaseAPI {
    /**
     * Get a list of flag events  ### Expanding the flag event collection response  LaunchDarkly supports expanding the flag event collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `experiments` includes details on all of the experiments run on each flag  For example, use `?expand=experiments` to include the `experiments` field in the response. By default, this field is **not** included in the response. 
     * @summary List flag events
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {string} [query] Filter events by flag key
     * @param {string} [impactSize] Filter events by impact size. A small impact created a less than 20% change in the proportion of end users receiving one or more flag variations. A medium impact created between a 20%-80% change. A large impact created a more than 80% change. Options: &#x60;none&#x60;, &#x60;small&#x60;, &#x60;medium&#x60;, &#x60;large&#x60;
     * @param {boolean} [hasExperiments] Filter events to those associated with an experiment (&#x60;true&#x60;) or without an experiment (&#x60;false&#x60;)
     * @param {string} [global] Filter to include or exclude global events. Default value is &#x60;include&#x60;. Options: &#x60;include&#x60;, &#x60;exclude&#x60;
     * @param {string} [expand] Expand properties in response. Options: &#x60;experiments&#x60;
     * @param {number} [limit] The number of deployments to return. Default is 20. Maximum allowed is 100.
     * @param {number} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {number} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [after] Identifier used for pagination
     * @param {string} [before] Identifier used for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsFlagEventsBetaApi
     */
    public getFlagEvents(projectKey: string, environmentKey: string, applicationKey?: string, query?: string, impactSize?: string, hasExperiments?: boolean, global?: string, expand?: string, limit?: number, from?: number, to?: number, after?: string, before?: string, options?: AxiosRequestConfig) {
        return InsightsFlagEventsBetaApiFp(this.configuration).getFlagEvents(projectKey, environmentKey, applicationKey, query, impactSize, hasExperiments, global, expand, limit, from, to, after, before, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsPullRequestsBetaApi - axios parameter creator
 * @export
 */
export const InsightsPullRequestsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of pull requests  ### Expanding the pull request collection response  LaunchDarkly supports expanding the pull request collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `deployments` includes details on all of the deployments associated with each pull request * `flagReferences` includes details on all of the references to flags in each pull request * `leadTime` includes details about the lead time of the pull request for each stage  For example, use `?expand=deployments` to include the `deployments` field in the response. By default, this field is **not** included in the response. 
         * @summary List pull requests
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] Required if you are using the &lt;code&gt;sort&lt;/code&gt; parameter\&#39;s &lt;code&gt;leadTime&lt;/code&gt; option to sort pull requests.
         * @param {string} [applicationKey] Filter the results to pull requests deployed to a comma separated list of applications
         * @param {string} [status] Filter results to pull requests with the given status. Options: &#x60;open&#x60;, &#x60;merged&#x60;, &#x60;closed&#x60;, &#x60;deployed&#x60;.
         * @param {string} [query] Filter list of pull requests by title or author
         * @param {number} [limit] The number of pull requests to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;deployments&#x60;, &#x60;flagReferences&#x60;, &#x60;leadTime&#x60;.
         * @param {string} [sort] Sort results. Requires the &#x60;environmentKey&#x60; to be set. Options: &#x60;leadTime&#x60; (asc) and &#x60;-leadTime&#x60; (desc). When query option is excluded, default sort is by created or merged date.
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequests: async (projectKey: string, environmentKey?: string, applicationKey?: string, status?: string, query?: string, limit?: number, expand?: string, sort?: string, from?: string, to?: string, after?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getPullRequests', 'projectKey', projectKey)
            const localVarPath = `/api/v2/engineering-insights/pull-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsPullRequestsBetaApi - functional programming interface
 * @export
 */
export const InsightsPullRequestsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsPullRequestsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of pull requests  ### Expanding the pull request collection response  LaunchDarkly supports expanding the pull request collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `deployments` includes details on all of the deployments associated with each pull request * `flagReferences` includes details on all of the references to flags in each pull request * `leadTime` includes details about the lead time of the pull request for each stage  For example, use `?expand=deployments` to include the `deployments` field in the response. By default, this field is **not** included in the response. 
         * @summary List pull requests
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] Required if you are using the &lt;code&gt;sort&lt;/code&gt; parameter\&#39;s &lt;code&gt;leadTime&lt;/code&gt; option to sort pull requests.
         * @param {string} [applicationKey] Filter the results to pull requests deployed to a comma separated list of applications
         * @param {string} [status] Filter results to pull requests with the given status. Options: &#x60;open&#x60;, &#x60;merged&#x60;, &#x60;closed&#x60;, &#x60;deployed&#x60;.
         * @param {string} [query] Filter list of pull requests by title or author
         * @param {number} [limit] The number of pull requests to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;deployments&#x60;, &#x60;flagReferences&#x60;, &#x60;leadTime&#x60;.
         * @param {string} [sort] Sort results. Requires the &#x60;environmentKey&#x60; to be set. Options: &#x60;leadTime&#x60; (asc) and &#x60;-leadTime&#x60; (desc). When query option is excluded, default sort is by created or merged date.
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequests(projectKey: string, environmentKey?: string, applicationKey?: string, status?: string, query?: string, limit?: number, expand?: string, sort?: string, from?: string, to?: string, after?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequestCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequests(projectKey, environmentKey, applicationKey, status, query, limit, expand, sort, from, to, after, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsPullRequestsBetaApi - factory interface
 * @export
 */
export const InsightsPullRequestsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsPullRequestsBetaApiFp(configuration)
    return {
        /**
         * Get a list of pull requests  ### Expanding the pull request collection response  LaunchDarkly supports expanding the pull request collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `deployments` includes details on all of the deployments associated with each pull request * `flagReferences` includes details on all of the references to flags in each pull request * `leadTime` includes details about the lead time of the pull request for each stage  For example, use `?expand=deployments` to include the `deployments` field in the response. By default, this field is **not** included in the response. 
         * @summary List pull requests
         * @param {string} projectKey The project key
         * @param {string} [environmentKey] Required if you are using the &lt;code&gt;sort&lt;/code&gt; parameter\&#39;s &lt;code&gt;leadTime&lt;/code&gt; option to sort pull requests.
         * @param {string} [applicationKey] Filter the results to pull requests deployed to a comma separated list of applications
         * @param {string} [status] Filter results to pull requests with the given status. Options: &#x60;open&#x60;, &#x60;merged&#x60;, &#x60;closed&#x60;, &#x60;deployed&#x60;.
         * @param {string} [query] Filter list of pull requests by title or author
         * @param {number} [limit] The number of pull requests to return. Default is 20. Maximum allowed is 100.
         * @param {string} [expand] Expand properties in response. Options: &#x60;deployments&#x60;, &#x60;flagReferences&#x60;, &#x60;leadTime&#x60;.
         * @param {string} [sort] Sort results. Requires the &#x60;environmentKey&#x60; to be set. Options: &#x60;leadTime&#x60; (asc) and &#x60;-leadTime&#x60; (desc). When query option is excluded, default sort is by created or merged date.
         * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
         * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
         * @param {string} [after] Identifier used for pagination
         * @param {string} [before] Identifier used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequests(projectKey: string, environmentKey?: string, applicationKey?: string, status?: string, query?: string, limit?: number, expand?: string, sort?: string, from?: string, to?: string, after?: string, before?: string, options?: any): AxiosPromise<PullRequestCollectionRep> {
            return localVarFp.getPullRequests(projectKey, environmentKey, applicationKey, status, query, limit, expand, sort, from, to, after, before, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsPullRequestsBetaApi - object-oriented interface
 * @export
 * @class InsightsPullRequestsBetaApi
 * @extends {BaseAPI}
 */
export class InsightsPullRequestsBetaApi extends BaseAPI {
    /**
     * Get a list of pull requests  ### Expanding the pull request collection response  LaunchDarkly supports expanding the pull request collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `deployments` includes details on all of the deployments associated with each pull request * `flagReferences` includes details on all of the references to flags in each pull request * `leadTime` includes details about the lead time of the pull request for each stage  For example, use `?expand=deployments` to include the `deployments` field in the response. By default, this field is **not** included in the response. 
     * @summary List pull requests
     * @param {string} projectKey The project key
     * @param {string} [environmentKey] Required if you are using the &lt;code&gt;sort&lt;/code&gt; parameter\&#39;s &lt;code&gt;leadTime&lt;/code&gt; option to sort pull requests.
     * @param {string} [applicationKey] Filter the results to pull requests deployed to a comma separated list of applications
     * @param {string} [status] Filter results to pull requests with the given status. Options: &#x60;open&#x60;, &#x60;merged&#x60;, &#x60;closed&#x60;, &#x60;deployed&#x60;.
     * @param {string} [query] Filter list of pull requests by title or author
     * @param {number} [limit] The number of pull requests to return. Default is 20. Maximum allowed is 100.
     * @param {string} [expand] Expand properties in response. Options: &#x60;deployments&#x60;, &#x60;flagReferences&#x60;, &#x60;leadTime&#x60;.
     * @param {string} [sort] Sort results. Requires the &#x60;environmentKey&#x60; to be set. Options: &#x60;leadTime&#x60; (asc) and &#x60;-leadTime&#x60; (desc). When query option is excluded, default sort is by created or merged date.
     * @param {string} [from] Unix timestamp in milliseconds. Default value is 7 days ago.
     * @param {string} [to] Unix timestamp in milliseconds. Default value is now.
     * @param {string} [after] Identifier used for pagination
     * @param {string} [before] Identifier used for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsPullRequestsBetaApi
     */
    public getPullRequests(projectKey: string, environmentKey?: string, applicationKey?: string, status?: string, query?: string, limit?: number, expand?: string, sort?: string, from?: string, to?: string, after?: string, before?: string, options?: AxiosRequestConfig) {
        return InsightsPullRequestsBetaApiFp(this.configuration).getPullRequests(projectKey, environmentKey, applicationKey, status, query, limit, expand, sort, from, to, after, before, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsRepositoriesBetaApi - axios parameter creator
 * @export
 */
export const InsightsRepositoriesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Associate repositories with projects
         * @summary Associate repositories with projects
         * @param {InsightsRepositoryProjectMappings} insightsRepositoryProjectMappings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateRepositoriesAndProjects: async (insightsRepositoryProjectMappings: InsightsRepositoryProjectMappings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightsRepositoryProjectMappings' is not null or undefined
            assertParamExists('associateRepositoriesAndProjects', 'insightsRepositoryProjectMappings', insightsRepositoryProjectMappings)
            const localVarPath = `/api/v2/engineering-insights/repositories/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightsRepositoryProjectMappings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove repository project association
         * @summary Remove repository project association
         * @param {string} repositoryKey The repository key
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryProject: async (repositoryKey: string, projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryKey' is not null or undefined
            assertParamExists('deleteRepositoryProject', 'repositoryKey', repositoryKey)
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteRepositoryProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/engineering-insights/repositories/{repositoryKey}/projects/{projectKey}`
                .replace(`{${"repositoryKey"}}`, encodeURIComponent(String(repositoryKey)))
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of repositories  ### Expanding the repository collection response  LaunchDarkly supports expanding the repository collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `projects` includes details on all of the LaunchDarkly projects associated with each repository  For example, use `?expand=projects` to include the `projects` field in the response. By default, this field is **not** included in the response. 
         * @summary List repositories
         * @param {string} [expand] Expand properties in response. Options: &#x60;projects&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsRepositories: async (expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/engineering-insights/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsRepositoriesBetaApi - functional programming interface
 * @export
 */
export const InsightsRepositoriesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsRepositoriesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Associate repositories with projects
         * @summary Associate repositories with projects
         * @param {InsightsRepositoryProjectMappings} insightsRepositoryProjectMappings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associateRepositoriesAndProjects(insightsRepositoryProjectMappings: InsightsRepositoryProjectMappings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsRepositoryProjectCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associateRepositoriesAndProjects(insightsRepositoryProjectMappings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove repository project association
         * @summary Remove repository project association
         * @param {string} repositoryKey The repository key
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryProject(repositoryKey: string, projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryProject(repositoryKey, projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of repositories  ### Expanding the repository collection response  LaunchDarkly supports expanding the repository collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `projects` includes details on all of the LaunchDarkly projects associated with each repository  For example, use `?expand=projects` to include the `projects` field in the response. By default, this field is **not** included in the response. 
         * @summary List repositories
         * @param {string} [expand] Expand properties in response. Options: &#x60;projects&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsightsRepositories(expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsRepositoryCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsightsRepositories(expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsRepositoriesBetaApi - factory interface
 * @export
 */
export const InsightsRepositoriesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsRepositoriesBetaApiFp(configuration)
    return {
        /**
         * Associate repositories with projects
         * @summary Associate repositories with projects
         * @param {InsightsRepositoryProjectMappings} insightsRepositoryProjectMappings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateRepositoriesAndProjects(insightsRepositoryProjectMappings: InsightsRepositoryProjectMappings, options?: any): AxiosPromise<InsightsRepositoryProjectCollection> {
            return localVarFp.associateRepositoriesAndProjects(insightsRepositoryProjectMappings, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove repository project association
         * @summary Remove repository project association
         * @param {string} repositoryKey The repository key
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryProject(repositoryKey: string, projectKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepositoryProject(repositoryKey, projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of repositories  ### Expanding the repository collection response  LaunchDarkly supports expanding the repository collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `projects` includes details on all of the LaunchDarkly projects associated with each repository  For example, use `?expand=projects` to include the `projects` field in the response. By default, this field is **not** included in the response. 
         * @summary List repositories
         * @param {string} [expand] Expand properties in response. Options: &#x60;projects&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsRepositories(expand?: string, options?: any): AxiosPromise<InsightsRepositoryCollection> {
            return localVarFp.getInsightsRepositories(expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsRepositoriesBetaApi - object-oriented interface
 * @export
 * @class InsightsRepositoriesBetaApi
 * @extends {BaseAPI}
 */
export class InsightsRepositoriesBetaApi extends BaseAPI {
    /**
     * Associate repositories with projects
     * @summary Associate repositories with projects
     * @param {InsightsRepositoryProjectMappings} insightsRepositoryProjectMappings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsRepositoriesBetaApi
     */
    public associateRepositoriesAndProjects(insightsRepositoryProjectMappings: InsightsRepositoryProjectMappings, options?: AxiosRequestConfig) {
        return InsightsRepositoriesBetaApiFp(this.configuration).associateRepositoriesAndProjects(insightsRepositoryProjectMappings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove repository project association
     * @summary Remove repository project association
     * @param {string} repositoryKey The repository key
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsRepositoriesBetaApi
     */
    public deleteRepositoryProject(repositoryKey: string, projectKey: string, options?: AxiosRequestConfig) {
        return InsightsRepositoriesBetaApiFp(this.configuration).deleteRepositoryProject(repositoryKey, projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of repositories  ### Expanding the repository collection response  LaunchDarkly supports expanding the repository collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `projects` includes details on all of the LaunchDarkly projects associated with each repository  For example, use `?expand=projects` to include the `projects` field in the response. By default, this field is **not** included in the response. 
     * @summary List repositories
     * @param {string} [expand] Expand properties in response. Options: &#x60;projects&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsRepositoriesBetaApi
     */
    public getInsightsRepositories(expand?: string, options?: AxiosRequestConfig) {
        return InsightsRepositoriesBetaApiFp(this.configuration).getInsightsRepositories(expand, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightsScoresBetaApi - axios parameter creator
 * @export
 */
export const InsightsScoresBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create insight group
         * @summary Create insight group
         * @param {PostInsightGroupParams} postInsightGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInsightGroup: async (postInsightGroupParams: PostInsightGroupParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postInsightGroupParams' is not null or undefined
            assertParamExists('createInsightGroup', 'postInsightGroupParams', postInsightGroupParams)
            const localVarPath = `/api/v2/engineering-insights/insights/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postInsightGroupParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete insight group
         * @summary Delete insight group
         * @param {string} insightGroupKey The insight group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInsightGroup: async (insightGroupKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightGroupKey' is not null or undefined
            assertParamExists('deleteInsightGroup', 'insightGroupKey', insightGroupKey)
            const localVarPath = `/api/v2/engineering-insights/insights/groups/{insightGroupKey}`
                .replace(`{${"insightGroupKey"}}`, encodeURIComponent(String(insightGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight group  ### Expanding the insight group response  LaunchDarkly supports expanding the insight group response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for this group * `environment` includes details on each environment associated with this group  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary Get insight group
         * @param {string} insightGroupKey The insight group key
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightGroup: async (insightGroupKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightGroupKey' is not null or undefined
            assertParamExists('getInsightGroup', 'insightGroupKey', insightGroupKey)
            const localVarPath = `/api/v2/engineering-insights/insights/groups/{insightGroupKey}`
                .replace(`{${"insightGroupKey"}}`, encodeURIComponent(String(insightGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List groups for which you are collecting insights  ### Expanding the insight groups collection response  LaunchDarkly supports expanding the insight groups collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for each group * `environment` includes details on each environment associated with each group * `metadata` includes counts of the number of insight groups with particular indicators, such as \"execellent,\" \"good,\" \"fair,\" and so on.  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary List insight groups
         * @param {number} [limit] The number of insight groups to return. Default is 20. Must be between 1 and 20 inclusive.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Sort flag list by field. Prefix field with &lt;code&gt;-&lt;/code&gt; to sort in descending order. Allowed fields: name
         * @param {string} [query] Filter list of insights groups by name.
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;, &#x60;metadata&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightGroups: async (limit?: number, offset?: number, sort?: string, query?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/engineering-insights/insights/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return insights scores, based on the given parameters. This data is also used in engineering insights metrics views.
         * @summary Get insight scores
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsScores: async (projectKey: string, environmentKey: string, applicationKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getInsightsScores', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getInsightsScores', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/engineering-insights/insights/scores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectKey !== undefined) {
                localVarQueryParameter['projectKey'] = projectKey;
            }

            if (environmentKey !== undefined) {
                localVarQueryParameter['environmentKey'] = environmentKey;
            }

            if (applicationKey !== undefined) {
                localVarQueryParameter['applicationKey'] = applicationKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an insight group. Updating an insight group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch insight group
         * @param {string} insightGroupKey The insight group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchInsightGroup: async (insightGroupKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'insightGroupKey' is not null or undefined
            assertParamExists('patchInsightGroup', 'insightGroupKey', insightGroupKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchInsightGroup', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/engineering-insights/insights/groups/{insightGroupKey}`
                .replace(`{${"insightGroupKey"}}`, encodeURIComponent(String(insightGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsScoresBetaApi - functional programming interface
 * @export
 */
export const InsightsScoresBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsScoresBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create insight group
         * @summary Create insight group
         * @param {PostInsightGroupParams} postInsightGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInsightGroup(postInsightGroupParams: PostInsightGroupParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInsightGroup(postInsightGroupParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete insight group
         * @summary Delete insight group
         * @param {string} insightGroupKey The insight group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInsightGroup(insightGroupKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInsightGroup(insightGroupKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get insight group  ### Expanding the insight group response  LaunchDarkly supports expanding the insight group response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for this group * `environment` includes details on each environment associated with this group  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary Get insight group
         * @param {string} insightGroupKey The insight group key
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsightGroup(insightGroupKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsightGroup(insightGroupKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List groups for which you are collecting insights  ### Expanding the insight groups collection response  LaunchDarkly supports expanding the insight groups collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for each group * `environment` includes details on each environment associated with each group * `metadata` includes counts of the number of insight groups with particular indicators, such as \"execellent,\" \"good,\" \"fair,\" and so on.  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary List insight groups
         * @param {number} [limit] The number of insight groups to return. Default is 20. Must be between 1 and 20 inclusive.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Sort flag list by field. Prefix field with &lt;code&gt;-&lt;/code&gt; to sort in descending order. Allowed fields: name
         * @param {string} [query] Filter list of insights groups by name.
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;, &#x60;metadata&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsightGroups(limit?: number, offset?: number, sort?: string, query?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightGroupCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsightGroups(limit, offset, sort, query, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return insights scores, based on the given parameters. This data is also used in engineering insights metrics views.
         * @summary Get insight scores
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsightsScores(projectKey: string, environmentKey: string, applicationKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightScores>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsightsScores(projectKey, environmentKey, applicationKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an insight group. Updating an insight group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch insight group
         * @param {string} insightGroupKey The insight group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchInsightGroup(insightGroupKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchInsightGroup(insightGroupKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsScoresBetaApi - factory interface
 * @export
 */
export const InsightsScoresBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsScoresBetaApiFp(configuration)
    return {
        /**
         * Create insight group
         * @summary Create insight group
         * @param {PostInsightGroupParams} postInsightGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInsightGroup(postInsightGroupParams: PostInsightGroupParams, options?: any): AxiosPromise<InsightGroup> {
            return localVarFp.createInsightGroup(postInsightGroupParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete insight group
         * @summary Delete insight group
         * @param {string} insightGroupKey The insight group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInsightGroup(insightGroupKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInsightGroup(insightGroupKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight group  ### Expanding the insight group response  LaunchDarkly supports expanding the insight group response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for this group * `environment` includes details on each environment associated with this group  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary Get insight group
         * @param {string} insightGroupKey The insight group key
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightGroup(insightGroupKey: string, expand?: string, options?: any): AxiosPromise<InsightGroup> {
            return localVarFp.getInsightGroup(insightGroupKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * List groups for which you are collecting insights  ### Expanding the insight groups collection response  LaunchDarkly supports expanding the insight groups collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for each group * `environment` includes details on each environment associated with each group * `metadata` includes counts of the number of insight groups with particular indicators, such as \"execellent,\" \"good,\" \"fair,\" and so on.  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
         * @summary List insight groups
         * @param {number} [limit] The number of insight groups to return. Default is 20. Must be between 1 and 20 inclusive.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Sort flag list by field. Prefix field with &lt;code&gt;-&lt;/code&gt; to sort in descending order. Allowed fields: name
         * @param {string} [query] Filter list of insights groups by name.
         * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;, &#x60;metadata&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightGroups(limit?: number, offset?: number, sort?: string, query?: string, expand?: string, options?: any): AxiosPromise<InsightGroupCollection> {
            return localVarFp.getInsightGroups(limit, offset, sort, query, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Return insights scores, based on the given parameters. This data is also used in engineering insights metrics views.
         * @summary Get insight scores
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [applicationKey] Comma separated list of application keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsScores(projectKey: string, environmentKey: string, applicationKey?: string, options?: any): AxiosPromise<InsightScores> {
            return localVarFp.getInsightsScores(projectKey, environmentKey, applicationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an insight group. Updating an insight group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Patch insight group
         * @param {string} insightGroupKey The insight group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchInsightGroup(insightGroupKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<InsightGroup> {
            return localVarFp.patchInsightGroup(insightGroupKey, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsScoresBetaApi - object-oriented interface
 * @export
 * @class InsightsScoresBetaApi
 * @extends {BaseAPI}
 */
export class InsightsScoresBetaApi extends BaseAPI {
    /**
     * Create insight group
     * @summary Create insight group
     * @param {PostInsightGroupParams} postInsightGroupParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public createInsightGroup(postInsightGroupParams: PostInsightGroupParams, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).createInsightGroup(postInsightGroupParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete insight group
     * @summary Delete insight group
     * @param {string} insightGroupKey The insight group key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public deleteInsightGroup(insightGroupKey: string, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).deleteInsightGroup(insightGroupKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight group  ### Expanding the insight group response  LaunchDarkly supports expanding the insight group response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for this group * `environment` includes details on each environment associated with this group  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
     * @summary Get insight group
     * @param {string} insightGroupKey The insight group key
     * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public getInsightGroup(insightGroupKey: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).getInsightGroup(insightGroupKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List groups for which you are collecting insights  ### Expanding the insight groups collection response  LaunchDarkly supports expanding the insight groups collection response to include additional fields.  To expand the response, append the `expand` query parameter and include the following:  * `scores` includes details on all of the scores used in the engineering insights metrics views for each group * `environment` includes details on each environment associated with each group * `metadata` includes counts of the number of insight groups with particular indicators, such as \"execellent,\" \"good,\" \"fair,\" and so on.  For example, use `?expand=scores` to include the `scores` field in the response. By default, this field is **not** included in the response. 
     * @summary List insight groups
     * @param {number} [limit] The number of insight groups to return. Default is 20. Must be between 1 and 20 inclusive.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [sort] Sort flag list by field. Prefix field with &lt;code&gt;-&lt;/code&gt; to sort in descending order. Allowed fields: name
     * @param {string} [query] Filter list of insights groups by name.
     * @param {string} [expand] Options: &#x60;scores&#x60;, &#x60;environment&#x60;, &#x60;metadata&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public getInsightGroups(limit?: number, offset?: number, sort?: string, query?: string, expand?: string, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).getInsightGroups(limit, offset, sort, query, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return insights scores, based on the given parameters. This data is also used in engineering insights metrics views.
     * @summary Get insight scores
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [applicationKey] Comma separated list of application keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public getInsightsScores(projectKey: string, environmentKey: string, applicationKey?: string, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).getInsightsScores(projectKey, environmentKey, applicationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an insight group. Updating an insight group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Patch insight group
     * @param {string} insightGroupKey The insight group key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsScoresBetaApi
     */
    public patchInsightGroup(insightGroupKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return InsightsScoresBetaApiFp(this.configuration).patchInsightGroup(insightGroupKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationAuditLogSubscriptionsApi - axios parameter creator
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (integrationKey: string, subscriptionPost: SubscriptionPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('createSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'subscriptionPost' is not null or undefined
            assertParamExists('createSubscription', 'subscriptionPost', subscriptionPost)
            const localVarPath = `/api/v2/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription: async (integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('deleteSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubscription', 'id', id)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByID: async (integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getSubscriptionByID', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionByID', 'id', id)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (integrationKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getSubscriptions', 'integrationKey', integrationKey)
            const localVarPath = `/api/v2/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an audit log subscription configuration. Updating an audit log subscription uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('updateSubscription', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscription', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('updateSubscription', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/integrations/{integrationKey}/{id}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationAuditLogSubscriptionsApi - functional programming interface
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationAuditLogSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(integrationKey, subscriptionPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscription(integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionByID(integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionByID(integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(integrationKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integrations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(integrationKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an audit log subscription configuration. Updating an audit log subscription uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(integrationKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationAuditLogSubscriptionsApi - factory interface
 * @export
 */
export const IntegrationAuditLogSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationAuditLogSubscriptionsApiFp(configuration)
    return {
        /**
         * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
         * @summary Create audit log subscription
         * @param {string} integrationKey The integration key
         * @param {SubscriptionPost} subscriptionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: any): AxiosPromise<Integration> {
            return localVarFp.createSubscription(integrationKey, subscriptionPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an audit log subscription.
         * @summary Delete audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(integrationKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscription(integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an audit log subscription by ID.
         * @summary Get audit log subscription by ID
         * @param {string} integrationKey The integration key
         * @param {string} id The subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByID(integrationKey: string, id: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.getSubscriptionByID(integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all audit log subscriptions associated with a given integration.
         * @summary Get audit log subscriptions by integration
         * @param {string} integrationKey The integration key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(integrationKey: string, options?: any): AxiosPromise<Integrations> {
            return localVarFp.getSubscriptions(integrationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an audit log subscription configuration. Updating an audit log subscription uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update audit log subscription
         * @param {string} integrationKey The integration key
         * @param {string} id The ID of the audit log subscription
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Integration> {
            return localVarFp.updateSubscription(integrationKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationAuditLogSubscriptionsApi - object-oriented interface
 * @export
 * @class IntegrationAuditLogSubscriptionsApi
 * @extends {BaseAPI}
 */
export class IntegrationAuditLogSubscriptionsApi extends BaseAPI {
    /**
     * Create an audit log subscription.<br /><br />For each subscription, you must specify the set of resources you wish to subscribe to audit log notifications for. You can describe these resources using a custom role policy. To learn more, read [Custom role concepts](https://docs.launchdarkly.com/home/members/role-concepts).
     * @summary Create audit log subscription
     * @param {string} integrationKey The integration key
     * @param {SubscriptionPost} subscriptionPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public createSubscription(integrationKey: string, subscriptionPost: SubscriptionPost, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).createSubscription(integrationKey, subscriptionPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an audit log subscription.
     * @summary Delete audit log subscription
     * @param {string} integrationKey The integration key
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public deleteSubscription(integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).deleteSubscription(integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an audit log subscription by ID.
     * @summary Get audit log subscription by ID
     * @param {string} integrationKey The integration key
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public getSubscriptionByID(integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).getSubscriptionByID(integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all audit log subscriptions associated with a given integration.
     * @summary Get audit log subscriptions by integration
     * @param {string} integrationKey The integration key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public getSubscriptions(integrationKey: string, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).getSubscriptions(integrationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an audit log subscription configuration. Updating an audit log subscription uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update audit log subscription
     * @param {string} integrationKey The integration key
     * @param {string} id The ID of the audit log subscription
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationAuditLogSubscriptionsApi
     */
    public updateSubscription(integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return IntegrationAuditLogSubscriptionsApiFp(this.configuration).updateSubscription(integrationKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationDeliveryConfigurationsBetaApi - axios parameter creator
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationDeliveryConfigurationPost' is not null or undefined
            assertParamExists('createIntegrationDeliveryConfiguration', 'integrationDeliveryConfigurationPost', integrationDeliveryConfigurationPost)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationDeliveryConfigurationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIntegrationDeliveryConfiguration', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationByEnvironment: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationByEnvironment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationByEnvironment', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationById: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntegrationDeliveryConfigurationById', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/integration-capabilities/featureStore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an integration delivery configuration. Updating an integration delivery configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchIntegrationDeliveryConfiguration', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegrationDeliveryConfiguration: async (projectKey: string, environmentKey: string, integrationKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'integrationKey', integrationKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('validateIntegrationDeliveryConfiguration', 'id', id)
            const localVarPath = `/api/v2/integration-capabilities/featureStore/{projectKey}/{environmentKey}/{integrationKey}/{id}/validate`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - functional programming interface
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationDeliveryConfigurationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationDeliveryConfigurations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationDeliveryConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an integration delivery configuration. Updating an integration delivery configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDeliveryConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - factory interface
 * @export
 */
export const IntegrationDeliveryConfigurationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationDeliveryConfigurationsBetaApiFp(configuration)
    return {
        /**
         * Create a delivery configuration.
         * @summary Create delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a delivery configuration.
         * @summary Delete delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get delivery configurations by environment.
         * @summary Get delivery configurations by environment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<IntegrationDeliveryConfigurationCollection> {
            return localVarFp.getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get delivery configuration by ID.
         * @summary Get delivery configuration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all delivery configurations.
         * @summary List all delivery configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationDeliveryConfigurations(options?: any): AxiosPromise<IntegrationDeliveryConfigurationCollection> {
            return localVarFp.getIntegrationDeliveryConfigurations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an integration delivery configuration. Updating an integration delivery configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<IntegrationDeliveryConfiguration> {
            return localVarFp.patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
         * @summary Validate delivery configuration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key
         * @param {string} id The configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: any): AxiosPromise<IntegrationDeliveryConfigurationResponse> {
            return localVarFp.validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationDeliveryConfigurationsBetaApi - object-oriented interface
 * @export
 * @class IntegrationDeliveryConfigurationsBetaApi
 * @extends {BaseAPI}
 */
export class IntegrationDeliveryConfigurationsBetaApi extends BaseAPI {
    /**
     * Create a delivery configuration.
     * @summary Create delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public createIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).createIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a delivery configuration.
     * @summary Delete delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public deleteIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).deleteIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get delivery configurations by environment.
     * @summary Get delivery configurations by environment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurationByEnvironment(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurationByEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get delivery configuration by ID.
     * @summary Get delivery configuration by ID
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurationById(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurationById(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all delivery configurations.
     * @summary List all delivery configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public getIntegrationDeliveryConfigurations(options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).getIntegrationDeliveryConfigurations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an integration delivery configuration. Updating an integration delivery configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public patchIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).patchIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the saved delivery configuration, using the `validationRequest` in the integration\'s `manifest.json` file.
     * @summary Validate delivery configuration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key
     * @param {string} id The configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationDeliveryConfigurationsBetaApi
     */
    public validateIntegrationDeliveryConfiguration(projectKey: string, environmentKey: string, integrationKey: string, id: string, options?: AxiosRequestConfig) {
        return IntegrationDeliveryConfigurationsBetaApiFp(this.configuration).validateIntegrationDeliveryConfiguration(projectKey, environmentKey, integrationKey, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsBetaApi - axios parameter creator
 * @export
 */
export const IntegrationsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the `config` object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: `namespace` (string)   * Sort key: `key` (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/segments/big-segment-configuration). 
         * @summary Create big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentStoreIntegration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createBigSegmentStoreIntegration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createBigSegmentStoreIntegration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('createBigSegmentStoreIntegration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationDeliveryConfigurationPost' is not null or undefined
            assertParamExists('createBigSegmentStoreIntegration', 'integrationDeliveryConfigurationPost', integrationDeliveryConfigurationPost)
            const localVarPath = `/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationDeliveryConfigurationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
         * @summary Delete big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBigSegmentStoreIntegration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteBigSegmentStoreIntegration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteBigSegmentStoreIntegration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('deleteBigSegmentStoreIntegration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('deleteBigSegmentStoreIntegration', 'integrationId', integrationId)
            const localVarPath = `/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a big segment store integration by ID.
         * @summary Get big segment store integration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentStoreIntegration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getBigSegmentStoreIntegration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getBigSegmentStoreIntegration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('getBigSegmentStoreIntegration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getBigSegmentStoreIntegration', 'integrationId', integrationId)
            const localVarPath = `/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all big segment store integrations.
         * @summary List all big segment store integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentStoreIntegrations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/integration-capabilities/big-segment-store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBigSegmentStoreIntegration: async (projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchBigSegmentStoreIntegration', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchBigSegmentStoreIntegration', 'environmentKey', environmentKey)
            // verify required parameter 'integrationKey' is not null or undefined
            assertParamExists('patchBigSegmentStoreIntegration', 'integrationKey', integrationKey)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('patchBigSegmentStoreIntegration', 'integrationId', integrationId)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchBigSegmentStoreIntegration', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsBetaApi - functional programming interface
 * @export
 */
export const IntegrationsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the `config` object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: `namespace` (string)   * Sort key: `key` (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/segments/big-segment-configuration). 
         * @summary Create big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentStoreIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
         * @summary Delete big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a big segment store integration by ID.
         * @summary Get big segment store integration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentStoreIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all big segment store integrations.
         * @summary List all big segment store integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentStoreIntegrations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentStoreIntegrationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentStoreIntegrations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentStoreIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsBetaApi - factory interface
 * @export
 */
export const IntegrationsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsBetaApiFp(configuration)
    return {
        /**
         *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the `config` object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: `namespace` (string)   * Sort key: `key` (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/segments/big-segment-configuration). 
         * @summary Create big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: any): AxiosPromise<BigSegmentStoreIntegration> {
            return localVarFp.createBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
         * @summary Delete big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a big segment store integration by ID.
         * @summary Get big segment store integration by ID
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: any): AxiosPromise<BigSegmentStoreIntegration> {
            return localVarFp.getBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all big segment store integrations.
         * @summary List all big segment store integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentStoreIntegrations(options?: any): AxiosPromise<BigSegmentStoreIntegrationCollection> {
            return localVarFp.getBigSegmentStoreIntegrations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update big segment store integration
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
         * @param {string} integrationId The integration ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<BigSegmentStoreIntegration> {
            return localVarFp.patchBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsBetaApi - object-oriented interface
 * @export
 * @class IntegrationsBetaApi
 * @extends {BaseAPI}
 */
export class IntegrationsBetaApi extends BaseAPI {
    /**
     *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the `config` object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: `namespace` (string)   * Sort key: `key` (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/segments/big-segment-configuration). 
     * @summary Create big segment store integration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param {IntegrationDeliveryConfigurationPost} integrationDeliveryConfigurationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsBetaApi
     */
    public createBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost, options?: AxiosRequestConfig) {
        return IntegrationsBetaApiFp(this.configuration).createBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationDeliveryConfigurationPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
     * @summary Delete big segment store integration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param {string} integrationId The integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsBetaApi
     */
    public deleteBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: AxiosRequestConfig) {
        return IntegrationsBetaApiFp(this.configuration).deleteBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a big segment store integration by ID.
     * @summary Get big segment store integration by ID
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param {string} integrationId The integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsBetaApi
     */
    public getBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, options?: AxiosRequestConfig) {
        return IntegrationsBetaApiFp(this.configuration).getBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all big segment store integrations.
     * @summary List all big segment store integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsBetaApi
     */
    public getBigSegmentStoreIntegrations(options?: AxiosRequestConfig) {
        return IntegrationsBetaApiFp(this.configuration).getBigSegmentStoreIntegrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update big segment store integration
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param {string} integrationId The integration ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsBetaApi
     */
    public patchBigSegmentStoreIntegration(projectKey: string, environmentKey: string, integrationKey: string, integrationId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return IntegrationsBetaApiFp(this.configuration).patchBigSegmentStoreIntegration(projectKey, environmentKey, integrationKey, integrationId, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric: async (projectKey: string, metricKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('deleteMetric', 'metricKey', metricKey)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports four fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric - `metricGroups` includes all metric groups from the specific project that use the metric - `metricGroupCount` includes the number of metric groups from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {string} [versionId] The specific version ID of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (projectKey: string, metricKey: string, expand?: string, versionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('getMetric', 'metricKey', metricKey)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (versionId !== undefined) {
                localVarQueryParameter['versionId'] = versionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (projectKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetrics', 'projectKey', projectKey)
            const localVarPath = `/api/v2/metrics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch a metric by key. Updating a metric uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetric: async (projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchMetric', 'projectKey', projectKey)
            // verify required parameter 'metricKey' is not null or undefined
            assertParamExists('patchMetric', 'metricKey', metricKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchMetric', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/metrics/{projectKey}/{metricKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricKey"}}`, encodeURIComponent(String(metricKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric: async (projectKey: string, metricPost: MetricPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postMetric', 'projectKey', projectKey)
            // verify required parameter 'metricPost' is not null or undefined
            assertParamExists('postMetric', 'metricPost', metricPost)
            const localVarPath = `/api/v2/metrics/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetric(projectKey: string, metricKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetric(projectKey, metricKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports four fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric - `metricGroups` includes all metric groups from the specific project that use the metric - `metricGroupCount` includes the number of metric groups from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {string} [versionId] The specific version ID of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(projectKey: string, metricKey: string, expand?: string, versionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(projectKey, metricKey, expand, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(projectKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(projectKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch a metric by key. Updating a metric uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMetric(projectKey, metricKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetric(projectKey: string, metricPost: MetricPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetric(projectKey, metricPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Delete a metric by key.
         * @summary Delete metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetric(projectKey: string, metricKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMetric(projectKey, metricKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports four fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric - `metricGroups` includes all metric groups from the specific project that use the metric - `metricGroupCount` includes the number of metric groups from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {string} [versionId] The specific version ID of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(projectKey: string, metricKey: string, expand?: string, versionId?: string, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.getMetric(projectKey, metricKey, expand, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
         * @summary List metrics
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(projectKey: string, expand?: string, options?: any): AxiosPromise<MetricCollectionRep> {
            return localVarFp.getMetrics(projectKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch a metric by key. Updating a metric uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update metric
         * @param {string} projectKey The project key
         * @param {string} metricKey The metric key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.patchMetric(projectKey, metricKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
         * @summary Create metric
         * @param {string} projectKey The project key
         * @param {MetricPost} metricPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetric(projectKey: string, metricPost: MetricPost, options?: any): AxiosPromise<MetricRep> {
            return localVarFp.postMetric(projectKey, metricPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Delete a metric by key.
     * @summary Delete metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public deleteMetric(projectKey: string, metricKey: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).deleteMetric(projectKey, metricKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a single metric from the specific project.  ### Expanding the metric response LaunchDarkly supports four fields for expanding the \"Get metric\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  - `experiments` includes all experiments from the specific project that use the metric - `experimentCount` includes the number of experiments from the specific project that use the metric - `metricGroups` includes all metric groups from the specific project that use the metric - `metricGroupCount` includes the number of metric groups from the specific project that use the metric  For example, `expand=experiments` includes the `experiments` field in the response. 
     * @summary Get metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {string} [versionId] The specific version ID of the metric
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(projectKey: string, metricKey: string, expand?: string, versionId?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(projectKey, metricKey, expand, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all metrics for the specified project.  ### Expanding the metric list response LaunchDarkly supports expanding the \"List metrics\" response. By default, the expandable field is **not** included in the response.  To expand the response, append the `expand` query parameter and add the following supported field:  - `experimentCount` includes the number of experiments from the specific project that use the metric  For example, `expand=experimentCount` includes the `experimentCount` field for each metric in the response. 
     * @summary List metrics
     * @param {string} projectKey The project key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(projectKey: string, expand?: string, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(projectKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch a metric by key. Updating a metric uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update metric
     * @param {string} projectKey The project key
     * @param {string} metricKey The metric key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public patchMetric(projectKey: string, metricKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).patchMetric(projectKey, metricKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new metric in the specified project. The expected `POST` body differs depending on the specified `kind` property.
     * @summary Create metric
     * @param {string} projectKey The project key
     * @param {MetricPost} metricPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public postMetric(projectKey: string, metricPost: MetricPost, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).postMetric(projectKey, metricPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsBetaApi - axios parameter creator
 * @export
 */
export const MetricsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new metric group in the specified project
         * @summary Create metric group
         * @param {string} projectKey The project key
         * @param {MetricGroupPost} metricGroupPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricGroup: async (projectKey: string, metricGroupPost: MetricGroupPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createMetricGroup', 'projectKey', projectKey)
            // verify required parameter 'metricGroupPost' is not null or undefined
            assertParamExists('createMetricGroup', 'metricGroupPost', metricGroupPost)
            const localVarPath = `/api/v2/projects/{projectKey}/metric-groups`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricGroupPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a metric group by key.
         * @summary Delete metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetricGroup: async (projectKey: string, metricGroupKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteMetricGroup', 'projectKey', projectKey)
            // verify required parameter 'metricGroupKey' is not null or undefined
            assertParamExists('deleteMetricGroup', 'metricGroupKey', metricGroupKey)
            const localVarPath = `/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricGroupKey"}}`, encodeURIComponent(String(metricGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a single metric group from the specific project.  ### Expanding the metric group response LaunchDarkly supports two fields for expanding the \"Get metric group\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with either or both of the following fields:  - `experiments` includes all experiments from the specific project that use the metric group - `experimentCount` includes the number of experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricGroup: async (projectKey: string, metricGroupKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetricGroup', 'projectKey', projectKey)
            // verify required parameter 'metricGroupKey' is not null or undefined
            assertParamExists('getMetricGroup', 'metricGroupKey', metricGroupKey)
            const localVarPath = `/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricGroupKey"}}`, encodeURIComponent(String(metricGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all metric groups for the specified project.  ### Expanding the metric groups response LaunchDarkly supports one field for expanding the \"Get metric groups\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the following field:  - `experiments` includes all experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary List metric groups
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricGroups: async (projectKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getMetricGroups', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/metric-groups`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch a metric group by key. Updating a metric group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes.
         * @summary Patch metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetricGroup: async (projectKey: string, metricGroupKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchMetricGroup', 'projectKey', projectKey)
            // verify required parameter 'metricGroupKey' is not null or undefined
            assertParamExists('patchMetricGroup', 'metricGroupKey', metricGroupKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchMetricGroup', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}/metric-groups/{metricGroupKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"metricGroupKey"}}`, encodeURIComponent(String(metricGroupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsBetaApi - functional programming interface
 * @export
 */
export const MetricsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new metric group in the specified project
         * @summary Create metric group
         * @param {string} projectKey The project key
         * @param {MetricGroupPost} metricGroupPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMetricGroup(projectKey: string, metricGroupPost: MetricGroupPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGroupRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMetricGroup(projectKey, metricGroupPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a metric group by key.
         * @summary Delete metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMetricGroup(projectKey: string, metricGroupKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMetricGroup(projectKey, metricGroupKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information for a single metric group from the specific project.  ### Expanding the metric group response LaunchDarkly supports two fields for expanding the \"Get metric group\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with either or both of the following fields:  - `experiments` includes all experiments from the specific project that use the metric group - `experimentCount` includes the number of experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricGroup(projectKey: string, metricGroupKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGroupRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricGroup(projectKey, metricGroupKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all metric groups for the specified project.  ### Expanding the metric groups response LaunchDarkly supports one field for expanding the \"Get metric groups\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the following field:  - `experiments` includes all experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary List metric groups
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricGroups(projectKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGroupCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricGroups(projectKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch a metric group by key. Updating a metric group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes.
         * @summary Patch metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMetricGroup(projectKey: string, metricGroupKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricGroupRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMetricGroup(projectKey, metricGroupKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsBetaApi - factory interface
 * @export
 */
export const MetricsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsBetaApiFp(configuration)
    return {
        /**
         * Create a new metric group in the specified project
         * @summary Create metric group
         * @param {string} projectKey The project key
         * @param {MetricGroupPost} metricGroupPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMetricGroup(projectKey: string, metricGroupPost: MetricGroupPost, options?: any): AxiosPromise<MetricGroupRep> {
            return localVarFp.createMetricGroup(projectKey, metricGroupPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a metric group by key.
         * @summary Delete metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetricGroup(projectKey: string, metricGroupKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMetricGroup(projectKey, metricGroupKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a single metric group from the specific project.  ### Expanding the metric group response LaunchDarkly supports two fields for expanding the \"Get metric group\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with either or both of the following fields:  - `experiments` includes all experiments from the specific project that use the metric group - `experimentCount` includes the number of experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary Get metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricGroup(projectKey: string, metricGroupKey: string, expand?: string, options?: any): AxiosPromise<MetricGroupRep> {
            return localVarFp.getMetricGroup(projectKey, metricGroupKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all metric groups for the specified project.  ### Expanding the metric groups response LaunchDarkly supports one field for expanding the \"Get metric groups\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the following field:  - `experiments` includes all experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
         * @summary List metric groups
         * @param {string} projectKey The project key
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricGroups(projectKey: string, expand?: string, options?: any): AxiosPromise<MetricGroupCollectionRep> {
            return localVarFp.getMetricGroups(projectKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch a metric group by key. Updating a metric group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes.
         * @summary Patch metric group
         * @param {string} projectKey The project key
         * @param {string} metricGroupKey The metric group key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMetricGroup(projectKey: string, metricGroupKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<MetricGroupRep> {
            return localVarFp.patchMetricGroup(projectKey, metricGroupKey, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsBetaApi - object-oriented interface
 * @export
 * @class MetricsBetaApi
 * @extends {BaseAPI}
 */
export class MetricsBetaApi extends BaseAPI {
    /**
     * Create a new metric group in the specified project
     * @summary Create metric group
     * @param {string} projectKey The project key
     * @param {MetricGroupPost} metricGroupPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBetaApi
     */
    public createMetricGroup(projectKey: string, metricGroupPost: MetricGroupPost, options?: AxiosRequestConfig) {
        return MetricsBetaApiFp(this.configuration).createMetricGroup(projectKey, metricGroupPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a metric group by key.
     * @summary Delete metric group
     * @param {string} projectKey The project key
     * @param {string} metricGroupKey The metric group key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBetaApi
     */
    public deleteMetricGroup(projectKey: string, metricGroupKey: string, options?: AxiosRequestConfig) {
        return MetricsBetaApiFp(this.configuration).deleteMetricGroup(projectKey, metricGroupKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a single metric group from the specific project.  ### Expanding the metric group response LaunchDarkly supports two fields for expanding the \"Get metric group\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with either or both of the following fields:  - `experiments` includes all experiments from the specific project that use the metric group - `experimentCount` includes the number of experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
     * @summary Get metric group
     * @param {string} projectKey The project key
     * @param {string} metricGroupKey The metric group key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBetaApi
     */
    public getMetricGroup(projectKey: string, metricGroupKey: string, expand?: string, options?: AxiosRequestConfig) {
        return MetricsBetaApiFp(this.configuration).getMetricGroup(projectKey, metricGroupKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all metric groups for the specified project.  ### Expanding the metric groups response LaunchDarkly supports one field for expanding the \"Get metric groups\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the following field:  - `experiments` includes all experiments from the specific project that use the metric group  For example, `expand=experiments` includes the `experiments` field in the response. 
     * @summary List metric groups
     * @param {string} projectKey The project key
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBetaApi
     */
    public getMetricGroups(projectKey: string, expand?: string, options?: AxiosRequestConfig) {
        return MetricsBetaApiFp(this.configuration).getMetricGroups(projectKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch a metric group by key. Updating a metric group uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes.
     * @summary Patch metric group
     * @param {string} projectKey The project key
     * @param {string} metricGroupKey The metric group key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsBetaApi
     */
    public patchMetricGroup(projectKey: string, metricGroupKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return MetricsBetaApiFp(this.configuration).patchMetricGroup(projectKey, metricGroupKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuth2ClientsApi - axios parameter creator
 * @export
 */
export const OAuth2ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2Client: async (oauthClientPost: OauthClientPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthClientPost' is not null or undefined
            assertParamExists('createOAuth2Client', 'oauthClientPost', oauthClientPost)
            const localVarPath = `/api/v2/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauthClientPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthClient: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteOAuthClient', 'clientId', clientId)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClientById: async (clientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getOAuthClientById', 'clientId', clientId)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/oauth/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Updating an OAuth2 client uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates). Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOAuthClient: async (clientId: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('patchOAuthClient', 'clientId', clientId)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchOAuthClient', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/oauth/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ClientsApi - functional programming interface
 * @export
 */
export const OAuth2ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOAuth2Client(oauthClientPost: OauthClientPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOAuth2Client(oauthClientPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOAuthClient(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOAuthClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthClientById(clientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthClientById(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthClients(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthClients(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Updating an OAuth2 client uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates). Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOAuthClient(clientId, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuth2ClientsApi - factory interface
 * @export
 */
export const OAuth2ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ClientsApiFp(configuration)
    return {
        /**
         * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
         * @summary Create a LaunchDarkly OAuth 2.0 client
         * @param {OauthClientPost} oauthClientPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2Client(oauthClientPost: OauthClientPost, options?: any): AxiosPromise<Client> {
            return localVarFp.createOAuth2Client(oauthClientPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing OAuth 2.0 client by unique client ID.
         * @summary Delete OAuth 2.0 client
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthClient(clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOAuthClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a registered OAuth 2.0 client by unique client ID.
         * @summary Get client by ID
         * @param {string} clientId The client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClientById(clientId: string, options?: any): AxiosPromise<Client> {
            return localVarFp.getOAuthClientById(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all OAuth 2.0 clients registered by your account.
         * @summary Get clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthClients(options?: any): AxiosPromise<ClientCollection> {
            return localVarFp.getOAuthClients(options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an existing OAuth 2.0 client by client ID. Updating an OAuth2 client uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates). Only `name`, `description`, and `redirectUri` may be patched.
         * @summary Patch client by ID
         * @param {string} clientId The client ID
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Client> {
            return localVarFp.patchOAuthClient(clientId, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2ClientsApi - object-oriented interface
 * @export
 * @class OAuth2ClientsApi
 * @extends {BaseAPI}
 */
export class OAuth2ClientsApi extends BaseAPI {
    /**
     * Create (register) a LaunchDarkly OAuth2 client. OAuth2 clients allow you to build custom integrations using LaunchDarkly as your identity provider.
     * @summary Create a LaunchDarkly OAuth 2.0 client
     * @param {OauthClientPost} oauthClientPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsApi
     */
    public createOAuth2Client(oauthClientPost: OauthClientPost, options?: AxiosRequestConfig) {
        return OAuth2ClientsApiFp(this.configuration).createOAuth2Client(oauthClientPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing OAuth 2.0 client by unique client ID.
     * @summary Delete OAuth 2.0 client
     * @param {string} clientId The client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsApi
     */
    public deleteOAuthClient(clientId: string, options?: AxiosRequestConfig) {
        return OAuth2ClientsApiFp(this.configuration).deleteOAuthClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a registered OAuth 2.0 client by unique client ID.
     * @summary Get client by ID
     * @param {string} clientId The client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsApi
     */
    public getOAuthClientById(clientId: string, options?: AxiosRequestConfig) {
        return OAuth2ClientsApiFp(this.configuration).getOAuthClientById(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all OAuth 2.0 clients registered by your account.
     * @summary Get clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsApi
     */
    public getOAuthClients(options?: AxiosRequestConfig) {
        return OAuth2ClientsApiFp(this.configuration).getOAuthClients(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an existing OAuth 2.0 client by client ID. Updating an OAuth2 client uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates). Only `name`, `description`, and `redirectUri` may be patched.
     * @summary Patch client by ID
     * @param {string} clientId The client ID
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ClientsApi
     */
    public patchOAuthClient(clientId: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return OAuth2ClientsApiFp(this.configuration).patchOAuthClient(clientId, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OtherApi - axios parameter creator
 * @export
 */
export const OtherApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/public-ip-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenapiSpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OtherApi - functional programming interface
 * @export
 */
export const OtherApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OtherApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIps(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIps(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenapiSpec(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenapiSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoot(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OtherApi - factory interface
 * @export
 */
export const OtherApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OtherApiFp(configuration)
    return {
        /**
         * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the public IP list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIps(options?: any): AxiosPromise<IpList> {
            return localVarFp.getIps(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Gets the OpenAPI spec in json
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenapiSpec(options?: any): AxiosPromise<void> {
            return localVarFp.getOpenapiSpec(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
         * @summary Root resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(options?: any): AxiosPromise<RootResponse> {
            return localVarFp.getRoot(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
         * @summary Get version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): AxiosPromise<VersionsRep> {
            return localVarFp.getVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OtherApi - object-oriented interface
 * @export
 * @class OtherApi
 * @extends {BaseAPI}
 */
export class OtherApi extends BaseAPI {
    /**
     * Get a list of IP ranges the LaunchDarkly service uses. You can use this list to allow LaunchDarkly through your firewall. We post upcoming changes to this list in advance on our [status page](https://status.launchdarkly.com/). <br /><br />In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Gets the public IP list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getIps(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getIps(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest version of the OpenAPI specification for LaunchDarkly\'s API in JSON format. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Gets the OpenAPI spec in json
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getOpenapiSpec(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getOpenapiSpec(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the resource categories the API supports. In the sandbox, click \'Try it\' and enter any string in the \'Authorization\' field to test this endpoint.
     * @summary Root resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getRoot(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getRoot(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest API version, the list of valid API versions in ascending order, and the version being used for this request. These are all in the external, date-based format.
     * @summary Get version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public getVersions(options?: AxiosRequestConfig) {
        return OtherApiFp(this.configuration).getVersions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagDefaultsByProject: async (projectKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagDefaultsByProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getProject', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a flag default. Updating a flag default uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagDefaultsByProject: async (projectKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFlagDefaultsByProject', 'projectKey', projectKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchFlagDefaultsByProject', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project. Updating a project uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the project fields that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject: async (projectKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchProject', 'projectKey', projectKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchProject', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject: async (projectPost: ProjectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPost' is not null or undefined
            assertParamExists('postProject', 'projectPost', projectPost)
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagDefaultsByProject: async (projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagDefaultsByProject', 'projectKey', projectKey)
            // verify required parameter 'upsertFlagDefaultsPayload' is not null or undefined
            assertParamExists('putFlagDefaultsByProject', 'upsertFlagDefaultsPayload', upsertFlagDefaultsPayload)
            const localVarPath = `/api/v2/projects/{projectKey}/flag-defaults`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertFlagDefaultsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagDefaultsByProject(projectKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlagDefaultsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagDefaultsByProject(projectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(limit, offset, filter, sort, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a flag default. Updating a flag default uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertPayloadRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFlagDefaultsByProject(projectKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a project. Updating a project uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the project fields that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProject(projectKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProject(projectPost: ProjectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProject(projectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertPayloadRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @summary Delete project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the flag defaults for a specific project.
         * @summary Get flag defaults for project
         * @param {string} projectKey The project key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagDefaultsByProject(projectKey: string, options?: any): AxiosPromise<FlagDefaultsRep> {
            return localVarFp.getFlagDefaultsByProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
         * @summary Get project
         * @param {string} projectKey The project key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectKey: string, expand?: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
         * @summary List projects
         * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: any): AxiosPromise<Projects> {
            return localVarFp.getProjects(limit, offset, filter, sort, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a flag default. Updating a flag default uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update flag default for project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<UpsertPayloadRep> {
            return localVarFp.patchFlagDefaultsByProject(projectKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a project. Updating a project uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the project fields that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
         * @summary Update project
         * @param {string} projectKey The project key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<ProjectRep> {
            return localVarFp.patchProject(projectKey, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new project with the given key and name. Project keys must be unique within an account.
         * @summary Create project
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(projectPost: ProjectPost, options?: any): AxiosPromise<ProjectRep> {
            return localVarFp.postProject(projectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update flag defaults for a project.
         * @summary Create or update flag defaults for project
         * @param {string} projectKey The project key
         * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: any): AxiosPromise<UpsertPayloadRep> {
            return localVarFp.putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Delete a project by key. Use this endpoint with caution. Deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @summary Delete project
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectKey: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the flag defaults for a specific project.
     * @summary Get flag defaults for project
     * @param {string} projectKey The project key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getFlagDefaultsByProject(projectKey: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getFlagDefaultsByProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single project by key.  ### Expanding the project response  LaunchDarkly supports one field for expanding the \"Get project\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields: * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for the project in the response. 
     * @summary Get project
     * @param {string} projectKey The project key.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectKey: string, expand?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(projectKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of projects.  By default, this returns the first 20 projects. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering projects  LaunchDarkly supports two fields for filters: - `query` is a string that matches against the projects\' names and keys. It is not case sensitive. - `tags` is a `+`-separated list of project tags. It filters the list of projects that have all of the tags in the list.  For example, the filter `filter=query:abc,tags:tag-1+tag-2` matches projects with the string `abc` in their name or key and also are tagged with `tag-1` and `tag-2`. The filter is not case-sensitive.  The documented values for `filter` query parameters are prior to URL encoding. For example, the `+` in `filter=tags:tag-1+tag-2` must be encoded to `%2B`.  ### Sorting projects  LaunchDarkly supports two fields for sorting: - `name` sorts by project name. - `createdOn` sorts by the creation date of the project.  For example, `sort=name` sorts the response by project name in ascending order.  ### Expanding the projects response  LaunchDarkly supports one field for expanding the \"List projects\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with the `environments` field.  `Environments` includes a paginated list of the project environments. * `environments` includes a paginated list of the project environments.  For example, `expand=environments` includes the `environments` field for each project in the response. 
     * @summary List projects
     * @param {number} [limit] The number of projects to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
     * @param {string} [sort] A comma-separated list of fields to sort by. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(limit?: number, offset?: number, filter?: string, sort?: string, expand?: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjects(limit, offset, filter, sort, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a flag default. Updating a flag default uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update flag default for project
     * @param {string} projectKey The project key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchFlagDefaultsByProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).patchFlagDefaultsByProject(projectKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a project. Updating a project uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).<br/><br/>To add an element to the project fields that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add to the beginning of the array. Use `/-` to add to the end of the array.
     * @summary Update project
     * @param {string} projectKey The project key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchProject(projectKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).patchProject(projectKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new project with the given key and name. Project keys must be unique within an account.
     * @summary Create project
     * @param {ProjectPost} projectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public postProject(projectPost: ProjectPost, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).postProject(projectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update flag defaults for a project.
     * @summary Create or update flag defaults for project
     * @param {string} projectKey The project key
     * @param {UpsertFlagDefaultsPayload} upsertFlagDefaultsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putFlagDefaultsByProject(projectKey: string, upsertFlagDefaultsPayload: UpsertFlagDefaultsPayload, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).putFlagDefaultsByProject(projectKey, upsertFlagDefaultsPayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelayProxyConfigurationsApi - axios parameter creator
 * @export
 */
export const RelayProxyConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayAutoConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRelayAutoConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRelayProxyConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Relay Proxy configuration. Updating a configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayAutoConfig: async (id: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRelayAutoConfig', 'id', id)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchRelayAutoConfig', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig: async (relayAutoConfigPost: RelayAutoConfigPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relayAutoConfigPost' is not null or undefined
            assertParamExists('postRelayAutoConfig', 'relayAutoConfigPost', relayAutoConfigPost)
            const localVarPath = `/api/v2/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relayAutoConfigPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayAutoConfig: async (id: string, expiry?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resetRelayAutoConfig', 'id', id)
            const localVarPath = `/api/v2/account/relay-auto-configs/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelayProxyConfigurationsApi - functional programming interface
 * @export
 */
export const RelayProxyConfigurationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelayProxyConfigurationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelayAutoConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelayAutoConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayProxyConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfigs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigCollectionRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayProxyConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Relay Proxy configuration. Updating a configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelayAutoConfig(id, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRelayAutoConfig(relayAutoConfigPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetRelayAutoConfig(id: string, expiry?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayAutoConfigRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetRelayAutoConfig(id, expiry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelayProxyConfigurationsApi - factory interface
 * @export
 */
export const RelayProxyConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelayProxyConfigurationsApiFp(configuration)
    return {
        /**
         * Delete a Relay Proxy config.
         * @summary Delete Relay Proxy config by ID
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayAutoConfig(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelayAutoConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Relay Proxy auto config by ID.
         * @summary Get Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig(id: string, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.getRelayProxyConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Relay Proxy configurations in the account.
         * @summary List Relay Proxy configs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs(options?: any): AxiosPromise<RelayAutoConfigCollectionRep> {
            return localVarFp.getRelayProxyConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Relay Proxy configuration. Updating a configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a Relay Proxy config
         * @param {string} id The relay auto config id
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.patchRelayAutoConfig(id, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Relay Proxy config.
         * @summary Create a new Relay Proxy config
         * @param {RelayAutoConfigPost} relayAutoConfigPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.postRelayAutoConfig(relayAutoConfigPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
         * @summary Reset Relay Proxy configuration key
         * @param {string} id The Relay Proxy configuration ID
         * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayAutoConfig(id: string, expiry?: number, options?: any): AxiosPromise<RelayAutoConfigRep> {
            return localVarFp.resetRelayAutoConfig(id, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelayProxyConfigurationsApi - object-oriented interface
 * @export
 * @class RelayProxyConfigurationsApi
 * @extends {BaseAPI}
 */
export class RelayProxyConfigurationsApi extends BaseAPI {
    /**
     * Delete a Relay Proxy config.
     * @summary Delete Relay Proxy config by ID
     * @param {string} id The relay auto config id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public deleteRelayAutoConfig(id: string, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).deleteRelayAutoConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Relay Proxy auto config by ID.
     * @summary Get Relay Proxy config
     * @param {string} id The relay auto config id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfig(id: string, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Relay Proxy configurations in the account.
     * @summary List Relay Proxy configs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfigs(options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Relay Proxy configuration. Updating a configuration uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update a Relay Proxy config
     * @param {string} id The relay auto config id
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public patchRelayAutoConfig(id: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).patchRelayAutoConfig(id, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Relay Proxy config.
     * @summary Create a new Relay Proxy config
     * @param {RelayAutoConfigPost} relayAutoConfigPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public postRelayAutoConfig(relayAutoConfigPost: RelayAutoConfigPost, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).postRelayAutoConfig(relayAutoConfigPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset a Relay Proxy configuration\'s secret key with an optional expiry time for the old key.
     * @summary Reset Relay Proxy configuration key
     * @param {string} id The Relay Proxy configuration ID
     * @param {number} [expiry] An expiration time for the old Relay Proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the Relay Proxy configuration will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public resetRelayAutoConfig(id: string, expiry?: number, options?: AxiosRequestConfig) {
        return RelayProxyConfigurationsApiFp(this.configuration).resetRelayAutoConfig(id, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReleasePipelinesBetaApi - axios parameter creator
 * @export
 */
export const ReleasePipelinesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`. 
         * @summary Delete release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReleasePipeline: async (projectKey: string, pipelineKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteReleasePipeline', 'projectKey', projectKey)
            // verify required parameter 'pipelineKey' is not null or undefined
            assertParamExists('deleteReleasePipeline', 'pipelineKey', pipelineKey)
            const localVarPath = `/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"pipelineKey"}}`, encodeURIComponent(String(pipelineKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the release pipeline `key`, `name`, and `description`. It is not case sensitive. For example: `?filter=query:examplePipeline`. 
         * @summary Get all release pipelines
         * @param {string} projectKey The project key
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {number} [limit] The maximum number of items to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReleasePipelines: async (projectKey: string, filter?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getAllReleasePipelines', 'projectKey', projectKey)
            const localVarPath = `/api/v2/projects/{projectKey}/release-pipelines`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a release pipeline by key
         * @summary Get release pipeline by key
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleasePipelineByKey: async (projectKey: string, pipelineKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getReleasePipelineByKey', 'projectKey', projectKey)
            // verify required parameter 'pipelineKey' is not null or undefined
            assertParamExists('getReleasePipelineByKey', 'pipelineKey', pipelineKey)
            const localVarPath = `/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"pipelineKey"}}`, encodeURIComponent(String(pipelineKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a release pipeline. Updating a release pipeline uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReleasePipeline: async (projectKey: string, pipelineKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchReleasePipeline', 'projectKey', projectKey)
            // verify required parameter 'pipelineKey' is not null or undefined
            assertParamExists('patchReleasePipeline', 'pipelineKey', pipelineKey)
            const localVarPath = `/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"pipelineKey"}}`, encodeURIComponent(String(pipelineKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`.  You can create up to 20 release pipelines per project. 
         * @summary Create a release pipeline
         * @param {string} projectKey The project key
         * @param {CreateReleasePipelineInput} createReleasePipelineInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReleasePipeline: async (projectKey: string, createReleasePipelineInput: CreateReleasePipelineInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postReleasePipeline', 'projectKey', projectKey)
            // verify required parameter 'createReleasePipelineInput' is not null or undefined
            assertParamExists('postReleasePipeline', 'createReleasePipelineInput', createReleasePipelineInput)
            const localVarPath = `/api/v2/projects/{projectKey}/release-pipelines`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReleasePipelineInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleasePipelinesBetaApi - functional programming interface
 * @export
 */
export const ReleasePipelinesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReleasePipelinesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`. 
         * @summary Delete release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReleasePipeline(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReleasePipeline(projectKey, pipelineKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the release pipeline `key`, `name`, and `description`. It is not case sensitive. For example: `?filter=query:examplePipeline`. 
         * @summary Get all release pipelines
         * @param {string} projectKey The project key
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {number} [limit] The maximum number of items to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllReleasePipelines(projectKey: string, filter?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleasePipelineCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllReleasePipelines(projectKey, filter, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a release pipeline by key
         * @summary Get release pipeline by key
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleasePipelineByKey(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleasePipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReleasePipelineByKey(projectKey, pipelineKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a release pipeline. Updating a release pipeline uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchReleasePipeline(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleasePipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchReleasePipeline(projectKey, pipelineKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`.  You can create up to 20 release pipelines per project. 
         * @summary Create a release pipeline
         * @param {string} projectKey The project key
         * @param {CreateReleasePipelineInput} createReleasePipelineInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReleasePipeline(projectKey: string, createReleasePipelineInput: CreateReleasePipelineInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleasePipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReleasePipeline(projectKey, createReleasePipelineInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReleasePipelinesBetaApi - factory interface
 * @export
 */
export const ReleasePipelinesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReleasePipelinesBetaApiFp(configuration)
    return {
        /**
         * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`. 
         * @summary Delete release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReleasePipeline(projectKey: string, pipelineKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReleasePipeline(projectKey, pipelineKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the release pipeline `key`, `name`, and `description`. It is not case sensitive. For example: `?filter=query:examplePipeline`. 
         * @summary Get all release pipelines
         * @param {string} projectKey The project key
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
         * @param {number} [limit] The maximum number of items to return. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReleasePipelines(projectKey: string, filter?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ReleasePipelineCollection> {
            return localVarFp.getAllReleasePipelines(projectKey, filter, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a release pipeline by key
         * @summary Get release pipeline by key
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleasePipelineByKey(projectKey: string, pipelineKey: string, options?: any): AxiosPromise<ReleasePipeline> {
            return localVarFp.getReleasePipelineByKey(projectKey, pipelineKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a release pipeline. Updating a release pipeline uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update a release pipeline
         * @param {string} projectKey The project key
         * @param {string} pipelineKey The release pipeline key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReleasePipeline(projectKey: string, pipelineKey: string, options?: any): AxiosPromise<ReleasePipeline> {
            return localVarFp.patchReleasePipeline(projectKey, pipelineKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`.  You can create up to 20 release pipelines per project. 
         * @summary Create a release pipeline
         * @param {string} projectKey The project key
         * @param {CreateReleasePipelineInput} createReleasePipelineInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReleasePipeline(projectKey: string, createReleasePipelineInput: CreateReleasePipelineInput, options?: any): AxiosPromise<ReleasePipeline> {
            return localVarFp.postReleasePipeline(projectKey, createReleasePipelineInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleasePipelinesBetaApi - object-oriented interface
 * @export
 * @class ReleasePipelinesBetaApi
 * @extends {BaseAPI}
 */
export class ReleasePipelinesBetaApi extends BaseAPI {
    /**
     * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`. 
     * @summary Delete release pipeline
     * @param {string} projectKey The project key
     * @param {string} pipelineKey The release pipeline key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasePipelinesBetaApi
     */
    public deleteReleasePipeline(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig) {
        return ReleasePipelinesBetaApiFp(this.configuration).deleteReleasePipeline(projectKey, pipelineKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the release pipeline `key`, `name`, and `description`. It is not case sensitive. For example: `?filter=query:examplePipeline`. 
     * @summary Get all release pipelines
     * @param {string} projectKey The project key
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields.
     * @param {number} [limit] The maximum number of items to return. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasePipelinesBetaApi
     */
    public getAllReleasePipelines(projectKey: string, filter?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ReleasePipelinesBetaApiFp(this.configuration).getAllReleasePipelines(projectKey, filter, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a release pipeline by key
     * @summary Get release pipeline by key
     * @param {string} projectKey The project key
     * @param {string} pipelineKey The release pipeline key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasePipelinesBetaApi
     */
    public getReleasePipelineByKey(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig) {
        return ReleasePipelinesBetaApiFp(this.configuration).getReleasePipelineByKey(projectKey, pipelineKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a release pipeline. Updating a release pipeline uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update a release pipeline
     * @param {string} projectKey The project key
     * @param {string} pipelineKey The release pipeline key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasePipelinesBetaApi
     */
    public patchReleasePipeline(projectKey: string, pipelineKey: string, options?: AxiosRequestConfig) {
        return ReleasePipelinesBetaApiFp(this.configuration).patchReleasePipeline(projectKey, pipelineKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the `defaultReleasePipelineKey`.  You can create up to 20 release pipelines per project. 
     * @summary Create a release pipeline
     * @param {string} projectKey The project key
     * @param {CreateReleasePipelineInput} createReleasePipelineInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasePipelinesBetaApi
     */
    public postReleasePipeline(projectKey: string, createReleasePipelineInput: CreateReleasePipelineInput, options?: AxiosRequestConfig) {
        return ReleasePipelinesBetaApiFp(this.configuration).postReleasePipeline(projectKey, createReleasePipelineInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReleasesBetaApi - axios parameter creator
 * @export
 */
export const ReleasesBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get currently active release for a flag
         * @summary Get release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseByFlagKey: async (projectKey: string, flagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getReleaseByFlagKey', 'projectKey', projectKey)
            // verify required parameter 'flagKey' is not null or undefined
            assertParamExists('getReleaseByFlagKey', 'flagKey', flagKey)
            const localVarPath = `/api/v2/flags/{projectKey}/{flagKey}/release`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"flagKey"}}`, encodeURIComponent(String(flagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update currently active release for a flag. Updating releases requires the [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) format. To learn more, read [Updates](/#section/Overview/Updates).  You can only use this endpoint to mark a release phase complete or incomplete. To indicate which phase to update, use the array index in the `path`. For example, to mark the first phase of a release as complete, use the following request body:  ```   [     {       \"op\": \"replace\",       \"path\": \"/phase/0/complete\",       \"value\": true     }   ] ``` 
         * @summary Patch release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReleaseByFlagKey: async (projectKey: string, flagKey: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchReleaseByFlagKey', 'projectKey', projectKey)
            // verify required parameter 'flagKey' is not null or undefined
            assertParamExists('patchReleaseByFlagKey', 'flagKey', flagKey)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchReleaseByFlagKey', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/flags/{projectKey}/{flagKey}/release`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"flagKey"}}`, encodeURIComponent(String(flagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleasesBetaApi - functional programming interface
 * @export
 */
export const ReleasesBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReleasesBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get currently active release for a flag
         * @summary Get release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleaseByFlagKey(projectKey: string, flagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReleaseByFlagKey(projectKey, flagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update currently active release for a flag. Updating releases requires the [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) format. To learn more, read [Updates](/#section/Overview/Updates).  You can only use this endpoint to mark a release phase complete or incomplete. To indicate which phase to update, use the array index in the `path`. For example, to mark the first phase of a release as complete, use the following request body:  ```   [     {       \"op\": \"replace\",       \"path\": \"/phase/0/complete\",       \"value\": true     }   ] ``` 
         * @summary Patch release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchReleaseByFlagKey(projectKey: string, flagKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchReleaseByFlagKey(projectKey, flagKey, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReleasesBetaApi - factory interface
 * @export
 */
export const ReleasesBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReleasesBetaApiFp(configuration)
    return {
        /**
         * Get currently active release for a flag
         * @summary Get release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseByFlagKey(projectKey: string, flagKey: string, options?: any): AxiosPromise<Release> {
            return localVarFp.getReleaseByFlagKey(projectKey, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update currently active release for a flag. Updating releases requires the [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) format. To learn more, read [Updates](/#section/Overview/Updates).  You can only use this endpoint to mark a release phase complete or incomplete. To indicate which phase to update, use the array index in the `path`. For example, to mark the first phase of a release as complete, use the following request body:  ```   [     {       \"op\": \"replace\",       \"path\": \"/phase/0/complete\",       \"value\": true     }   ] ``` 
         * @summary Patch release for flag
         * @param {string} projectKey The project key
         * @param {string} flagKey The flag key
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReleaseByFlagKey(projectKey: string, flagKey: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Release> {
            return localVarFp.patchReleaseByFlagKey(projectKey, flagKey, patchOperation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleasesBetaApi - object-oriented interface
 * @export
 * @class ReleasesBetaApi
 * @extends {BaseAPI}
 */
export class ReleasesBetaApi extends BaseAPI {
    /**
     * Get currently active release for a flag
     * @summary Get release for flag
     * @param {string} projectKey The project key
     * @param {string} flagKey The flag key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasesBetaApi
     */
    public getReleaseByFlagKey(projectKey: string, flagKey: string, options?: AxiosRequestConfig) {
        return ReleasesBetaApiFp(this.configuration).getReleaseByFlagKey(projectKey, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update currently active release for a flag. Updating releases requires the [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) format. To learn more, read [Updates](/#section/Overview/Updates).  You can only use this endpoint to mark a release phase complete or incomplete. To indicate which phase to update, use the array index in the `path`. For example, to mark the first phase of a release as complete, use the following request body:  ```   [     {       \"op\": \"replace\",       \"path\": \"/phase/0/complete\",       \"value\": true     }   ] ``` 
     * @summary Patch release for flag
     * @param {string} projectKey The project key
     * @param {string} flagKey The flag key
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleasesBetaApi
     */
    public patchReleaseByFlagKey(projectKey: string, flagKey: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return ReleasesBetaApiFp(this.configuration).patchReleaseByFlagKey(projectKey, flagKey, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledChangesApi - axios parameter creator
 * @export
 */
export const ScheduledChangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFlagConfigScheduledChanges', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagScheduledChange: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFeatureFlagScheduledChange', 'id', id)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  <details> <summary>Click to expand instructions for <strong>updating scheduled changes</strong></summary>  #### deleteScheduledChange  Removes the scheduled change.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"deleteScheduledChange\" }] } ```  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [     {       \"kind\": \"updateScheduledChangesExecutionDate\",       \"value\": 1754092860000     }   ] } ```  </details> 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagConfigScheduledChange: async (projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'environmentKey', environmentKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'id', id)
            // verify required parameter 'flagScheduledChangesInput' is not null or undefined
            assertParamExists('patchFlagConfigScheduledChange', 'flagScheduledChangesInput', flagScheduledChangesInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ignoreConflicts !== undefined) {
                localVarQueryParameter['ignoreConflicts'] = ignoreConflicts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flagScheduledChangesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagConfigScheduledChanges: async (projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'environmentKey', environmentKey)
            // verify required parameter 'postFlagScheduledChangesInput' is not null or undefined
            assertParamExists('postFlagConfigScheduledChanges', 'postFlagScheduledChangesInput', postFlagScheduledChangesInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ignoreConflicts !== undefined) {
                localVarQueryParameter['ignoreConflicts'] = ignoreConflicts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFlagScheduledChangesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledChangesApi - functional programming interface
 * @export
 */
export const ScheduledChangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledChangesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChanges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  <details> <summary>Click to expand instructions for <strong>updating scheduled changes</strong></summary>  #### deleteScheduledChange  Removes the scheduled change.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"deleteScheduledChange\" }] } ```  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [     {       \"kind\": \"updateScheduledChangesExecutionDate\",       \"value\": 1754092860000     }   ] } ```  </details> 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagScheduledChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledChangesApi - factory interface
 * @export
 */
export const ScheduledChangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledChangesApiFp(configuration)
    return {
        /**
         * Delete a scheduled changes workflow.
         * @summary Delete scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a scheduled change that will be applied to the feature flag by ID.
         * @summary Get a scheduled change
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of scheduled changes that will be applied to the feature flag.
         * @summary List scheduled changes
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: any): AxiosPromise<FeatureFlagScheduledChanges> {
            return localVarFp.getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  <details> <summary>Click to expand instructions for <strong>updating scheduled changes</strong></summary>  #### deleteScheduledChange  Removes the scheduled change.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"deleteScheduledChange\" }] } ```  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [     {       \"kind\": \"updateScheduledChangesExecutionDate\",       \"value\": 1754092860000     }   ] } ```  </details> 
         * @summary Update scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} id The scheduled change ID
         * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options).then((request) => request(axios, basePath));
        },
        /**
         * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
         * @summary Create scheduled changes workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
         * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: any): AxiosPromise<FeatureFlagScheduledChange> {
            return localVarFp.postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduledChangesApi - object-oriented interface
 * @export
 * @class ScheduledChangesApi
 * @extends {BaseAPI}
 */
export class ScheduledChangesApi extends BaseAPI {
    /**
     * Delete a scheduled changes workflow.
     * @summary Delete scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public deleteFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).deleteFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a scheduled change that will be applied to the feature flag by ID.
     * @summary Get a scheduled change
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public getFeatureFlagScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).getFeatureFlagScheduledChange(projectKey, featureFlagKey, environmentKey, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of scheduled changes that will be applied to the feature flag.
     * @summary List scheduled changes
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public getFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).getFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating scheduled changes.  <details> <summary>Click to expand instructions for <strong>updating scheduled changes</strong></summary>  #### deleteScheduledChange  Removes the scheduled change.  Here\'s an example:  ```json {   \"instructions\": [{ \"kind\": \"deleteScheduledChange\" }] } ```  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - `value`: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are `turnFlagOn` and `turnFlagOff`.  Here\'s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  ```json {   \"instructions\": [     {       \"kind\": \"replaceScheduledChangesInstructions\",       \"value\": [ {\"kind\": \"turnFlagOff\"} ]     }   ] } ```  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - `value`: the new execution date, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [     {       \"kind\": \"updateScheduledChangesExecutionDate\",       \"value\": 1754092860000     }   ] } ```  </details> 
     * @summary Update scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} id The scheduled change ID
     * @param {FlagScheduledChangesInput} flagScheduledChangesInput 
     * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public patchFlagConfigScheduledChange(projectKey: string, featureFlagKey: string, environmentKey: string, id: string, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).patchFlagConfigScheduledChange(projectKey, featureFlagKey, environmentKey, id, flagScheduledChangesInput, ignoreConflicts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create scheduled changes for a feature flag. If the `ignoreConficts` query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
     * @summary Create scheduled changes workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {PostFlagScheduledChangesInput} postFlagScheduledChangesInput 
     * @param {boolean} [ignoreConflicts] Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledChangesApi
     */
    public postFlagConfigScheduledChanges(projectKey: string, featureFlagKey: string, environmentKey: string, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts?: boolean, options?: AxiosRequestConfig) {
        return ScheduledChangesApiFp(this.configuration).postFlagConfigScheduledChanges(projectKey, featureFlagKey, environmentKey, postFlagScheduledChangesInput, ignoreConflicts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('deleteSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
         * @summary List segment memberships for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextInstanceSegmentsMembershipByEnv: async (projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getContextInstanceSegmentsMembershipByEnv', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getContextInstanceSegmentsMembershipByEnv', 'environmentKey', environmentKey)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getContextInstanceSegmentsMembershipByEnv', 'requestBody', requestBody)
            const localVarPath = `/api/v2/projects/{projectKey}/environments/{environmentKey}/segments/evaluate`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of a segment\'s context targets that are scheduled for removal.
         * @summary Get expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getExpiringTargetsForSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of a segment\'s user targets that are scheduled for removal. 
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getExpiringUserTargetsForSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single segment by key.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getSegment', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Get big segment membership for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} contextKey The context key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForContext: async (projectKey: string, environmentKey: string, segmentKey: string, contextKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegmentMembershipForContext', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForContext', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForContext', 'segmentKey', segmentKey)
            // verify required parameter 'contextKey' is not null or undefined
            assertParamExists('getSegmentMembershipForContext', 'contextKey', contextKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts/{contextKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"contextKey"}}`, encodeURIComponent(String(contextKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
         * @summary Get big segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForUser: async (projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'segmentKey', segmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getSegmentMembershipForUser', 'userKey', userKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all segments in the given project.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of segments to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are \&#39;creationDate\&#39;, \&#39;name\&#39;, \&#39;lastModified\&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [filter] Accepts filter by kind, query, tags, unbounded, or external. To filter by kind or query, use the &#x60;equals&#x60; operator. To filter by tags, use the &#x60;anyOf&#x60; operator. Query is a \&#39;fuzzy\&#39; search across segment key, name, and description. Example: &#x60;filter&#x3D;tags anyOf [\&#39;enterprise\&#39;, \&#39;beta\&#39;],query equals \&#39;toggle\&#39;&#x60; returns segments with \&#39;toggle\&#39; in their key, name, or description that also have \&#39;enterprise\&#39; or \&#39;beta\&#39; as a tag. To filter by unbounded, use the &#x60;equals&#x60; operator. Example: &#x60;filter&#x3D;unbounded equals true&#x60;. To filter by external, use the &#x60;exists&#x60; operator. Example: &#x60;filter&#x3D;external exists true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegments: async (projectKey: string, environmentKey: string, limit?: number, offset?: number, sort?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSegments', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSegments', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring context targets.  <details> <summary>Click to expand instructions for <strong>updating expiring context targets</strong></summary>  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754092860000   }] } ```  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The new date when the context should expire from the segment targeting, in Unix milliseconds. - `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754179260000   }] } ```  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",   }] } ```  </details> 
         * @summary Update expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentExpiringTargetInputRep} patchSegmentExpiringTargetInputRep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('patchExpiringTargetsForSegment', 'segmentKey', segmentKey)
            // verify required parameter 'patchSegmentExpiringTargetInputRep' is not null or undefined
            assertParamExists('patchExpiringTargetsForSegment', 'patchSegmentExpiringTargetInputRep', patchSegmentExpiringTargetInputRep)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchSegmentExpiringTargetInputRep, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key.  </details> 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForSegment: async (projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'segmentKey', segmentKey)
            // verify required parameter 'patchSegmentRequest' is not null or undefined
            assertParamExists('patchExpiringUserTargetsForSegment', 'patchSegmentRequest', patchSegmentRequest)
            const localVarPath = `/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchSegmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  <details> <summary>Click to expand instructions for <strong>updating segments</strong></summary>  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### addExcludedTargets  Adds context keys to the individual context targets excluded in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use `removeIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use `removeExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated segment name\"   }] } ```  </details>  ## Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add the new entry to the beginning of the array. Use `/-` to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"contextKind\": \"user\", \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: async (projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('patchSegment', 'segmentKey', segmentKey)
            // verify required parameter 'patchWithComment' is not null or undefined
            assertParamExists('patchSegment', 'patchWithComment', patchWithComment)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWithComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSegment: async (projectKey: string, environmentKey: string, segmentBody: SegmentBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postSegment', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postSegment', 'environmentKey', environmentKey)
            // verify required parameter 'segmentBody' is not null or undefined
            assertParamExists('postSegment', 'segmentBody', segmentBody)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentContextTargets: async (projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('updateBigSegmentContextTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('updateBigSegmentContextTargets', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('updateBigSegmentContextTargets', 'segmentKey', segmentKey)
            // verify required parameter 'segmentUserState' is not null or undefined
            assertParamExists('updateBigSegmentContextTargets', 'segmentUserState', segmentUserState)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentUserState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update user context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentTargets: async (projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'segmentKey', segmentKey)
            // verify required parameter 'segmentUserState' is not null or undefined
            assertParamExists('updateBigSegmentTargets', 'segmentUserState', segmentUserState)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentUserState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
         * @summary List segment memberships for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextInstanceSegmentsMembershipByEnv(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextInstanceSegmentMemberships>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextInstanceSegmentsMembershipByEnv(projectKey, environmentKey, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of a segment\'s context targets that are scheduled for removal.
         * @summary Get expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of a segment\'s user targets that are scheduled for removal. 
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single segment by key.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Get big segment membership for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} contextKey The context key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentMembershipForContext(projectKey: string, environmentKey: string, segmentKey: string, contextKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentMembershipForContext(projectKey, environmentKey, segmentKey, contextKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
         * @summary Get big segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BigSegmentTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all segments in the given project.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of segments to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are \&#39;creationDate\&#39;, \&#39;name\&#39;, \&#39;lastModified\&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [filter] Accepts filter by kind, query, tags, unbounded, or external. To filter by kind or query, use the &#x60;equals&#x60; operator. To filter by tags, use the &#x60;anyOf&#x60; operator. Query is a \&#39;fuzzy\&#39; search across segment key, name, and description. Example: &#x60;filter&#x3D;tags anyOf [\&#39;enterprise\&#39;, \&#39;beta\&#39;],query equals \&#39;toggle\&#39;&#x60; returns segments with \&#39;toggle\&#39; in their key, name, or description that also have \&#39;enterprise\&#39; or \&#39;beta\&#39; as a tag. To filter by unbounded, use the &#x60;equals&#x60; operator. Example: &#x60;filter&#x3D;unbounded equals true&#x60;. To filter by external, use the &#x60;exists&#x60; operator. Example: &#x60;filter&#x3D;external exists true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegments(projectKey: string, environmentKey: string, limit?: number, offset?: number, sort?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegments(projectKey, environmentKey, limit, offset, sort, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring context targets.  <details> <summary>Click to expand instructions for <strong>updating expiring context targets</strong></summary>  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754092860000   }] } ```  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The new date when the context should expire from the segment targeting, in Unix milliseconds. - `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754179260000   }] } ```  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",   }] } ```  </details> 
         * @summary Update expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentExpiringTargetInputRep} patchSegmentExpiringTargetInputRep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentExpiringTargetInputRep, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key.  </details> 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  <details> <summary>Click to expand instructions for <strong>updating segments</strong></summary>  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### addExcludedTargets  Adds context keys to the individual context targets excluded in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use `removeIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use `removeExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated segment name\"   }] } ```  </details>  ## Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add the new entry to the beginning of the array. Use `/-` to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"contextKind\": \"user\", \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSegment(projectKey, environmentKey, segmentBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBigSegmentContextTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBigSegmentContextTargets(projectKey, environmentKey, segmentKey, segmentUserState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update user context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * Delete a segment.
         * @summary Delete segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
         * @summary List segment memberships for context instance
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextInstanceSegmentsMembershipByEnv(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<ContextInstanceSegmentMemberships> {
            return localVarFp.getContextInstanceSegmentsMembershipByEnv(projectKey, environmentKey, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of a segment\'s context targets that are scheduled for removal.
         * @summary Get expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<ExpiringTargetGetResponse> {
            return localVarFp.getExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of a segment\'s user targets that are scheduled for removal. 
         * @summary Get expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single segment by key.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary Get segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.getSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Get big segment membership for context
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} contextKey The context key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForContext(projectKey: string, environmentKey: string, segmentKey: string, contextKey: string, options?: any): AxiosPromise<BigSegmentTarget> {
            return localVarFp.getSegmentMembershipForContext(projectKey, environmentKey, segmentKey, contextKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
         * @summary Get big segment membership for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: any): AxiosPromise<BigSegmentTarget> {
            return localVarFp.getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all segments in the given project.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
         * @summary List segments
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of segments to return. Defaults to 50.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are \&#39;creationDate\&#39;, \&#39;name\&#39;, \&#39;lastModified\&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
         * @param {string} [filter] Accepts filter by kind, query, tags, unbounded, or external. To filter by kind or query, use the &#x60;equals&#x60; operator. To filter by tags, use the &#x60;anyOf&#x60; operator. Query is a \&#39;fuzzy\&#39; search across segment key, name, and description. Example: &#x60;filter&#x3D;tags anyOf [\&#39;enterprise\&#39;, \&#39;beta\&#39;],query equals \&#39;toggle\&#39;&#x60; returns segments with \&#39;toggle\&#39; in their key, name, or description that also have \&#39;enterprise\&#39; or \&#39;beta\&#39; as a tag. To filter by unbounded, use the &#x60;equals&#x60; operator. Example: &#x60;filter&#x3D;unbounded equals true&#x60;. To filter by external, use the &#x60;exists&#x60; operator. Example: &#x60;filter&#x3D;external exists true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegments(projectKey: string, environmentKey: string, limit?: number, offset?: number, sort?: string, filter?: string, options?: any): AxiosPromise<UserSegments> {
            return localVarFp.getSegments(projectKey, environmentKey, limit, offset, sort, filter, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring context targets.  <details> <summary>Click to expand instructions for <strong>updating expiring context targets</strong></summary>  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754092860000   }] } ```  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The new date when the context should expire from the segment targeting, in Unix milliseconds. - `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754179260000   }] } ```  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",   }] } ```  </details> 
         * @summary Update expiring targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentExpiringTargetInputRep} patchSegmentExpiringTargetInputRep 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep, options?: any): AxiosPromise<ExpiringTargetPatchResponse> {
            return localVarFp.patchExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentExpiringTargetInputRep, options).then((request) => request(axios, basePath));
        },
        /**
         *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key.  </details> 
         * @summary Update expiring user targets for segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchSegmentRequest} patchSegmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  <details> <summary>Click to expand instructions for <strong>updating segments</strong></summary>  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### addExcludedTargets  Adds context keys to the individual context targets excluded in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use `removeIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use `removeExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated segment name\"   }] } ```  </details>  ## Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add the new entry to the beginning of the array. Use `/-` to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"contextKind\": \"user\", \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
         * @summary Patch segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {PatchWithComment} patchWithComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new segment.
         * @summary Create segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {SegmentBody} segmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: any): AxiosPromise<UserSegment> {
            return localVarFp.postSegment(projectKey, environmentKey, segmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentContextTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: any): AxiosPromise<void> {
            return localVarFp.updateBigSegmentContextTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
         * @summary Update user context targets on a big segment
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {SegmentUserState} segmentUserState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: any): AxiosPromise<void> {
            return localVarFp.updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * Delete a segment.
     * @summary Delete segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public deleteSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).deleteSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
     * @summary List segment memberships for context instance
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getContextInstanceSegmentsMembershipByEnv(projectKey: string, environmentKey: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getContextInstanceSegmentsMembershipByEnv(projectKey, environmentKey, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of a segment\'s context targets that are scheduled for removal.
     * @summary Get expiring targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get a list of a segment\'s user targets that are scheduled for removal. 
     * @summary Get expiring user targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single segment by key.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
     * @summary Get segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegment(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @summary Get big segment membership for context
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} contextKey The context key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentMembershipForContext(projectKey: string, environmentKey: string, segmentKey: string, contextKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegmentMembershipForContext(projectKey, environmentKey, segmentKey, contextKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
     * @summary Get big segment membership for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentMembershipForUser(projectKey: string, environmentKey: string, segmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegmentMembershipForUser(projectKey, environmentKey, segmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all segments in the given project.<br/><br/>Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
     * @summary List segments
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [limit] The number of segments to return. Defaults to 50.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {string} [sort] Accepts sorting order and fields. Fields can be comma separated. Possible fields are \&#39;creationDate\&#39;, \&#39;name\&#39;, \&#39;lastModified\&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending.
     * @param {string} [filter] Accepts filter by kind, query, tags, unbounded, or external. To filter by kind or query, use the &#x60;equals&#x60; operator. To filter by tags, use the &#x60;anyOf&#x60; operator. Query is a \&#39;fuzzy\&#39; search across segment key, name, and description. Example: &#x60;filter&#x3D;tags anyOf [\&#39;enterprise\&#39;, \&#39;beta\&#39;],query equals \&#39;toggle\&#39;&#x60; returns segments with \&#39;toggle\&#39; in their key, name, or description that also have \&#39;enterprise\&#39; or \&#39;beta\&#39; as a tag. To filter by unbounded, use the &#x60;equals&#x60; operator. Example: &#x60;filter&#x3D;unbounded equals true&#x60;. To filter by external, use the &#x60;exists&#x60; operator. Example: &#x60;filter&#x3D;external exists true&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegments(projectKey: string, environmentKey: string, limit?: number, offset?: number, sort?: string, filter?: string, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).getSegments(projectKey, environmentKey, limit, offset, sort, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring context targets.  <details> <summary>Click to expand instructions for <strong>updating expiring context targets</strong></summary>  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754092860000   }] } ```  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted. - `value`: The new date when the context should expire from the segment targeting, in Unix milliseconds. - `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn\'t match current version of the expiring target.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",     \"value\": 1754179260000   }] } ```  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - `targetType`: The type of individual target for this context. Must be either `included` or `excluded`. - `contextKey`: The context key. - `contextKind`: The kind of context being targeted.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExpiringTarget\",     \"targetType\": \"included\",     \"contextKey\": \"user-key-123abc\",     \"contextKind\": \"user\",   }] } ```  </details> 
     * @summary Update expiring targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {PatchSegmentExpiringTargetInputRep} patchSegmentExpiringTargetInputRep 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchExpiringTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchExpiringTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentExpiringTargetInputRep, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  > ### Contexts are now available > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code `200`. In this case, the response `errors` array will be non-empty.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key. - `value`: The new date when the user should expire from the segment targeting, in Unix milliseconds. - `version`: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - `targetType`: A segment\'s target type, must be either `included` or `excluded`. - `userKey`: The user key.  </details> 
     * @summary Update expiring user targets for segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {PatchSegmentRequest} patchSegmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchExpiringUserTargetsForSegment(projectKey: string, environmentKey: string, segmentKey: string, patchSegmentRequest: PatchSegmentRequest, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchExpiringUserTargetsForSegment(projectKey, environmentKey, segmentKey, patchSegmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:  * `comment` (string): (Optional) A description of the update. * `environmentKey` (string): (Required) The key of the LaunchDarkly environment. * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following `kind` instructions for updating segments.  <details> <summary>Click to expand instructions for <strong>updating segments</strong></summary>  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### addExcludedTargets  Adds context keys to the individual context targets excluded in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - `contextKind`: The context kind the targets should be added to. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use `removeIncludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeIncludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified `contextKind`.  ##### Parameters  - `contextKind`: The context kind the targets should be removed from. - `values`: List of keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedTargets\",     \"contextKind\": \"org\",     \"values\": [ \"org-key-123abc\", \"org-key-456def\" ]   }] } ```  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use `removeExcludedTargets` instead of this instruction.  ##### Parameters  - `values`: List of user keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeExcludedUsers\",     \"values\": [ \"user-key-123abc\", \"user-key-456def\" ]   }] } ```  #### updateName  Updates the name of the segment.  ##### Parameters  - `value`: Name of the segment.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated segment name\"   }] } ```  </details>  ## Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  ```json {   \"patch\": [     {       \"op\": \"replace\",       \"path\": \"/description\",       \"value\": \"new description\"     }   ] } ```  To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add the new entry to the beginning of the array. Use `/-` to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  ```json {   \"patch\":[     {       \"op\": \"add\",       \"path\": \"/rules/0\",       \"value\": {         \"clauses\": [{ \"contextKind\": \"user\", \"attribute\": \"email\", \"op\": \"endsWith\", \"values\": [\".edu\"], \"negate\": false }]       }     }   ] } ```  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
     * @summary Patch segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {PatchWithComment} patchWithComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public patchSegment(projectKey: string, environmentKey: string, segmentKey: string, patchWithComment: PatchWithComment, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).patchSegment(projectKey, environmentKey, segmentKey, patchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new segment.
     * @summary Create segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {SegmentBody} segmentBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public postSegment(projectKey: string, environmentKey: string, segmentBody: SegmentBody, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).postSegment(projectKey, environmentKey, segmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @summary Update context targets on a big segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {SegmentUserState} segmentUserState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public updateBigSegmentContextTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).updateBigSegmentContextTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @summary Update user context targets on a big segment
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {SegmentUserState} segmentUserState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public updateBigSegmentTargets(projectKey: string, environmentKey: string, segmentKey: string, segmentUserState: SegmentUserState, options?: AxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).updateBigSegmentTargets(projectKey, environmentKey, segmentKey, segmentUserState, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsBetaApi - axios parameter creator
 * @export
 */
export const SegmentsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentExport: async (projectKey: string, environmentKey: string, segmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('createBigSegmentExport', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentImport: async (projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('createBigSegmentImport', 'segmentKey', segmentKey)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (mode !== undefined) { 
                localVarFormParams.append('mode', mode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentExport: async (projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getBigSegmentExport', 'segmentKey', segmentKey)
            // verify required parameter 'exportID' is not null or undefined
            assertParamExists('getBigSegmentExport', 'exportID', exportID)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports/{exportID}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"exportID"}}`, encodeURIComponent(String(exportID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentImport: async (projectKey: string, environmentKey: string, segmentKey: string, importID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'environmentKey', environmentKey)
            // verify required parameter 'segmentKey' is not null or undefined
            assertParamExists('getBigSegmentImport', 'segmentKey', segmentKey)
            // verify required parameter 'importID' is not null or undefined
            assertParamExists('getBigSegmentImport', 'importID', importID)
            const localVarPath = `/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports/{importID}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"segmentKey"}}`, encodeURIComponent(String(segmentKey)))
                .replace(`{${"importID"}}`, encodeURIComponent(String(importID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsBetaApi - functional programming interface
 * @export
 */
export const SegmentsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigSegmentExport(projectKey, environmentKey, segmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Export>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Import>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsBetaApi - factory interface
 * @export
 */
export const SegmentsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsBetaApiFp(configuration)
    return {
        /**
         * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.createBigSegmentExport(projectKey, environmentKey, segmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
         * @summary Create big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {any} [file] CSV file containing keys
         * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment export
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} exportID The export ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: any): AxiosPromise<Export> {
            return localVarFp.getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
         * @summary Get big segment import
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} segmentKey The segment key
         * @param {string} importID The import ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: any): AxiosPromise<Import> {
            return localVarFp.getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsBetaApi - object-oriented interface
 * @export
 * @class SegmentsBetaApi
 * @extends {BaseAPI}
 */
export class SegmentsBetaApi extends BaseAPI {
    /**
     * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @summary Create big segment export
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public createBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).createBigSegmentExport(projectKey, environmentKey, segmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
     * @summary Create big segment import
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {any} [file] CSV file containing keys
     * @param {string} [mode] Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public createBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, file?: any, mode?: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).createBigSegmentImport(projectKey, environmentKey, segmentKey, file, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @summary Get big segment export
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} exportID The export ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public getBigSegmentExport(projectKey: string, environmentKey: string, segmentKey: string, exportID: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).getBigSegmentExport(projectKey, environmentKey, segmentKey, exportID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
     * @summary Get big segment import
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} segmentKey The segment key
     * @param {string} importID The import ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsBetaApi
     */
    public getBigSegmentImport(projectKey: string, environmentKey: string, segmentKey: string, importID: string, options?: AxiosRequestConfig) {
        return SegmentsBetaApiFp(this.configuration).getBigSegmentImport(projectKey, environmentKey, segmentKey, importID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {boolean} [archived] Whether or not to return archived flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (kind?: string, pre?: string, archived?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (pre !== undefined) {
                localVarQueryParameter['pre'] = pre;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {boolean} [archived] Whether or not to return archived flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(kind?: string, pre?: string, archived?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(kind, pre, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Get a list of tags.
         * @summary List tags
         * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
         * @param {string} [pre] Return tags with the specified prefix
         * @param {boolean} [archived] Whether or not to return archived flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(kind?: string, pre?: string, archived?: boolean, options?: any): AxiosPromise<TagCollection> {
            return localVarFp.getTags(kind, pre, archived, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Get a list of tags.
     * @summary List tags
     * @param {string} [kind] Fetch tags associated with the specified resource type. Options are &#x60;flag&#x60;, &#x60;project&#x60;, &#x60;environment&#x60;, &#x60;segment&#x60;. Returns all types by default.
     * @param {string} [pre] Return tags with the specified prefix
     * @param {boolean} [archived] Whether or not to return archived flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(kind?: string, pre?: string, archived?: boolean, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(kind, pre, archived, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (teamKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('deleteTeam', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamKey: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeam', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMaintainers: async (teamKey: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeamMaintainers', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/maintainers`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRoles: async (teamKey: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('getTeamRoles', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/roles`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (limit?: number, offset?: number, filter?: string, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs to add.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs to remove.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### replaceMembers  Replaces the existing members of the team with the new members.  ##### Parameters  - `values`: List of member IDs of the new members.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addPermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removePermissionGrants  Removes permission grants from members for the team. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removePermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Updated team description\"   }] } ```  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated team name\"   }] } ```  </details>  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam: async (teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('patchTeam', 'teamKey', teamKey)
            // verify required parameter 'teamPatchInput' is not null or undefined
            assertParamExists('patchTeam', 'teamPatchInput', teamPatchInput)
            const localVarPath = `/api/v2/teams/{teamKey}`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam: async (teamPostInput: TeamPostInput, expand?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamPostInput' is not null or undefined
            assertParamExists('postTeam', 'teamPostInput', teamPostInput)
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"new-team-member@acme.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@acme.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamMembers: async (teamKey: string, file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamKey' is not null or undefined
            assertParamExists('postTeamMembers', 'teamKey', teamKey)
            const localVarPath = `/api/v2/teams/{teamKey}/members`
                .replace(`{${"teamKey"}}`, encodeURIComponent(String(teamKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(teamKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(teamKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamKey: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamKey, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamMaintainers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamMaintainers(teamKey, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamCustomRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamRoles(teamKey, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(limit, offset, filter, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs to add.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs to remove.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### replaceMembers  Replaces the existing members of the team with the new members.  ##### Parameters  - `values`: List of member IDs of the new members.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addPermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removePermissionGrants  Removes permission grants from members for the team. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removePermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Updated team description\"   }] } ```  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated team name\"   }] } ```  </details>  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTeam(teamKey, teamPatchInput, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeam(teamPostInput: TeamPostInput, expand?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeam(teamPostInput, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"new-team-member@acme.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@acme.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeamMembers(teamKey: string, file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamImportsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeamMembers(teamKey, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
         * @summary Delete team
         * @param {string} teamKey The team key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeam(teamKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Get team
         * @param {string} teamKey The team key.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamKey: string, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.getTeam(teamKey, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
         * @summary Get team maintainers
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: any): AxiosPromise<TeamMaintainers> {
            return localVarFp.getTeamMaintainers(teamKey, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
         * @summary Get team custom roles
         * @param {string} teamKey The team key
         * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: any): AxiosPromise<TeamCustomRoles> {
            return localVarFp.getTeamRoles(teamKey, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary List teams
         * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
         * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: any): AxiosPromise<Teams> {
            return localVarFp.getTeams(limit, offset, filter, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs to add.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs to remove.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### replaceMembers  Replaces the existing members of the team with the new members.  ##### Parameters  - `values`: List of member IDs of the new members.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addPermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removePermissionGrants  Removes permission grants from members for the team. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removePermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Updated team description\"   }] } ```  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated team name\"   }] } ```  </details>  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Update team
         * @param {string} teamKey The team key
         * @param {TeamPatchInput} teamPatchInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.patchTeam(teamKey, teamPatchInput, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
         * @summary Create team
         * @param {TeamPostInput} teamPostInput 
         * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam(teamPostInput: TeamPostInput, expand?: string, options?: any): AxiosPromise<Team> {
            return localVarFp.postTeam(teamPostInput, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"new-team-member@acme.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@acme.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
         * @summary Add multiple members to team
         * @param {string} teamKey The team key
         * @param {any} [file] CSV file containing email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamMembers(teamKey: string, file?: any, options?: any): AxiosPromise<TeamImportsRep> {
            return localVarFp.postTeamMembers(teamKey, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Delete a team by key. To learn more, read [Deleting a team](https://docs.launchdarkly.com/home/teams/managing#deleting-a-team).
     * @summary Delete team
     * @param {string} teamKey The team key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(teamKey: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).deleteTeam(teamKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a team by key.  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Get team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Get team
     * @param {string} teamKey The team key.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeam(teamKey: string, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeam(teamKey, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the maintainers that have been assigned to the team. To learn more, read [Managing team maintainers](https://docs.launchdarkly.com/home/teams/managing#managing-team-maintainers).
     * @summary Get team maintainers
     * @param {string} teamKey The team key
     * @param {number} [limit] The number of maintainers to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamMaintainers(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamMaintainers(teamKey, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the custom roles that have been assigned to the team. To learn more, read [Managing team permissions](https://docs.launchdarkly.com/home/teams/managing#managing-team-permissions).
     * @summary Get team custom roles
     * @param {string} teamKey The team key
     * @param {number} [limit] The number of roles to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamRoles(teamKey: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamRoles(teamKey, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of teams.  By default, this returns the first 20 teams. Page through this list with the `limit` parameter and by following the `first`, `prev`, `next`, and `last` links in the `_links` field that returns. If those links do not appear, the pages they refer to don\'t exist. For example, the `first` and `prev` links will be missing from the response on the first page, because there is no previous page and you cannot return to the first page when you are already on the first page.  ### Filtering teams  LaunchDarkly supports the following fields for filters:  - `query` is a string that matches against the teams\' names and keys. It is not case-sensitive.   - A request with `query:abc` returns teams with the string `abc` in their name or key. - `nomembers` is a boolean that filters the list of teams who have 0 members   - A request with `nomembers:true` returns teams that have 0 members   - A request with `nomembers:false` returns teams that have 1 or more members  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"List teams\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary List teams
     * @param {number} [limit] The number of teams to return in the response. Defaults to 20.
     * @param {number} [offset] Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and returns the next &#x60;limit&#x60; items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is constructed as &#x60;field:value&#x60;.
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeams(limit?: number, offset?: number, filter?: string, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeams(limit, offset, filter, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a partial update to a team. Updating a team uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addCustomRoles  Adds custom roles to the team. Team members will have these custom roles granted to them.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### removeCustomRoles  Removes custom roles from the team. The app will no longer grant these custom roles to the team members.  ##### Parameters  - `values`: List of custom role keys.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeCustomRoles\",     \"values\": [ \"example-custom-role\" ]   }] } ```  #### addMembers  Adds members to the team.  ##### Parameters  - `values`: List of member IDs to add.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removeMembers  Removes members from the team.  ##### Parameters  - `values`: List of member IDs to remove.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removeMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### replaceMembers  Replaces the existing members of the team with the new members.  ##### Parameters  - `values`: List of member IDs of the new members.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"replaceMembers\",     \"values\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### addPermissionGrants  Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addPermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### removePermissionGrants  Removes permission grants from members for the team. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The `actionSet` and `actions` must match an existing permission grant.  ##### Parameters  - `actionSet`: Name of the action set. - `actions`: List of actions. - `memberIDs`: List of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"removePermissionGrants\",     \"actions\": [ \"updateTeamName\", \"updateTeamDescription\" ],     \"memberIDs\": [ \"1234a56b7c89d012345e678f\", \"507f1f77bcf86cd799439011\" ]   }] } ```  #### updateDescription  Updates the description of the team.  ##### Parameters  - `value`: The new description.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateDescription\",     \"value\": \"Updated team description\"   }] } ```  #### updateName  Updates the name of the team.  ##### Parameters  - `value`: The new name.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"updateName\",     \"value\": \"Updated team name\"   }] } ```  </details>  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Update team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Update team
     * @param {string} teamKey The team key
     * @param {TeamPatchInput} teamPatchInput 
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public patchTeam(teamKey: string, teamPatchInput: TeamPatchInput, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).patchTeam(teamKey, teamPatchInput, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a team. To learn more, read [Creating a team](https://docs.launchdarkly.com/home/teams/creating).  ### Expanding the teams response LaunchDarkly supports four fields for expanding the \"Create team\" response. By default, these fields are **not** included in the response.  To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:  * `members` includes the total count of members that belong to the team. * `roles` includes a paginated list of the custom roles that you have assigned to the team. * `projects` includes a paginated list of the projects that the team has any write access to. * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.  For example, `expand=members,roles` includes the `members` and `roles` fields in the response. 
     * @summary Create team
     * @param {TeamPostInput} teamPostInput 
     * @param {string} [expand] A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public postTeam(teamPostInput: TeamPostInput, expand?: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).postTeam(teamPostInput, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add multiple members to an existing team by uploading a CSV file of member email addresses. Your CSV file must include email addresses in the first column. You can include data in additional columns, but LaunchDarkly ignores all data outside the first column. Headers are optional. To learn more, read [Managing team members](https://docs.launchdarkly.com/home/teams/managing#managing-team-members).  **Members are only added on a `201` response.** A `207` indicates the CSV file contains a combination of valid and invalid entries. A `207` results in no members being added to the team.  On a `207` response, if an entry contains bad input, the `message` field contains the row number as well as the reason for the error. The `message` field is omitted if the entry is valid.  Example `207` response: ```json {   \"items\": [     {       \"status\": \"success\",       \"value\": \"new-team-member@acme.com\"     },     {       \"message\": \"Line 2: empty row\",       \"status\": \"error\",       \"value\": \"\"     },     {       \"message\": \"Line 3: email already exists in the specified team\",       \"status\": \"error\",       \"value\": \"existing-team-member@acme.com\"     },     {       \"message\": \"Line 4: invalid email formatting\",       \"status\": \"error\",       \"value\": \"invalid email format\"     }   ] } ```  Message | Resolution --- | --- Empty row | This line is blank. Add an email address and try again. Duplicate entry | This email address appears in the file twice. Remove the email from the file and try again. Email already exists in the specified team | This member is already on your team. Remove the email from the file and try again. Invalid formatting | This email address is not formatted correctly. Fix the formatting and try again. Email does not belong to a LaunchDarkly member | The email address doesn\'t belong to a LaunchDarkly account member. Invite them to LaunchDarkly, then re-add them to the team.  On a `400` response, the `message` field may contain errors specific to this endpoint.  Example `400` response: ```json {   \"code\": \"invalid_request\",   \"message\": \"Unable to process file\" } ```  Message | Resolution --- | --- Unable to process file | LaunchDarkly could not process the file for an unspecified reason. Review your file for errors and try again. File exceeds 25mb | Break up your file into multiple files of less than 25mbs each. All emails have invalid formatting | None of the email addresses in the file are in the correct format. Fix the formatting and try again. All emails belong to existing team members | All listed members are already on this team. Populate the file with member emails that do not belong to the team and try again. File is empty | The CSV file does not contain any email addresses. Populate the file and try again. No emails belong to members of your LaunchDarkly organization | None of the email addresses belong to members of your LaunchDarkly account. Invite these members to LaunchDarkly, then re-add them to the team. 
     * @summary Add multiple members to team
     * @param {string} teamKey The team key
     * @param {any} [file] CSV file containing email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public postTeamMembers(teamKey: string, file?: any, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).postTeamMembers(teamKey, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsBetaApi - axios parameter creator
 * @export
 */
export const TeamsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembersToTeams\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\"     ],     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ]   }] } ```  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addAllMembersToTeams\",     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeams: async (teamsPatchInput: TeamsPatchInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamsPatchInput' is not null or undefined
            assertParamExists('patchTeams', 'teamsPatchInput', teamsPatchInput)
            const localVarPath = `/api/v2/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamsPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsBetaApi - functional programming interface
 * @export
 */
export const TeamsBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembersToTeams\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\"     ],     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ]   }] } ```  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addAllMembersToTeams\",     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTeams(teamsPatchInput: TeamsPatchInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkEditTeamsRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTeams(teamsPatchInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsBetaApi - factory interface
 * @export
 */
export const TeamsBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsBetaApiFp(configuration)
    return {
        /**
         * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembersToTeams\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\"     ],     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ]   }] } ```  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addAllMembersToTeams\",     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
         * @summary Update teams
         * @param {TeamsPatchInput} teamsPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeams(teamsPatchInput: TeamsPatchInput, options?: any): AxiosPromise<BulkEditTeamsRep> {
            return localVarFp.patchTeams(teamsPatchInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsBetaApi - object-oriented interface
 * @export
 * @class TeamsBetaApi
 * @extends {BaseAPI}
 */
export class TeamsBetaApi extends BaseAPI {
    /**
     * Perform a partial update to multiple teams. Updating teams uses the semantic patch format.  To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating teams.  <details> <summary>Click to expand instructions for <strong>updating teams</strong></summary>  #### addMembersToTeams  Add the members to teams.  ##### Parameters  - `memberIDs`: List of member IDs to add. - `teamKeys`: List of teams to update.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addMembersToTeams\",     \"memberIDs\": [       \"1234a56b7c89d012345e678f\"     ],     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ]   }] } ```  #### addAllMembersToTeams  Add all members to the team. Members that match any of the filters are **excluded** from the update.  ##### Parameters  - `teamKeys`: List of teams to update. - `filterLastSeen`: (Optional) A JSON object with one of the following formats:   - `{\"never\": true}` - Members that have never been active, such as those who have not accepted their invitation to LaunchDarkly, or have not logged in after being provisioned via SCIM.   - `{\"noData\": true}` - Members that have not been active since LaunchDarkly began recording last seen timestamps.   - `{\"before\": 1608672063611}` - Members that have not been active since the provided value, which should be a timestamp in Unix epoch milliseconds. - `filterQuery`: (Optional) A string that matches against the members\' emails and names. It is not case sensitive. - `filterRoles`: (Optional) A `|` separated list of roles and custom roles. For the purposes of this filtering, `Owner` counts as `Admin`. - `filterTeamKey`: (Optional) A string that matches against the key of the team the members belong to. It is not case sensitive. - `ignoredMemberIDs`: (Optional) A list of member IDs.  Here\'s an example:  ```json {   \"instructions\": [{     \"kind\": \"addAllMembersToTeams\",     \"teamKeys\": [       \"example-team-1\",       \"example-team-2\"     ],     \"filterLastSeen\": { \"never\": true }   }] } ```  </details> 
     * @summary Update teams
     * @param {TeamsPatchInput} teamsPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsBetaApi
     */
    public patchTeams(teamsPatchInput: TeamsPatchInput, options?: AxiosRequestConfig) {
        return TeamsBetaApiFp(this.configuration).patchTeams(teamsPatchInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getExpiringFlagsForUser: async (projectKey: string, userKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'projectKey', projectKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'userKey', userKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getExpiringFlagsForUser', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'userKey', userKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getUserFlagSetting', 'featureFlagKey', featureFlagKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFlagSettings: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUserFlagSettings', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag  </details> 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        patchExpiringFlagsForUser: async (projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'projectKey', projectKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'userKey', userKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'environmentKey', environmentKey)
            // verify required parameter 'patchUsersRequest' is not null or undefined
            assertParamExists('patchExpiringFlagsForUser', 'patchUsersRequest', patchUsersRequest)
            const localVarPath = `/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        putFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('putFlagSetting', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('putFlagSetting', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('putFlagSetting', 'userKey', userKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('putFlagSetting', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'valuePut' is not null or undefined
            assertParamExists('putFlagSetting', 'valuePut', valuePut)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiringFlagsForUser(projectKey, userKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFlagSettings(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag  </details> 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpiringUserTargetPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSettingsApiFp(configuration)
    return {
        /**
         * Get a list of flags for which the given user is scheduled for removal.
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: any): AxiosPromise<ExpiringUserTargetGetResponse> {
            return localVarFp.getExpiringFlagsForUser(projectKey, userKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
         * @summary Get flag setting for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: any): AxiosPromise<UserFlagSetting> {
            return localVarFp.getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
         * @summary List flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserFlagSettings> {
            return localVarFp.getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag  </details> 
         * @summary Update expiring user target for flags
         * @param {string} projectKey The project key
         * @param {string} userKey The user key
         * @param {string} environmentKey The environment key
         * @param {PatchUsersRequest} patchUsersRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: any): AxiosPromise<ExpiringUserTargetPatchResponse> {
            return localVarFp.patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
         * @summary Update flag settings for user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {string} featureFlagKey The feature flag key
         * @param {ValuePut} valuePut 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: any): AxiosPromise<void> {
            return localVarFp.putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     * Get a list of flags for which the given user is scheduled for removal.
     * @summary Get expiring dates on flags for user
     * @param {string} projectKey The project key
     * @param {string} userKey The user key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getExpiringFlagsForUser(projectKey, userKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single flag setting for a user by flag key. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled.
     * @summary Get flag setting for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {string} featureFlagKey The feature flag key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current flag settings for a given user. <br /><br />The `_value` is the flag variation that the user receives. The `setting` indicates whether you\'ve explicitly targeted a user to receive a particular variation. For example, if you have turned off a feature flag for a user, this setting will be `false`. The example response indicates that the user `Abbie_Braun` has the `sort.order` flag enabled and the `alternate.page` flag disabled, and that the user has not been explicitly targeted to receive a particular variation.
     * @summary List flag settings for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.  You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.  Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following `kind` instructions for updating expiring user targets.  <details> <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>  #### addExpireUserTargetDate  Adds a date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.  #### updateExpireUserTargetDate  Updates the date and time that LaunchDarkly will remove the user from the flag\'s individual targeting.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag. * `version`: The version of the expiring user target to update. If included, update will fail if version doesn\'t match current version of the expiring user target.  #### removeExpireUserTargetDate  Removes the scheduled removal of the user from the flag\'s individual targeting. The user will remain part of the flag\'s individual targeting until explicitly removed, or until another removal is scheduled.  ##### Parameters  * `flagKey`: The flag key * `variationId`: ID of a variation on the flag  </details> 
     * @summary Update expiring user target for flags
     * @param {string} projectKey The project key
     * @param {string} userKey The user key
     * @param {string} environmentKey The environment key
     * @param {PatchUsersRequest} patchUsersRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public patchExpiringFlagsForUser(projectKey: string, userKey: string, environmentKey: string, patchUsersRequest: PatchUsersRequest, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).patchExpiringFlagsForUser(projectKey, userKey, environmentKey, patchUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable a feature flag for a user based on their key.  Omitting the `setting` attribute from the request body, or including a `setting` of `null`, erases the current setting for a user.  If you previously patched the flag, and the patch included the user\'s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the user\'s key before, it calculates the flag values based on the user key alone. 
     * @summary Update flag settings for user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {string} featureFlagKey The feature flag key
     * @param {ValuePut} valuePut 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, valuePut: ValuePut, options?: AxiosRequestConfig) {
        return UserSettingsApiFp(this.configuration).putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, valuePut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Delete context instances](/tag/Contexts#operation/deleteContextInstances) instead of this endpoint.  Delete a user by key. 
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUser: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteUser', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('deleteUser', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for context instances](/tag/Contexts#operation/searchContextInstances) instead of this endpoint.  Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Deprecated, use &#x60;searchAfter&#x60; instead. Specifies the first item to return in the collection.
         * @param {number} [after] A Unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSearchUsers: async (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getSearchUsers', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getSearchUsers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/user-search/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchAfter !== undefined) {
                localVarQueryParameter['searchAfter'] = searchAfter;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context instances](/tag/Contexts#operation/getContextInstances) instead of this endpoint.  Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key. 
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUser: async (projectKey: string, environmentKey: string, userKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUser', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUser', 'environmentKey', environmentKey)
            // verify required parameter 'userKey' is not null or undefined
            assertParamExists('getUser', 'userKey', userKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for contexts](/tag/Contexts#operation/searchContexts) instead of this endpoint.  List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsers: async (projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUsers', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUsers', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/users/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchAfter !== undefined) {
                localVarQueryParameter['searchAfter'] = searchAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Delete context instances](/tag/Contexts#operation/deleteContextInstances) instead of this endpoint.  Delete a user by key. 
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for context instances](/tag/Contexts#operation/searchContextInstances) instead of this endpoint.  Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Deprecated, use &#x60;searchAfter&#x60; instead. Specifies the first item to return in the collection.
         * @param {number} [after] A Unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context instances](/tag/Contexts#operation/getContextInstances) instead of this endpoint.  Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key. 
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(projectKey, environmentKey, userKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for contexts](/tag/Contexts#operation/searchContexts) instead of this endpoint.  List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(projectKey, environmentKey, limit, searchAfter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Delete context instances](/tag/Contexts#operation/deleteContextInstances) instead of this endpoint.  Delete a user by key. 
         * @summary Delete user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for context instances](/tag/Contexts#operation/searchContextInstances) instead of this endpoint.  Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary Find users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
         * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
         * @param {number} [offset] Deprecated, use &#x60;searchAfter&#x60; instead. Specifies the first item to return in the collection.
         * @param {number} [after] A Unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
         * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: any): AxiosPromise<Users> {
            return localVarFp.getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context instances](/tag/Contexts#operation/getContextInstances) instead of this endpoint.  Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key. 
         * @summary Get user
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {string} userKey The user key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserRecord> {
            return localVarFp.getUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for contexts](/tag/Contexts#operation/searchContexts) instead of this endpoint.  List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
         * @summary List users
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {number} [limit] The number of elements to return per page
         * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: any): AxiosPromise<UsersRep> {
            return localVarFp.getUsers(projectKey, environmentKey, limit, searchAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Delete context instances](/tag/Contexts#operation/deleteContextInstances) instead of this endpoint.  Delete a user by key. 
     * @summary Delete user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for context instances](/tag/Contexts#operation/searchContextInstances) instead of this endpoint.  Search users in LaunchDarkly based on their last active date, a user attribute filter set, or a search query.  An example user attribute filter set is `filter=firstName:Anna,activeTrial:false`. This matches users that have the user attribute `firstName` set to `Anna`, that also have the attribute `activeTrial` set to `false`.  To paginate through results, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
     * @summary Find users
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} [q] Full-text search for users based on name, first name, last name, e-mail address, or key
     * @param {number} [limit] Specifies the maximum number of items in the collection to return (max: 50, default: 20)
     * @param {number} [offset] Deprecated, use &#x60;searchAfter&#x60; instead. Specifies the first item to return in the collection.
     * @param {number} [after] A Unix epoch time in milliseconds specifying the maximum last time a user requested a feature flag from LaunchDarkly
     * @param {string} [sort] Specifies a field by which to sort. LaunchDarkly supports the &#x60;userKey&#x60; and &#x60;lastSeen&#x60; fields. Fields prefixed by a dash ( - ) sort in descending order.
     * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {string} [filter] A comma-separated list of user attribute filters. Each filter is in the form of attributeKey:attributeValue
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, sort?: string, searchAfter?: string, filter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSearchUsers(projectKey, environmentKey, q, limit, offset, after, sort, searchAfter, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context instances](/tag/Contexts#operation/getContextInstances) instead of this endpoint.  Get a user by key. The `user` object contains all attributes sent in `variation` calls for that key. 
     * @summary Get user
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {string} userKey The user key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(projectKey: string, environmentKey: string, userKey: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Search for contexts](/tag/Contexts#operation/searchContexts) instead of this endpoint.  List all users in the environment. Includes the total count of users. This is useful for exporting all users in the system for further analysis.  Each page displays users up to a set `limit`. The default is 20. To page through, follow the `next` link in the `_links` object. To learn more, read [Representations](/#section/Representations). 
     * @summary List users
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {number} [limit] The number of elements to return per page
     * @param {string} [searchAfter] Limits results to users with sort values after the value you specify. You can use this for pagination, but we recommend using the &#x60;next&#x60; link we provide instead.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(projectKey: string, environmentKey: string, limit?: number, searchAfter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(projectKey, environmentKey, limit, searchAfter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersBetaApi - axios parameter creator
 * @export
 */
export const UsersBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context attribute names ](/tag/Contexts#operation/getContextAttributeNames) instead of this endpoint.  Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days. 
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserAttributeNames: async (projectKey: string, environmentKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getUserAttributeNames', 'projectKey', projectKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getUserAttributeNames', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/user-attributes/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersBetaApi - functional programming interface
 * @export
 */
export const UsersBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context attribute names ](/tag/Contexts#operation/getContextAttributeNames) instead of this endpoint.  Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days. 
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserAttributeNames(projectKey: string, environmentKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAttributeNamesRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAttributeNames(projectKey, environmentKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersBetaApi - factory interface
 * @export
 */
export const UsersBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersBetaApiFp(configuration)
    return {
        /**
         * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context attribute names ](/tag/Contexts#operation/getContextAttributeNames) instead of this endpoint.  Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days. 
         * @summary Get user attribute names
         * @param {string} projectKey The project key
         * @param {string} environmentKey The environment key
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserAttributeNames(projectKey: string, environmentKey: string, options?: any): AxiosPromise<UserAttributeNamesRep> {
            return localVarFp.getUserAttributeNames(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersBetaApi - object-oriented interface
 * @export
 * @class UsersBetaApi
 * @extends {BaseAPI}
 */
export class UsersBetaApi extends BaseAPI {
    /**
     * > ### Use contexts instead > > After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get context attribute names ](/tag/Contexts#operation/getContextAttributeNames) instead of this endpoint.  Get all in-use user attributes in the specified environment. The set of in-use attributes typically consists of all attributes seen within the past 30 days. 
     * @summary Get user attribute names
     * @param {string} projectKey The project key
     * @param {string} environmentKey The environment key
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersBetaApi
     */
    public getUserAttributeNames(projectKey: string, environmentKey: string, options?: AxiosRequestConfig) {
        return UsersBetaApiFp(this.configuration).getUserAttributeNames(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook\'s settings. Updating webhook settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook: async (id: string, patchOperation: Array<PatchOperation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchWebhook', 'id', id)
            // verify required parameter 'patchOperation' is not null or undefined
            assertParamExists('patchWebhook', 'patchOperation', patchOperation)
            const localVarPath = `/api/v2/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (webhookPost: WebhookPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookPost' is not null or undefined
            assertParamExists('postWebhook', 'webhookPost', webhookPost)
            const localVarPath = `/api/v2/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWebhooks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhooks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWebhooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a webhook\'s settings. Updating webhook settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWebhook(id, patchOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(webhookPost: WebhookPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhook(webhookPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a webhook by ID.
         * @summary Delete webhook
         * @param {string} id The ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all webhooks.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(options?: any): AxiosPromise<Webhooks> {
            return localVarFp.getAllWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single webhook by ID.
         * @summary Get webhook
         * @param {string} id The ID of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook\'s settings. Updating webhook settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
         * @summary Update webhook
         * @param {string} id The ID of the webhook to update
         * @param {Array<PatchOperation>} patchOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: any): AxiosPromise<Webhook> {
            return localVarFp.patchWebhook(id, patchOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new webhook.
         * @summary Creates a webhook
         * @param {WebhookPost} webhookPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookPost: WebhookPost, options?: any): AxiosPromise<Webhook> {
            return localVarFp.postWebhook(webhookPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a webhook by ID.
     * @summary Delete webhook
     * @param {string} id The ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all webhooks.
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getAllWebhooks(options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getAllWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single webhook by ID.
     * @summary Get webhook
     * @param {string} id The ID of the webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a webhook\'s settings. Updating webhook settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @summary Update webhook
     * @param {string} id The ID of the webhook to update
     * @param {Array<PatchOperation>} patchOperation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public patchWebhook(id: string, patchOperation: Array<PatchOperation>, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).patchWebhook(id, patchOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new webhook.
     * @summary Creates a webhook
     * @param {WebhookPost} webhookPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhook(webhookPost: WebhookPost, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhook(webhookPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowTemplatesApi - axios parameter creator
 * @export
 */
export const WorkflowTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate: async (createWorkflowTemplateInput: CreateWorkflowTemplateInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowTemplateInput' is not null or undefined
            assertParamExists('createWorkflowTemplate', 'createWorkflowTemplateInput', createWorkflowTemplateInput)
            const localVarPath = `/api/v2/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowTemplateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate: async (templateKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateKey' is not null or undefined
            assertParamExists('deleteWorkflowTemplate', 'templateKey', templateKey)
            const localVarPath = `/api/v2/templates/{templateKey}`
                .replace(`{${"templateKey"}}`, encodeURIComponent(String(templateKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {boolean} [summary] Whether the entire template object or just a summary should be returned
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplates: async (summary?: boolean, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (summary !== undefined) {
                localVarQueryParameter['summary'] = summary;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowTemplatesApi - functional programming interface
 * @export
 */
export const WorkflowTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowTemplate(createWorkflowTemplateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflowTemplate(templateKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflowTemplate(templateKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {boolean} [summary] Whether the entire template object or just a summary should be returned
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowTemplates(summary?: boolean, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplatesListingOutputRep>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowTemplates(summary, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowTemplatesApi - factory interface
 * @export
 */
export const WorkflowTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowTemplatesApiFp(configuration)
    return {
        /**
         * Create a template for a feature flag workflow
         * @summary Create workflow template
         * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: any): AxiosPromise<WorkflowTemplateOutput> {
            return localVarFp.createWorkflowTemplate(createWorkflowTemplateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workflow template
         * @summary Delete workflow template
         * @param {string} templateKey The template key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate(templateKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflowTemplate(templateKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
         * @summary Get workflow templates
         * @param {boolean} [summary] Whether the entire template object or just a summary should be returned
         * @param {string} [search] The substring in either the name or description of a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplates(summary?: boolean, search?: string, options?: any): AxiosPromise<WorkflowTemplatesListingOutputRep> {
            return localVarFp.getWorkflowTemplates(summary, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowTemplatesApi - object-oriented interface
 * @export
 * @class WorkflowTemplatesApi
 * @extends {BaseAPI}
 */
export class WorkflowTemplatesApi extends BaseAPI {
    /**
     * Create a template for a feature flag workflow
     * @summary Create workflow template
     * @param {CreateWorkflowTemplateInput} createWorkflowTemplateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesApi
     */
    public createWorkflowTemplate(createWorkflowTemplateInput: CreateWorkflowTemplateInput, options?: AxiosRequestConfig) {
        return WorkflowTemplatesApiFp(this.configuration).createWorkflowTemplate(createWorkflowTemplateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workflow template
     * @summary Delete workflow template
     * @param {string} templateKey The template key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesApi
     */
    public deleteWorkflowTemplate(templateKey: string, options?: AxiosRequestConfig) {
        return WorkflowTemplatesApiFp(this.configuration).deleteWorkflowTemplate(templateKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get workflow templates belonging to an account, or can optionally return templates_endpoints.workflowTemplateSummariesListingOutputRep when summary query param is true
     * @summary Get workflow templates
     * @param {boolean} [summary] Whether the entire template object or just a summary should be returned
     * @param {string} [search] The substring in either the name or description of a template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplatesApi
     */
    public getWorkflowTemplates(summary?: boolean, search?: string, options?: AxiosRequestConfig) {
        return WorkflowTemplatesApiFp(this.configuration).getWorkflowTemplates(summary, search, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('deleteWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getCustomWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getCustomWorkflow', 'workflowId', workflowId)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} [status] Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;.
         * @param {string} [sort] A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (projectKey: string, featureFlagKey: string, environmentKey: string, status?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('getWorkflows', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('getWorkflows', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('getWorkflows', 'environmentKey', environmentKey)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  For each stage, define the `name`, `conditions` when the stage should be executed, and `action` that describes the stage.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag targeting on and increase feature rollout in 10% increments each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\", // or \"absolute\"               //  If \"scheduleKind\" is \"absolute\", set \"executionDate\";               // \"waitDuration\" and \"waitDurationUnit\" will be ignored           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         },         {           \"kind\": \"ld-approval\",           \"notifyMemberIds\": [ \"507f1f77bcf86cd799439011\" ],           \"notifyTeamKeys\": [ \"team-key-123abc\" ]         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ``` </details>  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dryRun` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dryRun` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ``` </details>  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {boolean} [dryRun] Whether to call the endpoint in dry-run mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow: async (projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            assertParamExists('postWorkflow', 'projectKey', projectKey)
            // verify required parameter 'featureFlagKey' is not null or undefined
            assertParamExists('postWorkflow', 'featureFlagKey', featureFlagKey)
            // verify required parameter 'environmentKey' is not null or undefined
            assertParamExists('postWorkflow', 'environmentKey', environmentKey)
            // verify required parameter 'customWorkflowInput' is not null or undefined
            assertParamExists('postWorkflow', 'customWorkflowInput', customWorkflowInput)
            const localVarPath = `/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (templateKey !== undefined) {
                localVarQueryParameter['templateKey'] = templateKey;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dryRun'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customWorkflowInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} [status] Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;.
         * @param {string} [sort] A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, status?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowsListingOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(projectKey, featureFlagKey, environmentKey, status, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  For each stage, define the `name`, `conditions` when the stage should be executed, and `action` that describes the stage.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag targeting on and increase feature rollout in 10% increments each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\", // or \"absolute\"               //  If \"scheduleKind\" is \"absolute\", set \"executionDate\";               // \"waitDuration\" and \"waitDurationUnit\" will be ignored           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         },         {           \"kind\": \"ld-approval\",           \"notifyMemberIds\": [ \"507f1f77bcf86cd799439011\" ],           \"notifyTeamKeys\": [ \"team-key-123abc\" ]         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ``` </details>  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dryRun` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dryRun` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ``` </details>  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {boolean} [dryRun] Whether to call the endpoint in dry-run mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomWorkflowOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Delete a workflow from a feature flag.
         * @summary Delete workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific workflow by ID.
         * @summary Get custom workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} workflowId The workflow ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: any): AxiosPromise<CustomWorkflowOutput> {
            return localVarFp.getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Display workflows associated with a feature flag.
         * @summary Get workflows
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {string} [status] Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;.
         * @param {string} [sort] A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, status?: string, sort?: string, options?: any): AxiosPromise<CustomWorkflowsListingOutput> {
            return localVarFp.getWorkflows(projectKey, featureFlagKey, environmentKey, status, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  For each stage, define the `name`, `conditions` when the stage should be executed, and `action` that describes the stage.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag targeting on and increase feature rollout in 10% increments each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\", // or \"absolute\"               //  If \"scheduleKind\" is \"absolute\", set \"executionDate\";               // \"waitDuration\" and \"waitDurationUnit\" will be ignored           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         },         {           \"kind\": \"ld-approval\",           \"notifyMemberIds\": [ \"507f1f77bcf86cd799439011\" ],           \"notifyTeamKeys\": [ \"team-key-123abc\" ]         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ``` </details>  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dryRun` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dryRun` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ``` </details>  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
         * @summary Create workflow
         * @param {string} projectKey The project key
         * @param {string} featureFlagKey The feature flag key
         * @param {string} environmentKey The environment key
         * @param {CustomWorkflowInput} customWorkflowInput 
         * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
         * @param {boolean} [dryRun] Whether to call the endpoint in dry-run mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, dryRun?: boolean, options?: any): AxiosPromise<CustomWorkflowOutput> {
            return localVarFp.postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, dryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Delete a workflow from a feature flag.
     * @summary Delete workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} workflowId The workflow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).deleteWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific workflow by ID.
     * @summary Get custom workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} workflowId The workflow ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getCustomWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, workflowId: string, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getCustomWorkflow(projectKey, featureFlagKey, environmentKey, workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Display workflows associated with a feature flag.
     * @summary Get workflows
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {string} [status] Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;.
     * @param {string} [sort] A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflows(projectKey: string, featureFlagKey: string, environmentKey: string, status?: string, sort?: string, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).getWorkflows(projectKey, featureFlagKey, environmentKey, status, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a `stages` array to the request body.  For each stage, define the `name`, `conditions` when the stage should be executed, and `action` that describes the stage.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {   \"name\": \"Progressive rollout starting in two days\",   \"description\": \"Turn flag targeting on and increase feature rollout in 10% increments each day\",   \"stages\": [     {       \"name\": \"10% rollout on day 1\",       \"conditions\": [         {           \"kind\": \"schedule\",           \"scheduleKind\": \"relative\", // or \"absolute\"               //  If \"scheduleKind\" is \"absolute\", set \"executionDate\";               // \"waitDuration\" and \"waitDurationUnit\" will be ignored           \"waitDuration\": 2,           \"waitDurationUnit\": \"calendarDay\"         },         {           \"kind\": \"ld-approval\",           \"notifyMemberIds\": [ \"507f1f77bcf86cd799439011\" ],           \"notifyTeamKeys\": [ \"team-key-123abc\" ]         }       ],       \"action\": {         \"instructions\": [           {             \"kind\": \"turnFlagOn\"           },           {             \"kind\": \"updateFallthroughVariationOrRollout\",             \"rolloutWeights\": {               \"452f5fb5-7320-4ba3-81a1-8f4324f79d49\": 90000,               \"fc15f6a4-05d3-4aa4-a997-446be461345d\": 10000             }           }         ]       }     }   ] } ``` </details>  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the `templateKey` query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a `dryRun` query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the `dryRun` query parameter is present the response body includes a `meta` property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a `valid` field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the `parameters` property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the `parameters` property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  <details> <summary>Click to expand example</summary>  _Example request body_ ```json {  \"name\": \"workflow created from my-template\",  \"description\": \"description of my workflow\",  \"parameters\": [   {    \"_id\": \"62cf2bc4cadbeb7697943f3b\",    \"path\": \"/clauses/0/values\",    \"default\": {     \"value\": [\"updated-segment\"]    }   },   {    \"_id\": \"62cf2bc4cadbeb7697943f3d\",    \"path\": \"/variationId\",    \"default\": {     \"value\": \"abcd1234-abcd-1234-abcd-1234abcd12\"    }   }  ] } ``` </details>  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the `meta` property will be included in the response body detailing which parameters need to be updated. 
     * @summary Create workflow
     * @param {string} projectKey The project key
     * @param {string} featureFlagKey The feature flag key
     * @param {string} environmentKey The environment key
     * @param {CustomWorkflowInput} customWorkflowInput 
     * @param {string} [templateKey] The template key to apply as a starting point for the new workflow
     * @param {boolean} [dryRun] Whether to call the endpoint in dry-run mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public postWorkflow(projectKey: string, featureFlagKey: string, environmentKey: string, customWorkflowInput: CustomWorkflowInput, templateKey?: string, dryRun?: boolean, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).postWorkflow(projectKey, featureFlagKey, environmentKey, customWorkflowInput, templateKey, dryRun, options).then((request) => request(this.axios, this.basePath));
    }
}


